{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":""},{"location":"#overview","title":"Overview","text":"<p>PR-Agent is an open-source, AI-powered code review agent and a community-maintained legacy project of Qodo. It is distinct from Qodo's primary AI code review offering, which provides a feature-rich, context-aware experience. Qodo now offers a free tier that integrates seamlessly with GitHub, GitLab, Bitbucket, and Azure DevOps for high-quality automated reviews.</p> <ul> <li> <p>See the Installation Guide for instructions on installing and running the tool on different git platforms.</p> </li> <li> <p>See the Usage Guide for instructions on running commands via different interfaces, including CLI, online usage, or by automatically triggering them when a new PR is opened.</p> </li> <li> <p>See the Tools Guide for a detailed description of the different tools.</p> </li> </ul>"},{"location":"#docs-smart-search","title":"Docs Smart Search","text":"<p>To search the documentation site using natural language:</p> <p>1) Comment <code>/help \"your question\"</code> in a pull request where PR-Agent is installed</p> <p>2) The bot will respond with an answer that includes relevant documentation links.</p>"},{"location":"#features","title":"Features","text":"<p>PR-Agent offers comprehensive pull request functionalities integrated with various git providers:</p> GitHub GitLab Bitbucket Azure DevOps Gitea TOOLS Describe \u2705 \u2705 \u2705 \u2705 \u2705 Review \u2705 \u2705 \u2705 \u2705 \u2705 Improve \u2705 \u2705 \u2705 \u2705 \u2705 Ask \u2705 \u2705 \u2705 \u2705 \u2b91 Ask on code lines \u2705 \u2705 Add Docs \u2705 \u2705 \u2705 \u2705 Generate Labels \u2705 \u2705 \u2705 \u2705 Similar Issues \u2705 Help \u2705 \u2705 \u2705 \u2705 Help Docs \u2705 \u2705 \u2705 Update CHANGELOG \u2705 \u2705 \u2705 \u2705 USAGE CLI \u2705 \u2705 \u2705 \u2705 \u2705 App / webhook \u2705 \u2705 \u2705 \u2705 \u2705 Tagging bot \u2705 Actions \u2705 \u2705 \u2705 \u2705 CORE Adaptive and token-aware file patch fitting \u2705 \u2705 \u2705 \u2705 Chat on code suggestions \u2705 \u2705 Compression strategy \u2705 \u2705 \u2705 \u2705 Dynamic context \u2705 \u2705 \u2705 \u2705 Fetching ticket context \u2705 \u2705 \u2705 Interactivity \u2705 \u2705 Local and global metadata \u2705 \u2705 \u2705 \u2705 Multiple models support \u2705 \u2705 \u2705 \u2705 Self reflection \u2705 \u2705 \u2705 \u2705"},{"location":"#example-results","title":"Example Results","text":""},{"location":"#describe","title":"/describe","text":""},{"location":"#review","title":"/review","text":""},{"location":"#improve","title":"/improve","text":""},{"location":"#how-it-works","title":"How it Works","text":"<p>The following diagram illustrates PR-Agent tools and their flow:</p> <p></p> <p>Check out the PR Compression strategy page for more details on how we convert a code diff to a manageable LLM prompt</p>"},{"location":"summary/","title":"Table of contents","text":""},{"location":"summary/#table-of-contents","title":"Table of contents","text":"<ul> <li>Overview</li> <li>Data Privacy</li> </ul>"},{"location":"summary/#installation","title":"Installation","text":"<ul> <li>Installation</li> <li>PR-Agent</li> </ul>"},{"location":"summary/#usage-guide","title":"Usage Guide","text":"<ul> <li>Usage Guide</li> <li>Introduction</li> <li>Configuration File</li> <li>Usage and Automation</li> <li>Managing Mail Notifications</li> <li>Changing a Model</li> <li>Additional Configurations</li> <li>Frequently Asked Questions</li> </ul>"},{"location":"summary/#tools","title":"Tools","text":"<ul> <li>Tools</li> <li>Describe</li> <li>Review</li> <li>Improve</li> <li>Ask</li> <li>Add Docs</li> <li>Generate Labels</li> <li>Similar Issues</li> <li>Help</li> <li>Help Docs</li> <li>Update Changelog</li> </ul>"},{"location":"summary/#core-abilities","title":"Core Abilities","text":"<ul> <li>Core Abilities</li> <li>Chat on code suggestions</li> <li>Compression strategy</li> <li>Dynamic context</li> <li>Fetching ticket context</li> <li>Interactivity</li> <li>Local and global metadata</li> <li>Self-reflection</li> </ul>"},{"location":"summary/#pr-benchmark","title":"PR Benchmark","text":"<ul> <li>PR Benchmark</li> </ul>"},{"location":"core-abilities/","title":"Core Abilities","text":""},{"location":"core-abilities/#core-abilities","title":"Core Abilities","text":"<p>PR-Agent utilizes a variety of core abilities to provide a comprehensive and efficient code review experience. These abilities include:</p> <ul> <li>Compression strategy</li> <li>Dynamic context</li> <li>Fetching ticket context</li> <li>Interactivity</li> <li>Local and global metadata</li> <li>Self-reflection</li> </ul>"},{"location":"core-abilities/#blogs","title":"Blogs","text":"<p>Here are some additional technical blogs from Qodo, that delve deeper into the core capabilities and features of Large Language Models (LLMs) when applied to coding tasks. These resources provide more comprehensive insights into leveraging LLMs for software development.</p>"},{"location":"core-abilities/#code-generation-and-llms","title":"Code Generation and LLMs","text":"<ul> <li>Effective AI code suggestions: less is more</li> <li>State-of-the-art Code Generation with AlphaCodium \u2013 From Prompt Engineering to Flow Engineering</li> <li>RAG for a Codebase with 10k Repos</li> </ul>"},{"location":"core-abilities/#development-processes","title":"Development Processes","text":"<ul> <li>Understanding the Challenges and Pain Points of the Pull Request Cycle</li> <li>Introduction to Code Coverage Testing</li> </ul>"},{"location":"core-abilities/#cost-optimization","title":"Cost Optimization","text":"<ul> <li>Reduce Your Costs by 30% When Using GPT for Python Code</li> </ul>"},{"location":"core-abilities/compression_strategy/","title":"Compression strategy","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p>"},{"location":"core-abilities/compression_strategy/#overview","title":"Overview","text":"<p>There are two scenarios:</p> <ol> <li>The PR is small enough to fit in a single prompt (including system and user prompt)</li> <li>The PR is too large to fit in a single prompt (including system and user prompt)</li> </ol> <p>For both scenarios, we first use the following strategy</p>"},{"location":"core-abilities/compression_strategy/#repo-language-prioritization-strategy","title":"Repo language prioritization strategy","text":"<p>We prioritize the languages of the repo based on the following criteria:</p> <ol> <li>Exclude binary files and non code files (e.g. images, pdfs, etc)</li> <li>Given the main languages used in the repo</li> <li>We sort the PR files by the most common languages in the repo (in descending order):</li> <li><code>[[file.py, file2.py],[file3.js, file4.jsx],[readme.md]]</code></li> </ol>"},{"location":"core-abilities/compression_strategy/#small-pr","title":"Small PR","text":"<p>In this case, we can fit the entire PR in a single prompt:</p> <ol> <li>Exclude binary files and non code files (e.g. images, pdfs, etc)</li> <li>We Expand the surrounding context of each patch to 3 lines above and below the patch</li> </ol>"},{"location":"core-abilities/compression_strategy/#large-pr","title":"Large PR","text":""},{"location":"core-abilities/compression_strategy/#motivation","title":"Motivation","text":"<p>Pull Requests can be very long and contain a lot of information with varying degree of relevance to the pr-agent. We want to be able to pack as much information as possible in a single LMM prompt, while keeping the information relevant to the pr-agent.</p>"},{"location":"core-abilities/compression_strategy/#compression-strategy","title":"Compression strategy","text":"<p>We prioritize additions over deletions:</p> <ul> <li>Combine all deleted files into a single list (<code>deleted files</code>)</li> <li>File patches are a list of hunks, remove all hunks of type deletion-only from the hunks in the file patch</li> </ul>"},{"location":"core-abilities/compression_strategy/#adaptive-and-token-aware-file-patch-fitting","title":"Adaptive and token-aware file patch fitting","text":"<p>We use tiktoken to tokenize the patches after the modifications described above, and we use the following strategy to fit the patches into the prompt:</p> <ol> <li>Within each language we sort the files by the number of tokens in the file (in descending order):<ul> <li><code>[[file2.py, file.py],[file4.jsx, file3.js],[readme.md]]</code></li> </ul> </li> <li>Iterate through the patches in the order described above</li> <li>Add the patches to the prompt until the prompt reaches a certain buffer from the max token length</li> <li>If there are still patches left, add the remaining patches as a list called <code>other modified files</code> to the prompt until the prompt reaches the max token length (hard stop), skip the rest of the patches.</li> <li>If we haven't reached the max token length, add the <code>deleted files</code> to the prompt until the prompt reaches the max token length (hard stop), skip the rest of the patches.</li> </ol>"},{"location":"core-abilities/compression_strategy/#example","title":"Example","text":""},{"location":"core-abilities/dynamic_context/","title":"Dynamic context","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p> <p>PR-Agent uses an asymmetric and dynamic context strategy to improve AI analysis of code changes in pull requests. It provides more context before changes than after, and dynamically adjusts the context based on code structure (e.g., enclosing functions or classes). This approach balances providing sufficient context for accurate analysis, while avoiding needle-in-the-haystack information overload that could degrade AI performance or exceed token limits.</p>"},{"location":"core-abilities/dynamic_context/#introduction","title":"Introduction","text":"<p>Pull request code changes are retrieved in a unified diff format, showing three lines of context before and after each modified section, with additions marked by '+' and deletions by '-'.</p> <pre><code>@@ -12,5 +12,5 @@ def func1():\n code line that already existed in the file...\n code line that already existed in the file...\n code line that already existed in the file....\n-code line that was removed in the PR\n+new code line added in the PR\n code line that already existed in the file...\n code line that already existed in the file...\n code line that already existed in the file...\n\n@@ -26,2 +26,4 @@ def func2():\n...\n</code></pre> <p>This unified diff format can be challenging for AI models to interpret accurately, as it provides limited context for understanding the full scope of code changes. The presentation of code using '+', '-', and ' ' symbols to indicate additions, deletions, and unchanged lines respectively also differs from the standard code formatting typically used to train AI models.</p>"},{"location":"core-abilities/dynamic_context/#challenges-of-expanding-the-context-window","title":"Challenges of expanding the context window","text":"<p>While expanding the context window is technically feasible, it presents a more fundamental trade-off:</p> <p>Pros:</p> <ul> <li>Enhanced context allows the model to better comprehend and localize the code changes, results (potentially) in more precise analysis and suggestions. Without enough context, the model may struggle to understand the code changes and provide relevant feedback.</li> </ul> <p>Cons:</p> <ul> <li> <p>Excessive context may overwhelm the model with extraneous information, creating a \"needle in a haystack\" scenario where focusing on the relevant details (the code that actually changed) becomes challenging. LLM quality is known to degrade when the context gets larger. Pull requests often encompass multiple changes across many files, potentially spanning hundreds of lines of modified code. This complexity presents a genuine risk of overwhelming the model with excessive context.</p> </li> <li> <p>Increased context expands the token count, increasing processing time and cost, and may prevent the model from processing the entire pull request in a single pass.</p> </li> </ul>"},{"location":"core-abilities/dynamic_context/#asymmetric-and-dynamic-context","title":"Asymmetric and dynamic context","text":"<p>To address these challenges, PR-Agent employs an asymmetric and dynamic context strategy, providing the model with more focused and relevant context information for each code change.</p> <p>Asymmetric:</p> <p>We start by recognizing that the context preceding a code change is typically more crucial for understanding the modification than the context following it. Consequently, PR-Agent implements an asymmetric context policy, decoupling the context window into two distinct segments: one for the code before the change and another for the code after.</p> <p>By independently adjusting each context window, PR-Agent can supply the model with a more tailored and pertinent context for individual code changes.</p> <p>Dynamic:</p> <p>We also employ a \"dynamic\" context strategy. We start by recognizing that the optimal context for a code change often corresponds to its enclosing code component (e.g., function, class), rather than a fixed number of lines. Consequently, we dynamically adjust the context window based on the code's structure, ensuring the model receives the most pertinent information for each modification.</p> <p>To prevent overwhelming the model with excessive context, we impose a limit on the number of lines searched when identifying the enclosing component. This balance allows for comprehensive understanding while maintaining efficiency and limiting context token usage.</p>"},{"location":"core-abilities/dynamic_context/#appendix-relevant-configuration-options","title":"Appendix - relevant configuration options","text":"<pre><code>[config]\npatch_extension_skip_types =[\".md\",\".txt\"]  # Skip files with these extensions when trying to extend the context\nallow_dynamic_context=true                  # Allow dynamic context extension\nmax_extra_lines_before_dynamic_context = 8  # will try to include up to X extra lines before the hunk in the patch, until we reach an enclosing function or class\npatch_extra_lines_before = 3                # Number of extra lines (+3 default ones) to include before each hunk in the patch\npatch_extra_lines_after = 1                 # Number of extra lines (+3 default ones) to include after each hunk in the patch\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/","title":"Fetching ticket context","text":""},{"location":"core-abilities/fetching_ticket_context/#fetching-ticket-context-for-prs","title":"Fetching Ticket Context for PRs","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p>"},{"location":"core-abilities/fetching_ticket_context/#overview","title":"Overview","text":"<p>PR-Agent streamlines code review workflows by seamlessly connecting with multiple ticket management systems. This integration enriches the review process by automatically surfacing relevant ticket information and context alongside code changes.</p> <p>Ticket systems supported:</p> <ul> <li>GitHub/Gitlab Issues</li> <li>Jira</li> </ul> <p>Ticket data fetched:</p> <ol> <li>Ticket Title</li> <li>Ticket Description</li> <li>Custom Fields (Acceptance criteria)</li> <li>Subtasks (linked tasks)</li> <li>Labels</li> <li>Attached Images/Screenshots</li> </ol>"},{"location":"core-abilities/fetching_ticket_context/#affected-tools","title":"Affected Tools","text":"<p>Ticket Recognition Requirements:</p> <ul> <li>The PR description should contain a link to the ticket or if the branch name starts with the ticket id / number.</li> <li>For Jira tickets, you should follow the instructions in Jira Integration in order to authenticate with Jira.</li> </ul>"},{"location":"core-abilities/fetching_ticket_context/#describe-tool","title":"Describe tool","text":"<p>PR-Agent will recognize the ticket and use the ticket content (title, description, labels) to provide additional context for the code changes. By understanding the reasoning and intent behind modifications, the LLM can offer more insightful and relevant code analysis.</p>"},{"location":"core-abilities/fetching_ticket_context/#review-tool","title":"Review tool","text":"<p>Similarly to the <code>describe</code> tool, the <code>review</code> tool will use the ticket content to provide additional context for the code changes.</p> <p>In addition, this feature will evaluate how well a Pull Request (PR) adheres to its original purpose/intent as defined by the associated ticket or issue mentioned in the PR description. Each ticket will be assigned a label (Compliance/Alignment level), Indicates the degree to which the PR fulfills its original purpose:</p> <ul> <li>Fully Compliant</li> <li>Partially Compliant</li> <li>Not Compliant</li> <li>PR Code Verified</li> </ul> <p></p> <p>A <code>PR Code Verified</code> label indicates the PR code meets ticket requirements, but requires additional manual testing beyond the code scope. For example - validating UI display across different environments (Mac, Windows, mobile, etc.).</p>"},{"location":"core-abilities/fetching_ticket_context/#configuration-options","title":"Configuration options","text":"<p>-</p> <pre><code>By default, the `review` tool will automatically validate if the PR complies with the referenced ticket.\nIf you want to disable this feedback, add the following line to your configuration file:\n\n```toml\n[pr_reviewer]\nrequire_ticket_analysis_review=false\n```\n</code></pre> <p>-</p> <pre><code>If you set:\n```toml\n[pr_reviewer]\ncheck_pr_additional_content=true\n```\n(default: `false`)\n\nthe `review` tool will also validate that the PR code doesn't contain any additional content that is not related to the ticket. If it does, the PR will be labeled at best as `PR Code Verified`, and the `review` tool will provide a comment with the additional unrelated content found in the PR code.\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/#githubgitlab-issues-integration","title":"GitHub/Gitlab Issues Integration","text":"<p>PR-Agent will automatically recognize GitHub/Gitlab issues mentioned in the PR description and fetch the issue content. Examples of valid GitHub/Gitlab issue references:</p> <ul> <li><code>https://github.com/&lt;ORG_NAME&gt;/&lt;REPO_NAME&gt;/issues/&lt;ISSUE_NUMBER&gt;</code> or <code>https://gitlab.com/&lt;ORG_NAME&gt;/&lt;REPO_NAME&gt;/-/issues/&lt;ISSUE_NUMBER&gt;</code></li> <li><code>#&lt;ISSUE_NUMBER&gt;</code></li> <li><code>&lt;ORG_NAME&gt;/&lt;REPO_NAME&gt;#&lt;ISSUE_NUMBER&gt;</code></li> </ul> <p>Branch names can also be used to link issues, for example: - <code>123-fix-bug</code> (where <code>123</code> is the issue number)</p> <p>Since PR-Agent is integrated with GitHub, it doesn't require any additional configuration to fetch GitHub issues.</p>"},{"location":"core-abilities/fetching_ticket_context/#jira-integration","title":"Jira Integration","text":"<p>We support both Jira Cloud and Jira Server/Data Center.</p>"},{"location":"core-abilities/fetching_ticket_context/#jira-cloud","title":"Jira Cloud","text":""},{"location":"core-abilities/fetching_ticket_context/#emailtoken-authentication","title":"Email/Token Authentication","text":"<p>You can create an API token from your Atlassian account:</p> <ol> <li> <p>Log in to https://id.atlassian.com/manage-profile/security/api-tokens.</p> </li> <li> <p>Click Create API token.</p> </li> <li> <p>From the dialog that appears, enter a name for your new token and click Create.</p> </li> <li> <p>Click Copy to clipboard.</p> </li> </ol> <p></p> <ol> <li>In your configuration file add the following lines:</li> </ol> <pre><code>[jira]\njira_api_token = \"YOUR_API_TOKEN\"\njira_api_email = \"YOUR_EMAIL\"\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/#jira-data-centerserver","title":"Jira Data Center/Server","text":""},{"location":"core-abilities/fetching_ticket_context/#using-basic-authentication-for-jira-data-centerserver","title":"Using Basic Authentication for Jira Data Center/Server","text":"<p>You can use your Jira username and password to authenticate with Jira Data Center/Server.</p> <p>In your Configuration file/Environment variables/Secrets file, add the following lines:</p> <pre><code>jira_api_email = \"your_username\"\njira_api_token = \"your_password\"\n</code></pre> <p>(Note that indeed the 'jira_api_email' field is used for the username, and the 'jira_api_token' field is used for the user password.)</p>"},{"location":"core-abilities/fetching_ticket_context/#validating-basic-authentication-via-python-script","title":"Validating Basic authentication via Python script","text":"<p>If you are facing issues retrieving tickets in PR-Agent with Basic auth, you can validate the flow using a Python script. This following steps will help you check if the basic auth is working correctly, and if you can access the Jira ticket details:</p> <ol> <li> <p>run <code>pip install jira==3.8.0</code></p> </li> <li> <p>run the following Python script (after replacing the placeholders with your actual values):</p> </li> </ol> Script to validate basic auth <pre><code>from jira import JIRA\n\n\nif __name__ == \"__main__\":\n    try:\n        # Jira server URL\n        server = \"https://...\"\n        # Basic auth\n        username = \"...\"\n        password = \"...\"\n        # Jira ticket code (e.g. \"PROJ-123\")\n        ticket_id = \"...\"\n\n        print(\"Initializing JiraServerTicketProvider with JIRA server\")\n        # Initialize JIRA client\n        jira = JIRA(\n            server=server,\n            basic_auth=(username, password),\n            timeout=30\n        )\n        if jira:\n            print(f\"JIRA client initialized successfully\")\n        else:\n            print(\"Error initializing JIRA client\")\n\n        # Fetch ticket details\n        ticket = jira.issue(ticket_id)\n        print(f\"Ticket title: {ticket.fields.summary}\")\n\n    except Exception as e:\n        print(f\"Error fetching JIRA ticket details: {e}\")\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/#using-a-personal-access-token-pat-for-jira-data-centerserver","title":"Using a Personal Access Token (PAT) for Jira Data Center/Server","text":"<ol> <li>Create a Personal Access Token (PAT) in your Jira account</li> <li>In your Configuration file/Environment variables/Secrets file, add the following lines:</li> </ol> <pre><code>[jira]\njira_base_url = \"YOUR_JIRA_BASE_URL\" # e.g. https://jira.example.com\njira_api_token = \"YOUR_API_TOKEN\"\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/#validating-pat-token-via-python-script","title":"Validating PAT token via Python script","text":"<p>If you are facing issues retrieving tickets in PR-Agent with PAT token, you can validate the flow using a Python script. This following steps will help you check if the token is working correctly, and if you can access the Jira ticket details:</p> <ol> <li> <p>run <code>pip install jira==3.8.0</code></p> </li> <li> <p>run the following Python script (after replacing the placeholders with your actual values):</p> </li> </ol> Script to validate PAT token <pre><code>from jira import JIRA\n\n\nif __name__ == \"__main__\":\n    try:\n        # Jira server URL\n        server = \"https://...\"\n        # Jira PAT token\n        token_auth = \"...\"\n        # Jira ticket code (e.g. \"PROJ-123\")\n        ticket_id = \"...\"\n\n        print(\"Initializing JiraServerTicketProvider with JIRA server\")\n        # Initialize JIRA client\n        jira = JIRA(\n            server=server,\n            token_auth=token_auth,\n            timeout=30\n        )\n        if jira:\n            print(f\"JIRA client initialized successfully\")\n        else:\n            print(\"Error initializing JIRA client\")\n\n        # Fetch ticket details\n        ticket = jira.issue(ticket_id)\n        print(f\"Ticket title: {ticket.fields.summary}\")\n\n    except Exception as e:\n        print(f\"Error fetching JIRA ticket details: {e}\")\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/#multi-jira-server-configuration","title":"Multi-JIRA Server Configuration","text":"<p>PR-Agent supports connecting to multiple JIRA servers using different authentication methods.</p> Email/Token (Basic Auth)PAT Auth <p>Configure multiple servers using Email/Token authentication:</p> <ul> <li><code>jira_servers</code>: List of JIRA server URLs</li> <li><code>jira_api_token</code>: List of API tokens (for Cloud) or passwords (for Data Center)</li> <li><code>jira_api_email</code>: List of emails (for Cloud) or usernames (for Data Center)</li> <li><code>jira_base_url</code>: Default server for ticket IDs like <code>PROJ-123</code>, Each repository can configure (local config file) its own <code>jira_base_url</code> to choose which server to use by default.</li> </ul> <p>Example Configuration: </p><pre><code>[jira]\n# Server URLs\njira_servers = [\"https://company.atlassian.net\", \"https://datacenter.jira.com\"]\n\n# API tokens/passwords\njira_api_token = [\"cloud_api_token_here\", \"datacenter_password\"]\n\n# Emails/usernames (both required)\njira_api_email = [\"user@company.com\", \"datacenter_username\"]\n\n# Default server for ticket IDs\njira_base_url = \"https://company.atlassian.net\"\n</code></pre><p></p> <p>Configure multiple servers using Personal Access Token authentication:</p> <ul> <li><code>jira_servers</code>: List of JIRA server URLs</li> <li><code>jira_api_token</code>: List of PAT tokens</li> <li><code>jira_api_email</code>: Not needed (can be omitted or left empty)</li> <li><code>jira_base_url</code>: Default server for ticket IDs like <code>PROJ-123</code>, Each repository can configure (local config file) its own <code>jira_base_url</code> to choose which server to use by default.</li> </ul> <p>Example Configuration: </p><pre><code>[jira]\n# Server URLs\njira_servers = [\"https://server1.jira.com\", \"https://server2.jira.com\"]\n\n# PAT tokens only\njira_api_token = [\"pat_token_1\", \"pat_token_2\"]\n\n# Default server for ticket IDs\njira_base_url = \"https://server1.jira.com\"\n</code></pre><p></p> <p>Mixed Authentication (Email/Token + PAT): </p><pre><code>[jira]\njira_servers = [\"https://company.atlassian.net\", \"https://server.jira.com\"]\njira_api_token = [\"cloud_api_token\", \"server_pat_token\"]\njira_api_email = [\"user@company.com\", \"\"]  # Empty for PAT\n</code></pre><p></p>"},{"location":"core-abilities/fetching_ticket_context/#how-to-link-a-pr-to-a-jira-ticket","title":"How to link a PR to a Jira ticket","text":"<p>To integrate with Jira, you can link your PR to a ticket using either of these methods:</p> <p>Method 1: Description Reference:</p> <p>Include a ticket reference in your PR description, using either the complete URL format <code>https://&lt;JIRA_ORG&gt;.atlassian.net/browse/ISSUE-123</code> or the shortened ticket ID <code>ISSUE-123</code> (without prefix or suffix for the shortened ID).</p> <p>Method 2: Branch Name Detection:</p> <p>Name your branch with the ticket ID as a prefix (e.g., <code>ISSUE-123-feature-description</code> or <code>ISSUE-123/feature-description</code>).</p> <p>Jira Base URL</p> <p>For shortened ticket IDs or branch detection (method 2 for JIRA cloud), you must configure the Jira base URL in your configuration file under the [jira] section:</p> <p></p><pre><code>[jira]\njira_base_url = \"https://&lt;JIRA_ORG&gt;.atlassian.net\"\n</code></pre> Where <code>&lt;JIRA_ORG&gt;</code> is your Jira organization identifier (e.g., <code>mycompany</code> for <code>https://mycompany.atlassian.net</code>).<p></p>"},{"location":"core-abilities/interactivity/","title":"Interactivity","text":""},{"location":"core-abilities/interactivity/#interactivity","title":"Interactivity","text":"<p><code>Supported Git Platforms: GitHub, GitLab</code></p>"},{"location":"core-abilities/interactivity/#overview","title":"Overview","text":"<p>PR-Agent transforms static code reviews into interactive experiences by enabling direct actions from pull request (PR) comments. Developers can immediately trigger actions and apply changes with simple checkbox clicks.</p> <p>This focused workflow maintains context while dramatically reducing the time between PR creation and final merge. The approach eliminates manual steps, provides clear visual indicators, and creates immediate feedback loops all within the same interface.</p>"},{"location":"core-abilities/interactivity/#key-interactive-features","title":"Key Interactive Features","text":""},{"location":"core-abilities/interactivity/#1-interactive-improve-tool","title":"1. Interactive <code>/improve</code> Tool","text":"<p>The <code>/improve</code> command delivers a comprehensive interactive experience:</p> <ul> <li> <p>Apply this suggestion: Clicking this checkbox instantly converts a suggestion into a committable code change. When committed to the PR, changes made to code that was flagged for improvement will be marked with a check mark, allowing developers to easily track and review implemented recommendations.</p> </li> <li> <p>More: Triggers additional suggestions generation while keeping each suggestion focused and relevant as the original set</p> </li> <li> <p>Update: Triggers a re-analysis of the code, providing updated suggestions based on the latest changes</p> </li> <li> <p>Author self-review: Interactive acknowledgment that developers have opened and reviewed collapsed suggestions</p> </li> </ul>"},{"location":"core-abilities/interactivity/#2-interactive-help-tool","title":"2. Interactive <code>/help</code> Tool","text":"<p>The <code>/help</code> command not only lists available tools and their descriptions but also enables immediate tool invocation through interactive checkboxes. When a user checks a tool's checkbox, PR-Agent instantly triggers that tool without requiring additional commands. This transforms the standard help menu into an interactive launch pad for all PR-Agent capabilities, eliminating context switching by keeping developers within their PR workflow.</p>"},{"location":"core-abilities/metadata/","title":"Local and global metadata","text":""},{"location":"core-abilities/metadata/#local-and-global-metadata-injection-with-multi-stage-analysis","title":"Local and global metadata injection with multi-stage analysis","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p> <p>1. PR-Agent initially retrieves for each PR the following data:</p> <ul> <li>PR title and branch name</li> <li>PR original description</li> <li>Commit messages history</li> <li>PR diff patches, in hunk diff format</li> <li>The entire content of the files that were modified in the PR</li> </ul> <p>Tip: Organization-level metadata</p> <p>In addition to the inputs above, PR-Agent can incorporate supplementary preferences provided by the user, like <code>extra_instructions</code> and <code>organization best practices</code>. This information can be used to enhance the PR analysis.</p> <p>2. By default, the first command that PR-Agent executes is <code>describe</code>, which generates three types of outputs:</p> <ul> <li>PR Type (e.g. bug fix, feature, refactor, etc)</li> <li>PR Description - a bullet point summary of the PR</li> <li>Changes walkthrough - for each modified file, provide a one-line summary followed by a detailed bullet point list of the changes.</li> </ul> <p>These AI-generated outputs are now considered as part of the PR metadata, and can be used in subsequent commands like <code>review</code> and <code>improve</code>. This effectively enables multi-stage chain-of-thought analysis, without doing any additional API calls which will cost time and money.</p> <p>For example, when generating code suggestions for different files, PR-Agent can inject the AI-generated \"Changes walkthrough\" file summary in the prompt:</p> <pre><code>## File: 'src/file1.py'\n### AI-generated file summary:\n- edited function `func1` that does X\n- Removed function `func2` that was not used\n- ....\n\n@@ ... @@ def func1():\n__new hunk__\n11  unchanged code line0\n12  unchanged code line1\n13 +new code line2 added\n14  unchanged code line3\n__old hunk__\n unchanged code line0\n unchanged code line1\n-old code line2 removed\n unchanged code line3\n\n@@ ... @@ def func2():\n__new hunk__\n...\n__old hunk__\n...\n</code></pre> <p>3. The entire PR files that were retrieved are also used to expand and enhance the PR context (see Dynamic Context).</p> <p>4. All the metadata described above represents several level of cumulative analysis - ranging from hunk level, to file level, to PR level, to organization level. This comprehensive approach enables PR-Agent AI models to generate more precise and contextually relevant suggestions and feedback.</p>"},{"location":"core-abilities/self_reflection/","title":"Self-reflection","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p> <p>PR-Agent implements a self-reflection process where the AI model reflects, scores, and re-ranks its own suggestions, eliminating irrelevant or incorrect ones. This approach improves the quality and relevance of suggestions, saving users time and enhancing their experience. Configuration options allow users to set a score threshold for further filtering out suggestions.</p>"},{"location":"core-abilities/self_reflection/#introduction-efficient-review-with-hierarchical-presentation","title":"Introduction - Efficient Review with Hierarchical Presentation","text":"<p>Given that not all generated code suggestions will be relevant, it is crucial to enable users to review them in a fast and efficient way, allowing quick identification and filtering of non-applicable ones.</p> <p>To achieve this goal, PR-Agent offers a dedicated hierarchical structure when presenting suggestions to users:</p> <ul> <li>A \"category\" section groups suggestions by their category, allowing users to quickly dismiss irrelevant suggestions.</li> <li>Each suggestion is first described by a one-line summary, which can be expanded to a full description by clicking on a collapsible.</li> <li>Upon expanding a suggestion, the user receives a more comprehensive description, and a code snippet demonstrating the recommendation.</li> </ul> <p>Fast Review</p> <p>This hierarchical structure is designed to facilitate rapid review of each suggestion, with users spending an average of ~5-10 seconds per item.</p>"},{"location":"core-abilities/self_reflection/#self-reflection-and-re-ranking","title":"Self-reflection and Re-ranking","text":"<p>The AI model is initially tasked with generating suggestions, and outputting them in order of importance. However, in practice we observe that models often struggle to simultaneously generate high-quality code suggestions and rank them well in a single pass. Furthermore, the initial set of generated suggestions sometimes contains easily identifiable errors.</p> <p>To address these issues, we implemented a \"self-reflection\" process that refines suggestion ranking and eliminates irrelevant or incorrect proposals. This process consists of the following steps:</p> <ol> <li>Presenting the generated suggestions to the model in a follow-up call.</li> <li>Instructing the model to score each suggestion on a scale of 0-10 and provide a rationale for the assigned score.</li> <li>Utilizing these scores to re-rank the suggestions and filter out incorrect ones (with a score of 0).</li> <li>Optionally, filtering out all suggestions below a user-defined score threshold.</li> </ol> <p>Note that presenting all generated suggestions simultaneously provides the model with a comprehensive context, enabling it to make more informed decisions compared to evaluating each suggestion individually.</p> <p>To conclude, the self-reflection process enables PR-Agent to prioritize suggestions based on their importance, eliminate inaccurate or irrelevant proposals, and optionally exclude suggestions that fall below a specified threshold of significance. This results in a more refined and valuable set of suggestions for the user, saving time and improving the overall experience.</p>"},{"location":"core-abilities/self_reflection/#example-results","title":"Example Results","text":""},{"location":"core-abilities/self_reflection/#appendix-relevant-configuration-options","title":"Appendix - Relevant Configuration Options","text":"<pre><code>[pr_code_suggestions]\nsuggestions_score_threshold = 0 # Filter out suggestions with a score below this threshold (0-10)\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#faq","title":"FAQ","text":"Q: Can PR-Agent serve as a substitute for a human reviewer? Q: I received an incorrect or irrelevant suggestion. Why? Q: How can I get more tailored suggestions? Q: Will you store my code? Are you using my code to train models? Q: Can PR-Agent review draft/offline PRs? Q: Can the 'Review effort' feedback be calibrated or customized? Q: How to reduce the noise generated by PR-Agent?"},{"location":"faq/#answer1","title":"Answer:1","text":"<p>PR-Agent is designed to assist, not replace, human reviewers.</p> <p>Reviewing PRs is a tedious and time-consuming task often seen as a \"chore\". In addition, the longer the PR \u2013 the shorter the relative feedback, since long PRs can overwhelm reviewers, both in terms of technical difficulty, and the actual review time. PR-Agent aims to address these pain points, and to assist and empower both the PR author and reviewer.</p> <p>However, PR-Agent has built-in safeguards to ensure the developer remains in the driver's seat. For example:</p> <ol> <li>Preserves user's original PR header</li> <li>Places user's description above the AI-generated PR description</li> <li>Won't approve PRs; approval remains reviewer's responsibility</li> <li>The code suggestions are optional, and aim to:<ul> <li>Encourage self-review and self-reflection</li> <li>Highlight potential bugs or oversights</li> <li>Enhance code quality and promote best practices</li> </ul> </li> </ol> <p>Read more about this issue in our blog</p>"},{"location":"faq/#answer2","title":"Answer:2","text":"<ul> <li>Modern AI models, like Claude Sonnet and GPT-5, are improving rapidly but remain imperfect. Users should critically evaluate all suggestions rather than accepting them automatically.</li> <li> <p>AI errors are rare, but possible. A main value from reviewing the code suggestions lies in their high probability of catching mistakes or bugs made by the PR author. We believe it's worth spending 30-60 seconds reviewing suggestions, even if some aren't relevant, as this practice can enhance code quality and prevent bugs in production.</p> </li> <li> <p>The hierarchical structure of the suggestions is designed to help the user quickly understand them, and to decide which ones are relevant and which are not:</p> <ul> <li>Only if the <code>Category</code> header is relevant, the user should move to the summarized suggestion description.</li> <li>Only if the summarized suggestion description is relevant, the user should click on the collapsible, to read the full suggestion description with a code preview example.</li> </ul> </li> <li> <p>In addition, we recommend to use the <code>extra_instructions</code> field to guide the model to suggestions that are more relevant to the specific needs of the project.</p> </li> </ul>"},{"location":"faq/#answer3","title":"Answer:3","text":"<p>See here for more information on how to use the <code>extra_instructions</code> and <code>best_practices</code> configuration options, to guide the model to more tailored suggestions.</p>"},{"location":"faq/#answer4","title":"Answer:4","text":"<p>No. PR-Agent strict privacy policy ensures that your code is not stored or used for training purposes.</p> <p>For a detailed overview of our data privacy policy, please refer to this link</p>"},{"location":"faq/#answer6","title":"Answer:6","text":"<p>Yes. While PR-Agent won't automatically review draft PRs, you can still get feedback by manually requesting it through online commenting.</p> <p>For active PRs, you can customize the automatic feedback settings here to match your team's workflow.</p>"},{"location":"faq/#answer7","title":"Answer:7","text":"<p>Yes, you can customize review effort estimates using the <code>extra_instructions</code> configuration option (see documentation).</p> <p>Example mapping:</p> <ul> <li>Effort 1: &lt; 30 minutes review time</li> <li>Effort 2: 30-60 minutes review time</li> <li>Effort 3: 60-90 minutes review time</li> <li>...</li> </ul> <p>Note: The effort levels (1-5) are primarily meant for comparative purposes, helping teams prioritize reviewing smaller PRs first. The actual review duration may vary, as the focus is on providing consistent relative effort estimates.</p>"},{"location":"faq/#answer3_1","title":"Answer:3","text":"<p>The default configuration of PR-Agent is designed to balance helpful feedback with noise reduction. It reduces noise through several approaches:</p> <ul> <li>Auto-feedback uses three highly structured tools (<code>/describe</code>, <code>/review</code>, and <code>/improve</code>), designed to be accessible at a glance without creating large visual overload</li> <li>Suggestions are presented in a table format rather than as committable comments, which are far noisier</li> <li>The 'File Walkthrough' section is folded by default, as it tends to be verbose</li> <li>Intermediate comments are avoided when creating new PRs (like \"PR-Agent is now reviewing your PR...\"), which would generate email noise</li> </ul> <p>From our experience, especially in large teams or organizations, complaints about \"noise\" sometimes stem from the following issues:</p> <ul> <li>Feedback from multiple bots: When multiple bots provide feedback on the same PR, it creates confusion and noise. We recommend using PR-Agent as the primary feedback tool to streamline the process and reduce redundancy.</li> <li>Getting familiar with the tool: Unlike many tools that provide feedback only on demand, PR-Agent automatically analyzes and suggests improvements for every code change. While this proactive approach can feel intimidating at first, it's designed to continuously enhance code quality and catch bugs and problems when they occur. We recommend reviewing this guide to help align expectations and maximize the value of PR-Agent's auto-feedback.</li> </ul> <p>Therefore, at a global configuration level, we recommend using the default configuration, which is designed to reduce noise while providing valuable feedback.</p> <p>However, if you still find the feedback too noisy, you can adjust the configuration. Since each user and team has different needs, it's definitely possible - and even recommended - to adjust configurations for specific repos as needed. Ways to adjust the configuration for noise reduction include for example:</p> <ul> <li>Score thresholds for code suggestions</li> <li>Utilizing the <code>extra_instructions</code> field for more tailored feedback</li> <li>Controlling which tools run automatically</li> </ul> <p>Note that some users may prefer the opposite - more thorough and detailed feedback. PR-Agent is designed to be flexible and customizable, allowing you to tailor the feedback to your team's specific needs and preferences. Examples of ways to increase feedback include:</p> <ul> <li>Dual-publishing mode</li> <li>Interactive usage</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>There are several ways to use PR-Agent:</p> <ul> <li>Locally</li> <li>GitHub integration</li> <li>GitLab integration</li> <li>BitBucket integration</li> <li>Azure DevOps integration</li> <li>Gitea integration</li> </ul>"},{"location":"installation/azure/","title":"Azure","text":""},{"location":"installation/azure/#azure-devops-pipeline","title":"Azure DevOps Pipeline","text":"<p>You can use a pre-built Action Docker image to run PR-Agent as an Azure DevOps pipeline. Add the following file to your repository under <code>azure-pipelines.yml</code>:</p> <pre><code># Opt out of CI triggers\ntrigger: none\n\n# Configure PR trigger\n# pr:\n#   branches:\n#     include:\n#     - '*'\n#   autoCancel: true\n#   drafts: false\n\n# NOTE for Azure Repos Git:\n# Azure Repos does not honor YAML pr: triggers. Configure Build Validation\n# via Branch Policies instead (see note below). You can safely omit pr:.\n\nstages:\n- stage: pr_agent\n  displayName: 'PR Agent Stage'\n  jobs:\n  - job: pr_agent_job\n    displayName: 'PR Agent Job'\n    pool:\n      vmImage: 'ubuntu-latest'\n    container:\n      image: codiumai/pr-agent:latest\n      options: --entrypoint \"\"\n    variables:\n      - group: pr_agent\n    steps:\n    - script: |\n        echo \"Running PR Agent action step\"\n\n        # Construct PR_URL\n        PR_URL=\"${SYSTEM_COLLECTIONURI}${SYSTEM_TEAMPROJECT}/_git/${BUILD_REPOSITORY_NAME}/pullrequest/${SYSTEM_PULLREQUEST_PULLREQUESTID}\"\n        echo \"PR_URL=$PR_URL\"\n\n        # Extract organization URL from System.CollectionUri\n        ORG_URL=$(echo \"$(System.CollectionUri)\" | sed 's/\\/$//') # Remove trailing slash if present\n        echo \"Organization URL: $ORG_URL\"\n\n        export azure_devops__org=\"$ORG_URL\"\n        export config__git_provider=\"azure\"\n\n        pr-agent --pr_url=\"$PR_URL\" describe\n        pr-agent --pr_url=\"$PR_URL\" review\n        pr-agent --pr_url=\"$PR_URL\" improve\n      env:\n        azure_devops__pat: $(azure_devops_pat)\n        openai__key: $(OPENAI_KEY)\n      displayName: 'Run PR-Agent'\n</code></pre> <p>This script will run PR-Agent on every new merge request, with the <code>improve</code>, <code>review</code>, and <code>describe</code> commands. Note that you need to export the <code>azure_devops__pat</code> and <code>OPENAI_KEY</code> variables in the Azure DevOps pipeline settings (Pipelines -&gt; Library -&gt; + Variable group):</p> <p></p> <p>Make sure to give pipeline permissions to the <code>pr_agent</code> variable group.</p> <p>Note that Azure Pipelines lacks support for triggering workflows from PR comments. If you find a viable solution, please contribute it to our issue tracker</p>"},{"location":"installation/azure/#azure-repos-git-pr-triggers-and-build-validation","title":"Azure Repos Git PR triggers and Build Validation","text":"<p>Azure Repos Git does not use YAML <code>pr:</code> triggers for pipelines. Instead, configure Build Validation on the target branch to run the PR Agent pipeline for pull requests:</p> <ol> <li>Go to Project Settings \u2192 Repositories \u2192 Branches.</li> <li>Select the target branch and open Branch Policies.</li> <li>Under Build Validation, add a policy:</li> <li>Select the PR Agent pipeline (the <code>azure-pipelines.yml</code> above).</li> <li>Set it as Required.</li> <li>Remove the <code>pr:</code> section from your YAML (not needed for Azure Repos Git).</li> </ol> <p>This distinction applies specifically to Azure Repos Git. Other providers like GitHub and Bitbucket Cloud can use YAML-based PR triggers.</p>"},{"location":"installation/azure/#azure-devops-from-cli","title":"Azure DevOps from CLI","text":"<p>To use Azure DevOps provider use the following settings in configuration.toml:</p> <pre><code>[config]\ngit_provider=\"azure\"\n</code></pre> <p>Azure DevOps provider supports PAT token or DefaultAzureCredential authentication. PAT is faster to create, but has built-in expiration date, and will use the user identity for API calls. Using DefaultAzureCredential you can use managed identity or Service principle, which are more secure and will create separate ADO user identity (via AAD) to the agent.</p> <p>If PAT was chosen, you can assign the value in .secrets.toml. If DefaultAzureCredential was chosen, you can assigned the additional env vars like AZURE_CLIENT_SECRET directly, or use managed identity/az cli (for local development) without any additional configuration. in any case, 'org' value must be assigned in .secrets.toml:</p> <pre><code>[azure_devops]\norg = \"https://dev.azure.com/YOUR_ORGANIZATION/\"\n# pat = \"YOUR_PAT_TOKEN\" needed only if using PAT for authentication\n</code></pre>"},{"location":"installation/azure/#azure-devops-webhook","title":"Azure DevOps Webhook","text":"<p>To trigger from an Azure webhook, you need to manually add a webhook. Use the \"Pull request created\" type to trigger a review, or \"Pull request commented on\" to trigger any supported comment with /  comment on the relevant PR. Note that for the \"Pull request commented on\" trigger, only API v2.0 is supported.</p> <p>For webhook security, create a sporadic username/password pair and configure the webhook username and password on both the server and Azure DevOps webhook. These will be sent as basic Auth data by the webhook with each request:</p> <pre><code>[azure_devops_server]\nwebhook_username = \"&lt;basic auth user&gt;\"\nwebhook_password = \"&lt;basic auth password&gt;\"\n</code></pre> <p> Ensure that the webhook endpoint is only accessible over HTTPS to mitigate the risk of credential interception when using basic authentication.</p>"},{"location":"installation/bitbucket/","title":"Bitbucket","text":""},{"location":"installation/bitbucket/#run-as-a-bitbucket-pipeline","title":"Run as a Bitbucket Pipeline","text":"<p>You can use the Bitbucket Pipeline system to run PR-Agent on every pull request open or update.</p> <ol> <li>Add the following file in your repository bitbucket-pipelines.yml</li> </ol> <pre><code>pipelines:\n    pull-requests:\n      '**':\n        - step:\n            name: PR Agent Review\n            image: codiumai/pr-agent:latest\n            script:\n              - pr-agent --pr_url=https://bitbucket.org/$BITBUCKET_WORKSPACE/$BITBUCKET_REPO_SLUG/pull-requests/$BITBUCKET_PR_ID review\n</code></pre> <ol> <li> <p>Add the following secure variables to your repository under Repository settings &gt; Pipelines &gt; Repository variables.</p> </li> <li> <p>CONFIG__GIT_PROVIDER: <code>bitbucket</code></p> </li> <li>OPENAI__KEY: <code>&lt;your key&gt;</code></li> <li>BITBUCKET__AUTH_TYPE: <code>basic</code> or <code>bearer</code> (default is <code>bearer</code>)</li> <li>BITBUCKET__BEARER_TOKEN: <code>&lt;your token&gt;</code> (required when auth_type is bearer)</li> <li>BITBUCKET__BASIC_TOKEN: <code>&lt;your token&gt;</code> (required when auth_type is basic)</li> </ol> <p>You can get a Bitbucket token for your repository by following Repository Settings -&gt; Security -&gt; Access Tokens. For basic auth, you can generate a base64 encoded token from your username:password combination.</p> <p>Note that comments on a PR are not supported in Bitbucket Pipeline.</p>"},{"location":"installation/bitbucket/#bitbucket-server-and-data-center","title":"Bitbucket Server and Data Center","text":"<p>Login into your on-prem instance of Bitbucket with your service account username and password. Navigate to <code>Manage account</code>, <code>HTTP Access tokens</code>, <code>Create Token</code>. Generate the token and add it to .secret.toml under <code>bitbucket_server</code> section</p> <pre><code>[bitbucket_server]\nbearer_token = \"&lt;your key&gt;\"\n</code></pre> <p>Don't forget to also set the URL of your Bitbucket Server instance (either in <code>.secret.toml</code> or in <code>configuration.toml</code>):</p> <pre><code>[bitbucket_server]\nurl = \"&lt;full URL to your Bitbucket instance, e.g.: https://git.bitbucket.com&gt;\"\n</code></pre>"},{"location":"installation/bitbucket/#run-it-as-cli","title":"Run it as CLI","text":"<p>Modify <code>configuration.toml</code>:</p> <pre><code>git_provider=\"bitbucket_server\"\n</code></pre> <p>and pass the Pull request URL:</p> <pre><code>python cli.py --pr_url https://git.on-prem-instance-of-bitbucket.com/projects/PROJECT/repos/REPO/pull-requests/1 review\n</code></pre>"},{"location":"installation/bitbucket/#run-it-as-service","title":"Run it as service","text":"<p>To run PR-Agent as webhook, build the docker image:</p> <pre><code>docker build . -t codiumai/pr-agent:bitbucket_server_webhook --target bitbucket_server_webhook -f docker/Dockerfile\ndocker push codiumai/pr-agent:bitbucket_server_webhook  # Push to your Docker repository\n</code></pre> <p>Navigate to <code>Projects</code> or <code>Repositories</code>, <code>Settings</code>, <code>Webhooks</code>, <code>Create Webhook</code>. Fill in the name and URL. For Authentication, select 'None'. Select the 'Pull Request Opened' checkbox to receive that event as a webhook.</p> <p>The URL should end with <code>/webhook</code>, for example: https://domain.com/webhook</p>"},{"location":"installation/gitea/","title":"Gitea","text":""},{"location":"installation/gitea/#run-a-gitea-webhook-server","title":"Run a Gitea webhook server","text":"<ol> <li> <p>In Gitea create a new user and give it \"Reporter\" role for the intended group or project.</p> </li> <li> <p>For the user from step 1. generate a <code>personal_access_token</code> with <code>api</code> access.</p> </li> <li> <p>Generate a random secret for your app, and save it for later (<code>webhook_secret</code>). For example, you can use:</p> </li> </ol> <pre><code>WEBHOOK_SECRET=$(python -c \"import secrets; print(secrets.token_hex(10))\")\n</code></pre> <ol> <li>Clone this repository:</li> </ol> <pre><code>git clone https://github.com/qodo-ai/pr-agent.git\n</code></pre> <ol> <li> <p>Prepare variables and secrets. Skip this step if you plan on setting these as environment variables when running the agent:</p> <ul> <li>In the configuration file/variables:<ul> <li>Set <code>config.git_provider</code> to \"gitea\"</li> </ul> </li> <li>In the secrets file/variables:<ul> <li>Set your AI model key in the respective section</li> <li>In the [Gitea] section, set <code>personal_access_token</code> (with token from step 2) and <code>webhook_secret</code> (with secret from step 3)</li> </ul> </li> </ul> </li> <li> <p>Build a Docker image for the app and optionally push it to a Docker repository. We'll use Dockerhub as an example:</p> </li> </ol> <pre><code>docker build -f /docker/Dockerfile -t pr-agent:gitea_app --target gitea_app .\ndocker push codiumai/pr-agent:gitea_webhook  # Push to your Docker repository\n</code></pre> <ol> <li>Set the environmental variables, the method depends on your docker runtime. Skip this step if you included your secrets/configuration directly in the Docker image.</li> </ol> <pre><code>CONFIG__GIT_PROVIDER=gitea\nGITEA__PERSONAL_ACCESS_TOKEN=&lt;personal_access_token&gt;\nGITEA__WEBHOOK_SECRET=&lt;webhook_secret&gt;\nGITEA__URL=https://gitea.com # Or self host\nOPENAI__KEY=&lt;your_openai_api_key&gt;\nGITEA__SKIP_SSL_VERIFICATION=false # or true\nGITEA__SSL_CA_CERT=/path/to/cacert.pem\n</code></pre> <ol> <li> <p>Create a webhook in your Gitea project. Set the URL to <code>http[s]://&lt;PR_AGENT_HOSTNAME&gt;/api/v1/gitea_webhooks</code>, the secret token to the generated secret from step 3, and enable the triggers <code>push</code>, <code>comments</code> and <code>merge request events</code>.</p> </li> <li> <p>Test your installation by opening a merge request or commenting on a merge request using one of PR Agent's commands.</p> </li> </ol>"},{"location":"installation/github/","title":"Github","text":"<p>In this page we will cover how to install and run PR-Agent as a GitHub Action or GitHub App, and how to configure it for your needs.</p>"},{"location":"installation/github/#run-as-a-github-action","title":"Run as a GitHub Action","text":"<p>You can use our pre-built Github Action Docker image to run PR-Agent as a Github Action.</p> <p>1) Add the following file to your repository under <code>.github/workflows/pr_agent.yml</code>:</p> <pre><code>on:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    name: Run pr agent on every pull request, respond to user comments\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: qodo-ai/pr-agent@main\n        env:\n          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>2) Add the following secret to your repository under <code>Settings &gt; Secrets and variables &gt; Actions &gt; New repository secret &gt; Add secret</code>:</p> <pre><code>Name = OPENAI_KEY\nSecret = &lt;your key&gt;\n</code></pre> <p>The GITHUB_TOKEN secret is automatically created by GitHub.</p> <p>3) Merge this change to your main branch. When you open your next PR, you should see a comment from <code>github-actions</code> bot with a review of your PR, and instructions on how to use the rest of the tools.</p> <p>4) You may configure PR-Agent by adding environment variables under the env section corresponding to any configurable property in the configuration file. Some examples:</p> <pre><code>      env:\n        # ... previous environment values\n        OPENAI.ORG: \"&lt;Your organization name under your OpenAI account&gt;\"\n        PR_REVIEWER.REQUIRE_TESTS_REVIEW: \"false\" # Disable tests review\n        PR_CODE_SUGGESTIONS.NUM_CODE_SUGGESTIONS: 6 # Increase number of code suggestions\n</code></pre> <p>See detailed usage instructions in the USAGE GUIDE</p>"},{"location":"installation/github/#configuration-examples","title":"Configuration Examples","text":"<p>This section provides detailed, step-by-step examples for configuring PR-Agent with different models and advanced options in GitHub Actions.</p>"},{"location":"installation/github/#quick-start-examples","title":"Quick Start Examples","text":""},{"location":"installation/github/#basic-setup-openai-default","title":"Basic Setup (OpenAI Default)","text":"<p>Copy this minimal workflow to get started with the default OpenAI models:</p> <pre><code>name: PR Agent\non:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    steps:\n      - name: PR Agent action step\n        uses: qodo-ai/pr-agent@main\n        env:\n          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre>"},{"location":"installation/github/#gemini-setup","title":"Gemini Setup","text":"<p>Ready-to-use workflow for Gemini models:</p> <pre><code>name: PR Agent (Gemini)\non:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    steps:\n      - name: PR Agent action step\n        uses: qodo-ai/pr-agent@main\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          config.model: \"gemini/gemini-1.5-flash\"\n          config.fallback_models: '[\"gemini/gemini-1.5-flash\"]'\n          GOOGLE_AI_STUDIO.GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}\n          github_action_config.auto_review: \"true\"\n          github_action_config.auto_describe: \"true\"\n          github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#claude-setup","title":"Claude Setup","text":"<p>Ready-to-use workflow for Claude models:</p> <pre><code>name: PR Agent (Claude)\non:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    steps:\n      - name: PR Agent action step\n        uses: qodo-ai/pr-agent@main\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          config.model: \"anthropic/claude-3-opus-20240229\"\n          config.fallback_models: '[\"anthropic/claude-3-haiku-20240307\"]'\n          ANTHROPIC.KEY: ${{ secrets.ANTHROPIC_KEY }}\n          github_action_config.auto_review: \"true\"\n          github_action_config.auto_describe: \"true\"\n          github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#basic-configuration-with-tool-controls","title":"Basic Configuration with Tool Controls","text":"<p>Start with this enhanced workflow that includes tool configuration:</p> <pre><code>on:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    name: Run pr agent on every pull request, respond to user comments\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: qodo-ai/pr-agent@main\n        env:\n          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          # Enable/disable automatic tools\n          github_action_config.auto_review: \"true\"\n          github_action_config.auto_describe: \"true\"\n          github_action_config.auto_improve: \"true\"\n          # Configure which PR events trigger the action\n          github_action_config.pr_actions: '[\"opened\", \"reopened\", \"ready_for_review\", \"review_requested\"]'\n</code></pre>"},{"location":"installation/github/#switching-models","title":"Switching Models","text":""},{"location":"installation/github/#using-gemini-google-ai-studio","title":"Using Gemini (Google AI Studio)","text":"<p>To use Gemini models instead of the default OpenAI models:</p> <pre><code>      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Set the model to Gemini\n        config.model: \"gemini/gemini-1.5-flash\"\n        config.fallback_models: '[\"gemini/gemini-1.5-flash\"]'\n        # Add your Gemini API key\n        GOOGLE_AI_STUDIO.GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}\n        # Tool configuration\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre> <p>Required Secrets:</p> <ul> <li>Add <code>GEMINI_API_KEY</code> to your repository secrets (get it from Google AI Studio)</li> </ul> <p>Note: When using non-OpenAI models like Gemini, you don't need to set <code>OPENAI_KEY</code> - only the model-specific API key is required.</p>"},{"location":"installation/github/#using-claude-anthropic","title":"Using Claude (Anthropic)","text":"<p>To use Claude models:</p> <pre><code>      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Set the model to Claude\n        config.model: \"anthropic/claude-3-opus-20240229\"\n        config.fallback_models: '[\"anthropic/claude-3-haiku-20240307\"]'\n        # Add your Anthropic API key\n        ANTHROPIC.KEY: ${{ secrets.ANTHROPIC_KEY }}\n        # Tool configuration\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre> <p>Required Secrets:</p> <ul> <li>Add <code>ANTHROPIC_KEY</code> to your repository secrets (get it from Anthropic Console)</li> </ul> <p>Note: When using non-OpenAI models like Claude, you don't need to set <code>OPENAI_KEY</code> - only the model-specific API key is required.</p>"},{"location":"installation/github/#using-azure-openai","title":"Using Azure OpenAI","text":"<p>To use Azure OpenAI services:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.AZURE_OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Azure OpenAI configuration\n        OPENAI.API_TYPE: \"azure\"\n        OPENAI.API_VERSION: \"2023-05-15\"\n        OPENAI.API_BASE: ${{ secrets.AZURE_OPENAI_ENDPOINT }}\n        OPENAI.DEPLOYMENT_ID: ${{ secrets.AZURE_OPENAI_DEPLOYMENT }}\n        # Set the model to match your Azure deployment\n        config.model: \"gpt-4o\"\n        config.fallback_models: '[\"gpt-4o\"]'\n        # Tool configuration\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre> <p>Required Secrets:</p> <ul> <li><code>AZURE_OPENAI_KEY</code>: Your Azure OpenAI API key</li> <li><code>AZURE_OPENAI_ENDPOINT</code>: Your Azure OpenAI endpoint URL</li> <li><code>AZURE_OPENAI_DEPLOYMENT</code>: Your deployment name</li> </ul>"},{"location":"installation/github/#using-local-models-ollama","title":"Using Local Models (Ollama)","text":"<p>To use local models via Ollama:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Set the model to a local Ollama model\n        config.model: \"ollama/qwen2.5-coder:32b\"\n        config.fallback_models: '[\"ollama/qwen2.5-coder:32b\"]'\n        config.custom_model_max_tokens: \"128000\"\n        # Ollama configuration\n        OLLAMA.API_BASE: \"http://localhost:11434\"\n        # Tool configuration\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre> <p>Note: For local models, you'll need to use a self-hosted runner with Ollama installed, as GitHub Actions hosted runners cannot access localhost services.</p>"},{"location":"installation/github/#advanced-configuration-options","title":"Advanced Configuration Options","text":""},{"location":"installation/github/#custom-review-instructions","title":"Custom Review Instructions","text":"<p>Add specific instructions for the review process:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Custom review instructions\n        pr_reviewer.extra_instructions: \"Focus on security vulnerabilities and performance issues. Check for proper error handling.\"\n        # Tool configuration\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#language-specific-configuration","title":"Language-Specific Configuration","text":"<p>Configure for specific programming languages:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Language-specific settings\n        pr_reviewer.extra_instructions: \"Focus on Python best practices, type hints, and docstrings.\"\n        pr_code_suggestions.num_code_suggestions: \"8\"\n        pr_code_suggestions.suggestions_score_threshold: \"7\"\n        # Tool configuration\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#selective-tool-execution","title":"Selective Tool Execution","text":"<p>Run only specific tools automatically:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Only run review and describe, skip improve\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"false\"\n        # Only trigger on PR open and reopen\n        github_action_config.pr_actions: '[\"opened\", \"reopened\"]'\n</code></pre>"},{"location":"installation/github/#using-configuration-files","title":"Using Configuration Files","text":"<p>Instead of setting all options via environment variables, you can use a <code>.pr_agent.toml</code> file in your repository root:</p> <ol> <li>Create a <code>.pr_agent.toml</code> file in your repository root:</li> </ol> <pre><code>[config]\nmodel = \"gemini/gemini-1.5-flash\"\nfallback_models = [\"anthropic/claude-3-opus-20240229\"]\n\n[pr_reviewer]\nextra_instructions = \"Focus on security issues and code quality.\"\n\n[pr_code_suggestions]\nnum_code_suggestions = 6\nsuggestions_score_threshold = 7\n</code></pre> <ol> <li>Use a simpler workflow file:</li> </ol> <pre><code>on:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    name: Run pr agent on every pull request, respond to user comments\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: qodo-ai/pr-agent@main\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GOOGLE_AI_STUDIO.GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}\n          ANTHROPIC.KEY: ${{ secrets.ANTHROPIC_KEY }}\n          github_action_config.auto_review: \"true\"\n          github_action_config.auto_describe: \"true\"\n          github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"installation/github/#model-not-found-errors","title":"Model Not Found Errors","text":"<p>If you get model not found errors:</p> <ol> <li> <p>Check model name format: Ensure you're using the correct model identifier format (e.g., <code>gemini/gemini-1.5-flash</code>, not just <code>gemini-1.5-flash</code>)</p> </li> <li> <p>Verify API keys: Make sure your API keys are correctly set as repository secrets</p> </li> <li> <p>Check model availability: Some models may not be available in all regions or may require specific access</p> </li> </ol>"},{"location":"installation/github/#environment-variable-format","title":"Environment Variable Format","text":"<p>Remember these key points about environment variables:</p> <ul> <li>Use dots (<code>.</code>) or double underscores (<code>__</code>) to separate sections and keys</li> <li>Boolean values should be strings: <code>\"true\"</code> or <code>\"false\"</code></li> <li>Arrays should be JSON strings: <code>'[\"item1\", \"item2\"]'</code></li> <li>Model names are case-sensitive</li> </ul>"},{"location":"installation/github/#rate-limiting","title":"Rate Limiting","text":"<p>If you encounter rate limiting:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Add fallback models for better reliability\n        config.fallback_models: '[\"gpt-4o\", \"gpt-3.5-turbo\"]'\n        # Increase timeout for slower models\n        config.ai_timeout: \"300\"\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#common-error-messages-and-solutions","title":"Common Error Messages and Solutions","text":"<p>Error: \"Model not found\" - Solution: Check the model name format and ensure it matches the exact identifier. See the Changing a model in PR-Agent guide for supported models and their correct identifiers.</p> <p>Error: \"API key not found\" - Solution: Verify that your API key is correctly set as a repository secret and the environment variable name matches exactly - Note: For non-OpenAI models (Gemini, Claude, etc.), you only need the model-specific API key, not <code>OPENAI_KEY</code></p> <p>Error: \"Rate limit exceeded\" - Solution: Add fallback models or increase the <code>config.ai_timeout</code> value</p> <p>Error: \"Permission denied\" - Solution: Ensure your workflow has the correct permissions set:   </p><pre><code>permissions:\n  issues: write\n  pull-requests: write\n  contents: write\n</code></pre><p></p> <p>Error: \"Invalid JSON format\"</p> <ul> <li>Solution: Check that arrays are properly formatted as JSON strings:</li> </ul> <pre><code>Correct:\nconfig.fallback_models: '[\"model1\", \"model2\"]'\nIncorrect (interpreted as a YAML list, not a string):\nconfig.fallback_models: [\"model1\", \"model2\"]\n</code></pre>"},{"location":"installation/github/#debugging-tips","title":"Debugging Tips","text":"<ol> <li>Enable verbose logging: Add <code>config.verbosity_level: \"2\"</code> to see detailed logs</li> <li>Check GitHub Actions logs: Look at the step output for specific error messages</li> <li>Test with minimal configuration: Start with just the basic setup and add options one by one</li> <li>Verify secrets: Double-check that all required secrets are set in your repository settings</li> </ol>"},{"location":"installation/github/#performance-optimization","title":"Performance Optimization","text":"<p>For better performance with large repositories:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Optimize for large PRs\n        config.large_patch_policy: \"clip\"\n        config.max_model_tokens: \"32000\"\n        config.patch_extra_lines_before: \"3\"\n        config.patch_extra_lines_after: \"1\"\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#reference","title":"Reference","text":"<p>For more detailed configuration options, see:</p> <ul> <li>Changing a model in PR-Agent</li> <li>Configuration options</li> <li>Automations and usage</li> </ul>"},{"location":"installation/github/#using-a-specific-release","title":"Using a specific release","text":"<p>if you want to pin your action to a specific release (v0.23 for example) for stability reasons, use: </p><pre><code>...\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: docker://codiumai/pr-agent:0.23-github_action\n...\n</code></pre><p></p> <p>For enhanced security, you can also specify the Docker image by its digest: </p><pre><code>...\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: docker://codiumai/pr-agent@sha256:14165e525678ace7d9b51cda8652c2d74abb4e1d76b57c4a6ccaeba84663cc64\n...\n</code></pre><p></p>"},{"location":"installation/github/#action-for-github-enterprise-server","title":"Action for GitHub enterprise server","text":"<p>To use the action with a GitHub enterprise server, add an environment variable <code>GITHUB.BASE_URL</code> with the API URL of your GitHub server.</p> <p>For example, if your GitHub server is at <code>https://github.mycompany.com</code>, add the following to your workflow file: </p><pre><code>      env:\n        # ... previous environment values\n        GITHUB.BASE_URL: \"https://github.mycompany.com/api/v3\"\n</code></pre><p></p>"},{"location":"installation/github/#run-as-a-github-app","title":"Run as a GitHub App","text":"<p>Allowing you to automate the review process on your private or public repositories.</p> <p>1) Create a GitHub App from the Github Developer Portal.</p> <ul> <li>Set the following permissions:<ul> <li>Pull requests: Read &amp; write</li> <li>Issue comment: Read &amp; write</li> <li>Metadata: Read-only</li> <li>Contents: Read-only</li> </ul> </li> <li>Set the following events:<ul> <li>Issue comment</li> <li>Pull request</li> <li>Push (if you need to enable triggering on PR update)</li> </ul> </li> </ul> <p>2) Generate a random secret for your app, and save it for later. For example, you can use:</p> <pre><code>WEBHOOK_SECRET=$(python -c \"import secrets; print(secrets.token_hex(10))\")\n</code></pre> <p>3) Acquire the following pieces of information from your app's settings page:</p> <ul> <li>App private key (click \"Generate a private key\" and save the file)</li> <li>App ID</li> </ul> <p>4) Clone this repository:</p> <pre><code>git clone https://github.com/qodo-ai/pr-agent.git\n</code></pre> <p>5) Copy the secrets template file and fill in the following:</p> <pre><code>cp pr_agent/settings/.secrets_template.toml pr_agent/settings/.secrets.toml\n# Edit .secrets.toml file\n</code></pre> <ul> <li>Your OpenAI key.</li> <li>Copy your app's private key to the private_key field.</li> <li>Copy your app's ID to the app_id field.</li> <li>Copy your app's webhook secret to the webhook_secret field.</li> <li> <p>Set deployment_type to 'app' in configuration.toml</p> <p>The .secrets.toml file is not copied to the Docker image by default, and is only used for local development. If you want to use the .secrets.toml file in your Docker image, you can add remove it from the .dockerignore file. In most production environments, you would inject the secrets file as environment variables or as mounted volumes. For example, in order to inject a secrets file as a volume in a Kubernetes environment you can update your pod spec to include the following, assuming you have a secret named <code>pr-agent-settings</code> with a key named <code>.secrets.toml</code>:</p> <pre><code>       volumes:\n        - name: settings-volume\n          secret:\n            secretName: pr-agent-settings\n// ...\n       containers:\n// ...\n          volumeMounts:\n            - mountPath: /app/pr_agent/settings_prod\n              name: settings-volume\n</code></pre> <p>Another option is to set the secrets as environment variables in your deployment environment, for example <code>OPENAI.KEY</code> and <code>GITHUB.USER_TOKEN</code>.</p> </li> </ul> <p>6) Build a Docker image for the app and optionally push it to a Docker repository. We'll use Dockerhub as an example:</p> <pre><code>```bash\ndocker build . -t codiumai/pr-agent:github_app --target github_app -f docker/Dockerfile\ndocker push codiumai/pr-agent:github_app  # Push to your Docker repository\n```\n</code></pre> <ol> <li> <p>Host the app using a server, serverless function, or container environment. Alternatively, for development and    debugging, you may use tools like smee.io to forward webhooks to your local machine.     You can check Deploy as a Lambda Function</p> </li> <li> <p>Go back to your app's settings, and set the following:</p> </li> <li> <p>Webhook URL: The URL of your app's server or the URL of the smee.io channel.</p> </li> <li> <p>Webhook secret: The secret you generated earlier.</p> </li> <li> <p>Install the app by navigating to the \"Install App\" tab and selecting your desired repositories.</p> </li> </ol> <p>Note: When running PR-Agent from GitHub app, the default configuration file (configuration.toml) will be loaded. However, you can override the default tool parameters by uploading a local configuration file <code>.pr_agent.toml</code> For more information please check out the USAGE GUIDE</p>"},{"location":"installation/github/#additional-deployment-methods","title":"Additional deployment methods","text":""},{"location":"installation/github/#deploy-as-a-lambda-function","title":"Deploy as a Lambda Function","text":"<p>Note that since AWS Lambda env vars cannot have \".\" in the name, you can replace each \".\" in an env variable with \"__\". For example: <code>GITHUB.WEBHOOK_SECRET</code> --&gt; <code>GITHUB__WEBHOOK_SECRET</code></p> <ol> <li>Follow steps 1-5 from here.</li> <li> <p>Build a docker image that can be used as a lambda function</p> <p><code>shell docker buildx build --platform=linux/amd64 . -t codiumai/pr-agent:github_lambda --target github_lambda -f docker/Dockerfile.lambda</code>    (Note: --target github_lambda is optional as it's the default target)</p> </li> <li> <p>Push image to ECR</p> <pre><code>docker tag codiumai/pr-agent:github_lambda &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:github_lambda\ndocker push &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:github_lambda\n</code></pre> </li> <li> <p>Create a lambda function that uses the uploaded image. Set the lambda timeout to be at least 3m.</p> </li> <li>Configure the lambda function to have a Function URL.</li> <li>In the environment variables of the Lambda function, specify <code>AZURE_DEVOPS_CACHE_DIR</code> to a writable location such as /tmp. (see link)</li> <li>Go back to steps 8-9 of Method 5 with the function url as your Webhook URL.     The Webhook URL would look like <code>https://&lt;LAMBDA_FUNCTION_URL&gt;/api/v1/github_webhooks</code></li> </ol>"},{"location":"installation/github/#using-aws-secrets-manager","title":"Using AWS Secrets Manager","text":"<p>For production Lambda deployments, use AWS Secrets Manager instead of environment variables:</p> <ol> <li>Create a secret in AWS Secrets Manager with JSON format like this:</li> </ol> <pre><code>{\n  \"openai.key\": \"sk-proj-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",\n  \"github.webhook_secret\": \"your-webhook-secret-from-step-2\",\n  \"github.private_key\": \"-----BEGIN RSA PRIVATE KEY-----\\nMIIEpAIBAAKCAQEA...\\n-----END RSA PRIVATE KEY-----\"\n}\n</code></pre> <ol> <li>Add IAM permission <code>secretsmanager:GetSecretValue</code> to your Lambda execution role</li> <li>Set these environment variables in your Lambda:</li> </ol> <pre><code>AWS_SECRETS_MANAGER__SECRET_ARN=arn:aws:secretsmanager:us-east-1:123456789012:secret:pr-agent-secrets-AbCdEf\nCONFIG__SECRET_PROVIDER=aws_secrets_manager\n</code></pre>"},{"location":"installation/github/#aws-codecommit-setup","title":"AWS CodeCommit Setup","text":"<p>Not all features have been added to CodeCommit yet.  As of right now, CodeCommit has been implemented to run the PR-Agent CLI on the command line, using AWS credentials stored in environment variables.  (More features will be added in the future.)  The following is a set of instructions to have PR-Agent do a review of your CodeCommit pull request from the command line:</p> <ol> <li>Create an IAM user that you will use to read CodeCommit pull requests and post comments<ul> <li>Note: That user should have CLI access only, not Console access</li> </ul> </li> <li>Add IAM permissions to that user, to allow access to CodeCommit (see IAM Role example below)</li> <li>Generate an Access Key for your IAM user</li> <li>Set the Access Key and Secret using environment variables (see Access Key example below)</li> <li>Set the <code>git_provider</code> value to <code>codecommit</code> in the <code>pr_agent/settings/configuration.toml</code> settings file</li> <li>Set the <code>PYTHONPATH</code> to include your <code>pr-agent</code> project directory<ul> <li>Option A: Add <code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent</code> to your <code>.env</code> file</li> <li>Option B: Set <code>PYTHONPATH</code> and run the CLI in one command, for example:<ul> <li><code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent python pr_agent/cli.py [--ARGS]</code></li> </ul> </li> </ul> </li> </ol>"},{"location":"installation/github/#aws-codecommit-iam-role-example","title":"AWS CodeCommit IAM Role Example","text":"<p>Example IAM permissions to that user to allow access to CodeCommit:</p> <ul> <li>Note: The following is a working example of IAM permissions that has read access to the repositories and write access to allow posting comments</li> <li>Note: If you only want pr-agent to review your pull requests, you can tighten the IAM permissions further, however this IAM example will work, and allow the pr-agent to post comments to the PR</li> <li>Note: You may want to replace the <code>\"Resource\": \"*\"</code> with your list of repos, to limit access to only those repos</li> </ul> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"codecommit:BatchDescribe*\",\n                \"codecommit:BatchGet*\",\n                \"codecommit:Describe*\",\n                \"codecommit:EvaluatePullRequestApprovalRules\",\n                \"codecommit:Get*\",\n                \"codecommit:List*\",\n                \"codecommit:PostComment*\",\n                \"codecommit:PutCommentReaction\",\n                \"codecommit:UpdatePullRequestDescription\",\n                \"codecommit:UpdatePullRequestTitle\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre>"},{"location":"installation/github/#aws-codecommit-access-key-and-secret","title":"AWS CodeCommit Access Key and Secret","text":"<p>Example setting the Access Key and Secret using environment variables</p> <pre><code>export AWS_ACCESS_KEY_ID=\"XXXXXXXXXXXXXXXX\"\nexport AWS_SECRET_ACCESS_KEY=\"XXXXXXXXXXXXXXXX\"\nexport AWS_DEFAULT_REGION=\"us-east-1\"\n</code></pre>"},{"location":"installation/github/#aws-codecommit-cli-example","title":"AWS CodeCommit CLI Example","text":"<p>After you set up AWS CodeCommit using the instructions above, here is an example CLI run that tells pr-agent to review a given pull request. (Replace your specific PYTHONPATH and PR URL in the example)</p> <pre><code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent\" python pr_agent/cli.py \\\n  --pr_url https://us-east-1.console.aws.amazon.com/codesuite/codecommit/repositories/MY_REPO_NAME/pull-requests/321 \\\n  review\n</code></pre>"},{"location":"installation/gitlab/","title":"Gitlab","text":""},{"location":"installation/gitlab/#run-as-a-gitlab-pipeline","title":"Run as a GitLab Pipeline","text":"<p>You can use a pre-built Action Docker image to run PR-Agent as a GitLab pipeline. This is a simple way to get started with PR-Agent without setting up your own server.</p> <p>(1) Add the following file to your repository under <code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n  - pr_agent\n\npr_agent_job:\n  stage: pr_agent\n  image:\n    name: codiumai/pr-agent:latest\n    entrypoint: [\"\"]\n  script:\n    - cd /app\n    - echo \"Running PR Agent action step\"\n    - export MR_URL=\"$CI_MERGE_REQUEST_PROJECT_URL/merge_requests/$CI_MERGE_REQUEST_IID\"\n    - echo \"MR_URL=$MR_URL\"\n    - export gitlab__url=$CI_SERVER_PROTOCOL://$CI_SERVER_FQDN\n    - export gitlab__PERSONAL_ACCESS_TOKEN=$GITLAB_PERSONAL_ACCESS_TOKEN\n    - export config__git_provider=\"gitlab\"\n    - export openai__key=$OPENAI_KEY\n    - python -m pr_agent.cli --pr_url=\"$MR_URL\" describe\n    - python -m pr_agent.cli --pr_url=\"$MR_URL\" review\n    - python -m pr_agent.cli --pr_url=\"$MR_URL\" improve\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n</code></pre> <p>This script will run PR-Agent on every new merge request. You can modify the <code>rules</code> section to run PR-Agent on different events. You can also modify the <code>script</code> section to run different PR-Agent commands, or with different parameters by exporting different environment variables.</p> <p>(2) Add the following masked variables to your GitLab repository (CI/CD -&gt; Variables):</p> <ul> <li> <p><code>GITLAB_PERSONAL_ACCESS_TOKEN</code>: Your GitLab personal access token.</p> </li> <li> <p><code>OPENAI_KEY</code>: Your OpenAI key.</p> </li> </ul> <p>Note that if your base branches are not protected, don't set the variables as <code>protected</code>, since the pipeline will not have access to them.</p> <p>Note: The <code>$CI_SERVER_FQDN</code> variable is available starting from GitLab version 16.10. If you're using an earlier version, this variable will not be available. However, you can combine <code>$CI_SERVER_HOST</code> and <code>$CI_SERVER_PORT</code> to achieve the same result. Please ensure you're using a compatible version or adjust your configuration.</p> <p>Note: The <code>gitlab__SSL_VERIFY</code> environment variable can be used to specify the path to a custom CA certificate bundle for SSL verification. GitLab exposes the <code>$CI_SERVER_TLS_CA_FILE</code> variable, which points to the custom CA certificate file configured in your GitLab instance. Alternatively, SSL verification can be disabled entirely by setting <code>gitlab__SSL_VERIFY=false</code>, although this is not recommended.</p>"},{"location":"installation/gitlab/#run-a-gitlab-webhook-server","title":"Run a GitLab webhook server","text":"<ol> <li> <p>In GitLab create a new user and give it \"Reporter\" role for the intended group or project.</p> </li> <li> <p>For the user from step 1, generate a <code>personal_access_token</code> with <code>api</code> access.</p> </li> <li> <p>Generate a random secret for your app, and save it for later (<code>shared_secret</code>). For example, you can use:</p> </li> </ol> <pre><code>SHARED_SECRET=$(python -c \"import secrets; print(secrets.token_hex(10))\")\n</code></pre> <ol> <li>Clone this repository:</li> </ol> <pre><code>git clone https://github.com/qodo-ai/pr-agent.git\n</code></pre> <ol> <li> <p>Prepare variables and secrets. Skip this step if you plan on setting these as environment variables when running the agent:</p> <ol> <li> <p>In the configuration file/variables:</p> <ul> <li>Set <code>config.git_provider</code> to \"gitlab\"</li> </ul> </li> <li> <p>In the secrets file/variables:</p> <ul> <li>Set your AI model key in the respective section</li> <li>In the [gitlab] section, set <code>personal_access_token</code> (with token from step 2) and <code>shared_secret</code> (with secret from step 3)</li> <li>Authentication type: Set <code>auth_type</code> to <code>\"private_token\"</code> for older GitLab versions (e.g., 11.x) or private deployments. Default is <code>\"oauth_token\"</code> for gitlab.com and newer versions.</li> </ul> </li> </ol> </li> <li> <p>Build a Docker image for the app and optionally push it to a Docker repository. We'll use Dockerhub as an example:</p> </li> </ol> <pre><code>docker build . -t gitlab_pr_agent --target gitlab_webhook -f docker/Dockerfile\ndocker push codiumai/pr-agent:gitlab_webhook  # Push to your Docker repository\n</code></pre> <ol> <li>Set the environmental variables, the method depends on your docker runtime. Skip this step if you included your secrets/configuration directly in the Docker image.</li> </ol> <pre><code>CONFIG__GIT_PROVIDER=gitlab\nGITLAB__PERSONAL_ACCESS_TOKEN=&lt;personal_access_token&gt;\nGITLAB__SHARED_SECRET=&lt;shared_secret&gt;\nGITLAB__URL=https://gitlab.com\nGITLAB__AUTH_TYPE=oauth_token  # Use \"private_token\" for older GitLab versions\nOPENAI__KEY=&lt;your_openai_api_key&gt;\nPORT=3000  # Optional: override the webhook server port\n</code></pre> <ol> <li> <p>Create a webhook in your GitLab project. Set the URL to <code>http[s]://&lt;PR_AGENT_HOSTNAME&gt;/webhook</code>, the secret token to the generated secret from step 3, and enable the triggers <code>push</code>, <code>comments</code> and <code>merge request events</code>.</p> </li> <li> <p>Test your installation by opening a merge request or commenting on a merge request using one of PR Agent's commands.</p> </li> </ol>"},{"location":"installation/gitlab/#deploy-as-a-lambda-function","title":"Deploy as a Lambda Function","text":"<p>Note that since AWS Lambda env vars cannot have \".\" in the name, you can replace each \".\" in an env variable with \"__\". For example: <code>GITLAB.PERSONAL_ACCESS_TOKEN</code> --&gt; <code>GITLAB__PERSONAL_ACCESS_TOKEN</code></p> <ol> <li>Follow steps 1-5 from Run a GitLab webhook server.</li> <li> <p>Build a docker image that can be used as a lambda function</p> <p><code>shell docker buildx build --platform=linux/amd64 . -t codiumai/pr-agent:gitlab_lambda --target gitlab_lambda -f docker/Dockerfile.lambda</code></p> </li> <li> <p>Push image to ECR</p> <pre><code>docker tag codiumai/pr-agent:gitlab_lambda &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:gitlab_lambda\ndocker push &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:gitlab_lambda\n</code></pre> </li> <li> <p>Create a lambda function that uses the uploaded image. Set the lambda timeout to be at least 3m.</p> </li> <li>Configure the lambda function to have a Function URL.</li> <li>In the environment variables of the Lambda function, specify <code>AZURE_DEVOPS_CACHE_DIR</code> to a writable location such as /tmp. (see link)</li> <li>Go back to steps 8-9 of Run a GitLab webhook server with the function URL as your Webhook URL.     The Webhook URL would look like <code>https://&lt;LAMBDA_FUNCTION_URL&gt;/webhook</code></li> </ol>"},{"location":"installation/gitlab/#using-aws-secrets-manager","title":"Using AWS Secrets Manager","text":"<p>For production Lambda deployments, use AWS Secrets Manager instead of environment variables:</p> <ol> <li>Create individual secrets for each GitLab webhook with this JSON format (e.g., secret name: <code>project-webhook-secret-001</code>)</li> </ol> <pre><code>{\n  \"gitlab_token\": \"glpat-xxxxxxxxxxxxxxxxxxxxxxxx\",\n  \"token_name\": \"project-webhook-001\"\n}\n</code></pre> <ol> <li>Create a main configuration secret for common settings (e.g., secret name: <code>pr-agent-main-config</code>)</li> </ol> <pre><code>{\n  \"openai.key\": \"sk-proj-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n}\n</code></pre> <ol> <li>Set these environment variables in your Lambda:</li> </ol> <pre><code>CONFIG__SECRET_PROVIDER=aws_secrets_manager\nAWS_SECRETS_MANAGER__SECRET_ARN=arn:aws:secretsmanager:us-east-1:123456789012:secret:pr-agent-main-config-AbCdEf\n</code></pre> <ol> <li>In your GitLab webhook configuration, set the Secret Token to the Secret name created in step 1:</li> <li>Example: <code>project-webhook-secret-001</code></li> </ol> <p>Important: When using Secrets Manager, GitLab's webhook secret must be the Secrets Manager secret name.</p> <ol> <li>Add IAM permission <code>secretsmanager:GetSecretValue</code> to your Lambda execution role</li> </ol>"},{"location":"installation/locally/","title":"Locally","text":"<p>To run PR-Agent locally, you first need to acquire two keys:</p> <ol> <li>An OpenAI key from here, with access to GPT-4 and o4-mini (or a key for other language models, if you prefer).</li> <li>A personal access token from your Git platform (GitHub, GitLab, BitBucket,Gitea) with repo scope. GitHub token, for example, can be issued from here</li> </ol>"},{"location":"installation/locally/#using-docker-image","title":"Using Docker image","text":"<p>A list of the relevant tools can be found in the tools guide.</p> <p>To invoke a tool (for example <code>review</code>), you can run PR-Agent directly from the Docker image. Here's how:</p> <ul> <li> <p>For GitHub:</p> <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your_openai_key&gt; -e GITHUB.USER_TOKEN=&lt;your_github_token&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre> <p>If you are using GitHub enterprise server, you need to specify the custom url as variable. For example, if your GitHub server is at <code>https://github.mycompany.com</code>, add the following to the command:</p> <pre><code>-e GITHUB.BASE_URL=https://github.mycompany.com/api/v3\n</code></pre> </li> <li> <p>For GitLab:</p> <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e CONFIG.GIT_PROVIDER=gitlab -e GITLAB.PERSONAL_ACCESS_TOKEN=&lt;your token&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre> <p>If you have a dedicated GitLab instance, you need to specify the custom url as variable:</p> <pre><code>-e GITLAB.URL=&lt;your gitlab instance url&gt;\n</code></pre> </li> <li> <p>For BitBucket:</p> <pre><code>docker run --rm -it -e CONFIG.GIT_PROVIDER=bitbucket -e OPENAI.KEY=$OPENAI_API_KEY -e BITBUCKET.BEARER_TOKEN=$BITBUCKET_BEARER_TOKEN codiumai/pr-agent:latest --pr_url=&lt;pr_url&gt; review\n</code></pre> </li> <li> <p>For Gitea:</p> <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e CONFIG.GIT_PROVIDER=gitea -e GITEA.PERSONAL_ACCESS_TOKEN=&lt;your token&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre> <p>If you have a dedicated Gitea instance, you need to specify the custom url as variable:</p> <pre><code>-e GITEA.URL=&lt;your gitea instance url&gt;\n</code></pre> </li> </ul> <p>For other git providers, update <code>CONFIG.GIT_PROVIDER</code> accordingly and check the <code>pr_agent/settings/.secrets_template.toml</code> file for environment variables expected names and values.</p>"},{"location":"installation/locally/#utilizing-environment-variables","title":"Utilizing environment variables","text":"<p>It is also possible to provide or override the configuration by setting the corresponding environment variables. You can define the corresponding environment variables by following this convention: <code>&lt;TABLE&gt;__&lt;KEY&gt;=&lt;VALUE&gt;</code> or <code>&lt;TABLE&gt;.&lt;KEY&gt;=&lt;VALUE&gt;</code>. The <code>&lt;TABLE&gt;</code> refers to a table/section in a configuration file and <code>&lt;KEY&gt;=&lt;VALUE&gt;</code> refers to the key/value pair of a setting in the configuration file.</p> <p>For example, suppose you want to run <code>pr_agent</code> that connects to a self-hosted GitLab instance similar to an example above. You can define the environment variables in a plain text file named <code>.env</code> with the following content:</p> <pre><code>CONFIG__GIT_PROVIDER=\"gitlab\"\nGITLAB__URL=\"&lt;your url&gt;\"\nGITLAB__PERSONAL_ACCESS_TOKEN=\"&lt;your token&gt;\"\nOPENAI__KEY=\"&lt;your key&gt;\"\n</code></pre> <p>Then, you can run <code>pr_agent</code> using Docker with the following command:</p> <pre><code>docker run --rm -it --env-file .env codiumai/pr-agent:latest &lt;tool&gt; &lt;tool parameter&gt;\n</code></pre>"},{"location":"installation/locally/#i-get-an-error-when-running-the-docker-image-what-should-i-do","title":"I get an error when running the Docker image. What should I do?","text":"<p>If you encounter an error when running the Docker image, it is almost always due to a misconfiguration of api keys or tokens.</p> <p>Note that litellm, which is used by pr-agent, sometimes returns non-informative error messages such as <code>APIError: OpenAIException - Connection error.</code> Carefully check the api keys and tokens you provided and make sure they are correct. Adjustments may be needed depending on your llm provider.</p> <p>For example, for Azure OpenAI, additional keys are needed. Same goes for other providers, make sure to check the documentation</p>"},{"location":"installation/locally/#using-pip-package","title":"Using pip package","text":"<p>Install the package:</p> <pre><code>pip install pr-agent\n</code></pre> <p>Then run the relevant tool with the script below.  Make sure to fill in the required parameters (<code>user_token</code>, <code>openai_key</code>, <code>pr_url</code>, <code>command</code>):</p> <pre><code>from pr_agent import cli\nfrom pr_agent.config_loader import get_settings\n\ndef main():\n    # Fill in the following values\n    provider = \"github\" # github/gitlab/bitbucket/azure_devops\n    user_token = \"...\"  #  user token\n    openai_key = \"...\"  # OpenAI key\n    pr_url = \"...\"      # PR URL, for example 'https://github.com/qodo-ai/pr-agent/pull/809'\n    command = \"/review\" # Command to run (e.g. '/review', '/describe', '/ask=\"What is the purpose of this PR?\"', ...)\n\n    # Setting the configurations\n    get_settings().set(\"CONFIG.git_provider\", provider)\n    get_settings().set(\"openai.key\", openai_key)\n    get_settings().set(\"github.user_token\", user_token)\n\n    # Run the command. Feedback will appear in GitHub PR comments\n    cli.run_command(pr_url, command)\n\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"installation/locally/#run-from-source","title":"Run from source","text":"<ol> <li>Clone this repository:</li> </ol> <pre><code>git clone https://github.com/qodo-ai/pr-agent.git\n</code></pre> <ol> <li>Navigate to the <code>/pr-agent</code> folder and install the requirements in your favorite virtual environment:</li> </ol> <pre><code>pip install -e .\n</code></pre> <p>Note: If you get an error related to Rust in the dependency installation then make sure Rust is installed and in your <code>PATH</code>, instructions: https://rustup.rs</p> <ol> <li>Copy the secrets template file and fill in your OpenAI key and your GitHub user token:</li> </ol> <pre><code>cp pr_agent/settings/.secrets_template.toml pr_agent/settings/.secrets.toml\nchmod 600 pr_agent/settings/.secrets.toml\n# Edit .secrets.toml file\n</code></pre> <ol> <li>Run the cli.py script:</li> </ol> <pre><code>python3 -m pr_agent.cli --pr_url &lt;pr_url&gt; review\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; ask &lt;your question&gt;\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; describe\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; improve\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; add_docs\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; generate_labels\npython3 -m pr_agent.cli --issue_url &lt;issue_url&gt; similar_issue\n...\n</code></pre> <p>[Optional] Add the pr_agent folder to your PYTHONPATH</p> <pre><code>export PYTHONPATH=$PYTHONPATH:&lt;PATH to pr_agent folder&gt;\n</code></pre>"},{"location":"installation/pr_agent/","title":"PR-Agent","text":""},{"location":"installation/pr_agent/#pr-agent-installation-guide","title":"PR-Agent Installation Guide","text":"<p>PR-Agent can be deployed in various environments and platforms. Choose the installation method that best suits your needs:</p>"},{"location":"installation/pr_agent/#local-installation","title":"\ud83d\udda5\ufe0f Local Installation","text":"<p>Learn how to run PR-Agent locally using:</p> <ul> <li>Docker image</li> <li>pip package</li> <li>CLI from source code</li> </ul> <p>View Local Installation Guide \u2192</p>"},{"location":"installation/pr_agent/#github-integration","title":"\ud83d\udc19 GitHub Integration","text":"<p>Set up PR-Agent with GitHub as:</p> <ul> <li>GitHub Action</li> <li>Local GitHub App</li> </ul> <p>View GitHub Integration Guide \u2192</p>"},{"location":"installation/pr_agent/#gitlab-integration","title":"\ud83e\udd8a GitLab Integration","text":"<p>Deploy PR-Agent on GitLab as:</p> <ul> <li>GitLab pipeline job</li> <li>Local GitLab webhook server</li> </ul> <p>View GitLab Integration Guide \u2192</p>"},{"location":"installation/pr_agent/#bitbucket-integration","title":"\ud83d\udfe6 BitBucket Integration","text":"<p>Implement PR-Agent in BitBucket as:</p> <ul> <li>BitBucket pipeline job</li> <li>Local BitBucket server</li> </ul> <p>View BitBucket Integration Guide \u2192</p>"},{"location":"installation/pr_agent/#azure-devops-integration","title":"\ud83d\udd37  Azure DevOps Integration","text":"<p>Configure PR-Agent with Azure DevOps as:</p> <ul> <li>Azure DevOps pipeline job</li> <li>Local Azure DevOps webhook</li> </ul> <p>View Azure DevOps Integration Guide \u2192</p>"},{"location":"overview/data_privacy/","title":"Data Privacy","text":""},{"location":"overview/data_privacy/#self-hosted-pr-agent","title":"Self-hosted PR-Agent","text":"<ul> <li>If you self-host PR-Agent with your OpenAI (or other LLM provider) API key, it is between you and the provider.</li> </ul>"},{"location":"pr_benchmark/","title":"PR Benchmark","text":""},{"location":"pr_benchmark/#pr-agent-pull-request-benchmark","title":"PR-Agent Pull Request Benchmark","text":""},{"location":"pr_benchmark/#methodology","title":"Methodology","text":"<p>PR-Agent PR Benchmark evaluates and compares the performance of Large Language Models (LLMs) in analyzing pull request code and providing meaningful code suggestions. Our diverse dataset contains 400 pull requests from over 100 repositories, spanning multiple programming languages to reflect real-world scenarios.</p> <ul> <li> <p>For each pull request, we have pre-generated suggestions from eleven different top-performing models using the PR-Agent <code>improve</code> tool. The prompt for response generation can be found here. </p> </li> <li> <p>To benchmark a model, we generate its suggestions for the same pull requests and ask a high-performing judge model to rank the new model's output against the pre-generated baseline suggestions. We utilize OpenAI's <code>o3</code> model as the judge, though other models have yielded consistent results. The prompt for this ranking judgment is available here.</p> </li> <li> <p>We aggregate ranking outcomes across all pull requests, calculating performance metrics for the evaluated model. </p> </li> <li> <p>We also analyze the qualitative feedback from the judge to identify the model's comparative strengths and weaknesses against the established baselines. This approach provides not just a quantitative score but also a detailed analysis of each model's strengths and weaknesses.</p> </li> </ul> <p>A list of the models used for generating the baseline suggestions, and example results, can be found in the Appendix.</p>"},{"location":"pr_benchmark/#pr-benchmark-results","title":"PR Benchmark Results","text":"Model Name Version (Date) Thinking budget tokens Score GPT-5.2 2025-12-11 medium 80.8 GPT-5.2 2025-12-11 low 79.1 GPT-5-pro 2025-10-06 73.4 GPT-5 2025-08-07 medium 72.2 GPT-5 2025-08-07 low 67.8 GPT-5 2025-08-07 minimal 62.7 o3 2025-04-16 'medium' (8000) 62.5 o4-mini 2025-04-16 'medium' (8000) 57.7 Gemini-3-pro-review 2025-11-18 high 57.3 Gemini-2.5-pro 2025-06-05 4096 56.3 Gemini-3-pro-review 2025-11-18 low 55.6 Claude-haiku-4.5 2025-10-01 4096 48.8 GPT-5.1 2025-11-13 medium 44.9 Gemini-2.5-pro 2025-06-05 1024 44.3 Claude-sonnet-4.5 2025-09-29 4096 44.2 Claude-haiku-4.5 2025-10-01 40.7 Claude-sonnet-4.5 2025-09-29 40.7 Claude-4-sonnet 2025-05-14 4096 39.7 Claude-4-sonnet 2025-05-14 39.0 Codex-mini 2025-06-20 unknown 37.2 Gemini-2.5-flash 2025-04-17 33.5 Grok-4 2025-07-09 unknown 32.8 Claude-4-opus-20250514 2025-05-14 32.8 Claude-opus-4.5 2025-11-01 high 30.3"},{"location":"pr_benchmark/#results-analysis-latest-additions","title":"Results Analysis (Latest Additions)","text":""},{"location":"pr_benchmark/#gpt-52-medium-thinking-budget","title":"GPT-5.2 ('medium' thinking budget)","text":"<p>Final score: 80.8</p> <p>Strengths:</p> <ul> <li>Broad, context-aware coverage: Frequently identifies multiple high-impact faults in the added lines and proposes fixes that surpass or equal the best prior answer in many cases (\u224860 % of the 399 comparisons).</li> <li>Actionable, minimal patches: Tends to supply concise before/after code snippets that compile/run, keep changes local, and respect limits (\u22643 suggestions, touched-lines only) \u2013 making the advice easy to apply.</li> <li>Clear reasoning &amp; prioritisation: Usually explains why an issue is critical, ranks it properly (e.g., crash &gt; style), and avoids clutter, resulting in focused reviews that align with real test failures.</li> </ul> <p>Weaknesses:</p> <ul> <li>Critical omissions remain common: In a sizeable minority of examples the model overlooks the single most blocking error (e.g., compile-time break, nil-deref, enum mismatch), causing it to trail a sharper peer answer.</li> <li>Occasional inaccurate or harmful fixes: It sometimes introduces non-compiling code, speculative refactors, or misguided changes to unchanged lines, lowering reliability.</li> <li>Inconsistent guideline adherence: A non-trivial set of replies add off-scope edits, non-critical style nits, or empty suggestion lists when clear bugs exist, leading to avoidable downgrades.</li> </ul>"},{"location":"pr_benchmark/#gpt-52-low-thinking-budget","title":"GPT-5.2 ('low' thinking budget)","text":"<p>Final score: 79.1</p> <p>Strengths:</p> <ul> <li>Often spots multiple critical regressions: In many cases the model is the only or one of very few answers that simultaneously catches several high-impact bugs (e.g. Examples 25, 55, 134, 206, 371).</li> <li>Produces concise, actionable patches: Suggestions are usually well-scoped, supply minimal working code/YAML snippets and respect the three-item limit, so reviewers can apply them quickly.</li> <li>Good rule compliance most of the time: It generally limits itself to '+' lines, avoids stylistic nit-picking, and honours output format and suggestion cap, which keeps responses focused.</li> <li>Broad language &amp; domain coverage: The model successfully reviews changes in many stacks (C/C++, Rust, Go, TS/JS, Python, Kotlin, SQL, CSS/MD/PO, CI scripts), showing solid cross-domain competence.</li> </ul> <p>Weaknesses:</p> <ul> <li>Misses higher-severity issues fairly often: In a substantial fraction of examples it overlooks a more critical bug that other answers find (e.g. 6, 21, 30, 94, 310), lowering its relative rank.</li> <li>Occasional invented or non-critical advice: Sometimes raises speculative, cosmetic or out-of-scope points (17, 106, 171, 230, 390), violating the \"critical bugs only\" rule and hurting ranking.</li> <li>Technical inaccuracies &amp; unsafe fixes: A number of replies introduce uncompilable code, wrong APIs, or contradictory edits (24, 341, 346, 375), indicating imperfect code-level precision.</li> <li>Inconsistency in restraint: While usually concise, the model sporadically adds redundant or excessive suggestions, touches unchanged lines, or conflicts with its own fixes (238, 270, 330), showing uneven guideline adherence.</li> </ul>"},{"location":"pr_benchmark/#gpt-5-pro","title":"GPT-5-pro","text":"<p>Final score: 73.4</p> <p>Strengths:</p> <ul> <li>High bug\u2010finding accuracy and depth: In many cases the model uncovers the core compile-time or run-time regression that other answers miss and frequently combines several distinct critical issues into one reply.</li> <li>Actionable, minimal patches: Suggestions almost always include clear before/after code blocks that touch only the added lines and respect the \u22643-suggestion limit, making them easy to apply.</li> <li>Good guideline compliance: The model generally honours the task rules\u2014no edits to unchanged code, no version bumps, no more than three items\u2014and shows solid judgment about when an empty list is appropriate.</li> <li>Concise, impact-oriented reasoning: Explanations focus on severity, crash potential and build breakage rather than style, helping reviewers prioritise fixes.</li> </ul> <p>Weaknesses:</p> <ul> <li>Coverage gaps: In a noticeable minority of examples the model misses a higher-impact defect that several other answers catch, or returns an empty list despite clear bugs.</li> <li>Occasional incorrect or harmful fixes: A few replies introduce new errors or rest on wrong assumptions about functionality or language-specific behavior.</li> <li>Formatting / guideline slips: Sporadic duplication of suggestions, missing or empty <code>improved_code</code> blocks, or YAML mishaps undermine otherwise good answers.</li> <li>Uneven criticality judgement: Some suggestions drift into low-impact territory while overlooking more severe problems, indicating inconsistent prioritisation.</li> </ul>"},{"location":"pr_benchmark/#gemini-3-pro-review-high-thinking-budget","title":"Gemini-3-pro-review (high thinking budget)","text":"<p>Final score: 57.3</p> <p>Strengths:</p> <ul> <li>Good schema &amp; format discipline: Consistently returns well-formed YAML with correct fields and respects the 3-suggestion limit; rarely breaks the required output structure.</li> <li>Reasonable guideline awareness: Often recognises when a diff contains only data / translations and properly emits an empty list, avoiding over-reporting.</li> <li>Clear, actionable patches when correct: When it does find a bug it usually supplies minimal-diff, compilable code snippets with concise explanations, and occasionally surfaces issues no other model spotted.</li> </ul> <p>Weaknesses:</p> <ul> <li>Spot-coverage gaps on critical defects: In a large share of cases it overlooks the principal regression the tests were written for, while fixating on minor style or performance nits.</li> <li>False or speculative fixes: A noticeable number of answers invent non-existent problems or propose changes that would not compile or would re-introduce removed behaviour.</li> <li>Guideline violations creep in: Sometimes touches unchanged lines, adds forbidden imports / labels, or supplies more than \"critical\" advice, showing imperfect rule adherence.</li> <li>High variance / inconsistency: Quality swings from best-in-class to harmful within consecutive examples, indicating unstable defect-prioritisation and review depth.</li> </ul>"},{"location":"pr_benchmark/#gemini-25-pro-4096-thinking-tokens","title":"Gemini-2.5 Pro (4096 thinking tokens)","text":"<p>Final score: 56.3</p> <p>Strengths:</p> <ul> <li>High formatting compliance: The model almost always produces valid YAML, respects the three-suggestion limit, and supplies clear before/after code snippets and short rationales.</li> <li>Good \u201cfirst-bug\u201d detection: It frequently notices the single most obvious regression (crash, compile error, nil/NPE risk, wrong path, etc.) and gives a minimal, correct patch\u2014often judged \u201con-par\u201d with other solid answers.</li> <li>Clear, concise writing: Explanations are brief yet understandable for reviewers; fixes are scoped to the changed lines and rarely include extraneous context.</li> <li>Low rate of harmful fixes: Truly dangerous or build-breaking advice is rare; most mistakes are omissions rather than wrong code.</li> </ul> <p>Weaknesses:</p> <ul> <li>Limited breadth of review: The model regularly stops after the first or second issue, missing additional critical problems that stronger answers surface, so it is often out-ranked by more comprehensive peers.</li> <li>Occasional guideline violations: A noticeable minority of answers touch unchanged lines, exceed the 3-item cap, suggest adding imports, or drop the required YAML wrapper, leading to automatic downgrades.</li> <li>False positives / speculative fixes: In several cases it flags non-issues (style, performance, redundant code) or supplies debatable \u201cimprovements\u201d, lowering precision and sometimes breaching the \u201ccritical bugs only\u201d rule.</li> <li>Inconsistent error coverage: For certain domains (build scripts, schema files, test code) it either returns an empty list when real regressions exist or proposes cosmetic edits, indicating gaps in specialised knowledge.</li> </ul>"},{"location":"pr_benchmark/#gemini-3-pro-review-low-thinking-budget","title":"Gemini-3-pro-review (low thinking budget)","text":"<p>Final score: 55.6</p> <p>Strengths:</p> <ul> <li>Concise, well-structured patches: Suggestions are usually expressed in short, self-contained YAML items with clear before/after code blocks and just enough rationale, making them easy for reviewers to apply.</li> <li>Good eye for crash-level defects: When the model does spot a problem it often focuses on high-impact issues such as compile-time errors, NPEs, nil-pointer races, buffer overflows, etc., and supplies a minimal, correct fix.</li> <li>High guideline compliance (format &amp; scope): In most cases it respects the 1-3-item limit and the \"new lines only\" rule, avoids changing imports, and keeps snippets syntactically valid.</li> </ul> <p>Weaknesses:</p> <ul> <li>Coverage inconsistency: Many answers miss other obvious or even more critical regressions spotted by peers; breadth fluctuates from excellent to empty, leaving reviewers with partial insight.</li> <li>False positives &amp; speculative advice: A noticeable share of suggestions target stylistic or non-critical tweaks, or even introduce wrong changes, betraying occasional mis-reading of the diff and hurting trust.</li> <li>Rule violations still occur: There are repeated instances of touching unchanged code, recommending version bumps/imports, mis-labelling severities, or outputting malformed snippets\u2014showing lapses in instruction adherence.</li> <li>Quality variance / empty outputs: Some responses provide no suggestions despite real bugs, while others supply harmful fixes; this volatility lowers overall reliability.</li> </ul>"},{"location":"pr_benchmark/#claude-haiku-45-4096-thinking-tokens","title":"Claude-haiku-4.5 (4096 thinking tokens)","text":"<p>Final score: 48.8</p> <p>Strengths:</p> <ul> <li>High precision on detected issues: When the model does flag a problem it is usually a real, high-impact bug; many answers are judged equal or better than strong baselines because the proposed fix is correct, minimal and easy to apply.</li> <li>Language- and domain-agnostic competence: It successfully diagnoses defects across a wide range of languages (Python, Go, C/C++, Rust, JS/TS, CSS, SQL, Markdown, etc.) and domains (backend logic, build files, tests, docs).</li> <li>Clear, actionable patches: Suggested code is typically concise, well-explained and scoped exactly to the added lines, making it practical for reviewers to adopt.</li> </ul> <p>Weaknesses:</p> <ul> <li>Low recall / narrow coverage: The model often stops after one or two findings, leaving other obvious critical bugs unmentioned; in many examples stronger answers simply covered more ground.</li> <li>Occasional faulty or speculative fixes: A non-trivial number of responses either mis-diagnose the issue or introduce new errors (e.g., wrong logic, undeclared imports), dropping them below baseline quality.</li> <li>Inconsistent output robustness: Several cases show truncated or malformed responses, reducing value despite correct analysis elsewhere.</li> <li>Frequent false negatives: The model sometimes returns an empty list even when clear regressions exist, indicating conservative behaviour that misses mandatory fixes.</li> </ul>"},{"location":"pr_benchmark/#gpt-51-medium-thinking-budget","title":"GPT-5.1 ('medium' thinking budget)","text":"<p>Final score: 44.9</p> <p>Strengths:</p> <ul> <li>High precision &amp; guideline compliance: When the model does emit suggestions they are almost always technically sound, respect the \"new-lines-only / \u22643 suggestions / no-imports\" rules, and are formatted correctly. It rarely introduces harmful changes and often provides clear, runnable patches.</li> <li>Ability to spot subtle or unique defects: In several cases the model caught a critical issue that most or all baselines missed, showing good deep-code reasoning when it does engage.</li> <li>Good judgment on noise-free diffs: On purely data or documentation changes the model frequently (and correctly) returns an empty list, avoiding false-positive \"nit\" feedback.</li> </ul> <p>Weaknesses:</p> <ul> <li>Very low recall / over-conservatism: In a large fraction of examples it outputs an empty suggestion list while clear critical bugs exist (well over 50 % of cases), making it inferior to almost every baseline answer that offered any fix.</li> <li>Narrow coverage when it speaks: Even when it flags one bug, it often stops there and ignores other equally critical problems present in the same diff, leaving reviewers with partial insight.</li> <li>Occasional misdiagnosis or harmful fix: A minority of suggestions are wrong or counter-productive, showing that precision, while good, is not perfect.</li> </ul>"},{"location":"pr_benchmark/#claude-sonnet-45-4096-thinking-tokens","title":"Claude-sonnet-4.5 (4096 thinking tokens)","text":"<p>Final score: 44.2</p> <p>Strengths:</p> <ul> <li>High precision / low noise: When the model does offer fixes they are usually correct, concise and confined to the new '+' lines, rarely introducing spurious or off-scope changes.</li> <li>Clear, actionable patches: Suggestions come with well-explained reasoning and minimal but valid code snippets, making them easy for a reviewer to apply.</li> <li>Good rule compliance: It almost always respects the 1-3 suggestion limit, avoids touching unchanged code and seldom violates formatting or other task guidelines.</li> </ul> <p>Weaknesses:</p> <ul> <li>Low recall / frequent omissions: In a large share of cases the model returns an empty list or only one minor tip while overlooking obvious, higher-impact regressions found by peers.</li> <li>Narrow coverage when it does respond: Even in non-empty outputs it typically fixes a single issue and ignores related defects in the same diff, indicating shallow analysis.</li> <li>Occasional harmful or incomplete fixes: A few suggestions introduce new errors (e.g., wrong logic, missing imports, malformed snippets) or mark non-critical style nits as \"critical\", reducing trust.</li> </ul>"},{"location":"pr_benchmark/#claude-sonnet-45","title":"Claude-sonnet-4.5","text":"<p>Final score: 40.7</p> <p>Strengths:</p> <ul> <li>Concise &amp; well-formatted output: Most replies strictly follow the schema, stay within the 3-suggestion limit, and include clear, copy-paste-ready patches, making them easy to apply.</li> <li>Can spot headline bugs: When a single, obvious regression is present (e.g. duplicated regex block, missing null-check, wrong macro name) the model often detects it and proposes an accurate, minimal fix.</li> <li>Scope discipline (usually): It frequently restricts changes to newly-added lines and avoids broad refactors, so many answers comply with the \u201cnew code only / critical bugs only\u201d rule.</li> <li>Reasonable explanations: The accompanying rationales are typically short but precise, helping reviewers understand why the change is needed.</li> </ul> <p>Weaknesses:</p> <ul> <li>Low recall of critical issues: In a large fraction of examples the model misses the primary bug or flags nothing at all while other reviewers find clear problems. Coverage is therefore unreliable.</li> <li>False or harmful fixes: A notable number of suggestions mis-diagnose the code, touch unchanged lines, violate task rules, or would break compilation/runtime (wrong paths, bad types, guideline-forbidden advice).</li> <li>Priority mistakes: The model often downgrades severe defects to \u201cgeneral\u201d or upgrades cosmetic nits to \u201ccritical\u201d, showing weak bug-severity judgment.</li> <li>Inconsistent quality: Performance swings widely between excellent and poor; reviewers cannot predict whether a given answer will be thorough, partial, or incorrect.</li> </ul>"},{"location":"pr_benchmark/#claude-haiku-45","title":"Claude-haiku-4.5","text":"<p>Final score: 40.7</p> <p>Strengths:</p> <ul> <li>**Good format &amp; clarity: Consistently produces valid YAML and readable, minimally-intrusive patches with clear before/after snippets, so its outputs are easy to apply.</li> <li>**Basic bug-spotting ability: Often detects the most obvious new-line defect (e.g., syntax error, missing guard, wrong constant) and supplies a correct, concise fix; rarely ranks last in the set.</li> <li>**Rule compliance in many cases: Usually stays within the 3-suggestion limit, touches only '+' lines, and avoids speculative refactors\u2014returning an empty list when no code was added.</li> </ul> <p>Weaknesses:</p> <ul> <li>**Shallow coverage: Frequently fixes just one surface-level issue and misses additional, higher-impact bugs that stronger reviewers catch, leaving regressions in place.</li> <li>**Occasional incorrect or no-op patches: A noticeable share of suggestions either leave code unchanged, contain invalid code, or introduce new errors, lowering trust.</li> <li>**Guideline slips: In several examples it edits unchanged lines, adds forbidden imports/version bumps, mis-labels severities, or supplies non-critical stylistic advice.</li> <li>**Inconsistent diligence: Roughly a quarter of the cases return an empty list despite real problems, while others duplicate existing PR changes, indicating weak diff comprehension.</li> </ul>"},{"location":"pr_benchmark/#openai-codex-mini","title":"OpenAI codex-mini","text":"<p>Final score: 37.2</p> <p>Strengths:</p> <ul> <li>Can spot high-impact defects: When it \"locks on\", codex-mini often identifies the main runtime or security regression (e.g., race-conditions, logic inversions, blocking I/O, resource leaks) and proposes a minimal, direct patch that compiles and respects neighbouring style.</li> <li>Produces concise, scoped fixes: Valid answers usually stay within the allowed 3-suggestion limit, reference only the added lines, and contain clear before/after snippets that reviewers can apply verbatim.</li> <li>Occasional broad coverage: In a minority of cases the model catches multiple independent issues (logic + tests + docs) and outperforms every baseline answer, showing good contextual understanding of heterogeneous diffs.</li> </ul> <p>Weaknesses:</p> <ul> <li>Output instability / format errors: A very large share of responses are unusable\u2014plain refusals, shell commands, or malformed/empty YAML\u2014indicating brittle adherence to the required schema and tanking overall usefulness.</li> <li>Critical-miss rate: Even when the format is correct the model frequently overlooks the single most serious bug the diff introduces, instead focusing on stylistic nits or speculative refactors.</li> <li>Introduces new problems: Several suggestions add unsupported APIs, undeclared variables, wrong types, or break compilation, hurting trust in the recommendations.</li> <li>Rule violations: It often edits lines outside the diff, exceeds the 3-suggestion cap, or labels cosmetic tweaks as \"critical\", showing inconsistent guideline compliance.</li> </ul>"},{"location":"pr_benchmark/#gemini-25-flash","title":"Gemini-2.5 Flash","text":"<p>Final score: 33.5</p> <p>Strengths:</p> <ul> <li>High precision / low false-positive rate: The model often stays silent or gives a single, well-justified fix, so when it does speak the suggestion is usually correct and seldom touches unchanged lines, keeping guideline compliance high.  </li> <li>Good guideline awareness: YAML structure is consistently valid; suggestions rarely exceed the 3-item limit and generally restrict themselves to newly-added lines.  </li> <li>Clear, concise patches: When a defect is found, the model produces short rationales and tidy \u201cimproved_code\u201d blocks that reviewers can apply directly.  </li> <li>Risk-averse behaviour pays off in \u201cno-bug\u201d PRs: In examples where the diff truly contained no critical issue, the model\u2019s empty output ranked above peers that offered speculative or stylistic advice.</li> </ul> <p>Weaknesses:</p> <ul> <li>Very low recall / shallow coverage: In a large majority of cases it gives 0-1 suggestions and misses other evident, critical bugs highlighted by peer models, leading to inferior rankings.  </li> <li>Occasional incorrect or harmful fixes: A noticeable subset of answers propose changes that break functionality or misunderstand the code (e.g. bad constant, wrong header logic, speculative rollbacks).  </li> <li>Non-actionable placeholders: Some \u201cimproved_code\u201d sections contain comments or \u201c\u2026\u201d rather than real patches, reducing practical value.  </li> </ul>"},{"location":"pr_benchmark/#claude-4-opus","title":"Claude-4 Opus","text":"<p>Final score: 32.8</p> <p>Strengths:</p> <ul> <li>Format &amp; rule adherence: Almost always returns valid YAML, stays within the \u22643-suggestion limit, and usually restricts edits to newly-added lines, so its output is easy to apply automatically.</li> <li>Concise, focused patches: When it does find a real bug it gives short, well-scoped explanations plus minimal diff snippets, often outperforming verbose baselines in clarity.</li> <li>Able to catch subtle edge-cases: In several examples it detected overflow, race-condition or enum-mismatch issues that many other models missed, showing solid code\u2010analysis capability.</li> </ul> <p>Weaknesses:</p> <ul> <li>Low recall / narrow coverage: In a large share of the 399 examples the model produced an empty list or only one minor tip while more serious defects were present, causing it to be rated inferior to most baselines.</li> <li>Frequent incorrect or no-op fixes: It sometimes supplies identical \u201cbefore/after\u201d code, flags non-issues, or suggests changes that would break compilation or logic, reducing reviewer trust.</li> <li>Shaky guideline consistency: Although generally compliant, it still occasionally violates rules (touches unchanged lines, offers stylistic advice, adds imports) and duplicates suggestions, indicating unstable internal checks.</li> </ul>"},{"location":"pr_benchmark/#grok-4","title":"Grok-4","text":"<p>Final score: 32.8</p> <p>Strengths:</p> <ul> <li>Focused and concise fixes: When the model does detect a problem it usually proposes a minimal, well-scoped patch that compiles and directly addresses the defect without unnecessary noise.</li> <li>Good critical-bug instinct: It often prioritises show-stoppers (compile failures, crashes, security issues) over cosmetic matters and occasionally spots subtle issues that all other reviewers miss.</li> <li>Clear explanations &amp; snippets: Explanations are short, readable and paired with ready-to-paste code, making the advice easy to apply.</li> </ul> <p>Weaknesses:</p> <ul> <li>High miss rate: In a large fraction of examples the model returned an empty list or covered only one minor issue while overlooking more serious newly-introduced bugs.</li> <li>Inconsistent accuracy: A noticeable subset of answers contain wrong or even harmful fixes (e.g., removing valid flags, creating compile errors, re-introducing bugs).</li> <li>Limited breadth: Even when it finds a real defect it rarely reports additional related problems that peers catch, leading to partial reviews.</li> <li>Occasional guideline slips: A few replies modify unchanged lines, suggest new imports, or duplicate suggestions, showing imperfect compliance with instructions.</li> </ul>"},{"location":"pr_benchmark/#claude-opus-45-high-thinking-budget","title":"Claude-Opus-4.5 (high thinking budget)","text":"<p>Final score: 30.3</p> <p>Strengths:</p> <ul> <li>High rule compliance &amp; formatting: Consistently produces valid YAML, respects the \u22643-suggestion limit, and usually confines edits to added lines, avoiding many guideline violations seen in peers.</li> <li>Low false-positive rate: Tends to stay silent unless convinced of a real problem; when the diff is a pure version bump / docs tweak it often (correctly) returns an empty list, beating noisier baselines.</li> <li>Clear, focused patches when it fires: In the minority of cases where it does spot a bug, it explains the issue crisply and supplies concise, copy-paste-able code snippets.</li> </ul> <p>Weaknesses:</p> <ul> <li>Very low recall: In the vast majority of examples it misses obvious critical issues or suggests only a subset, frequently returning an empty list; this places it below most baselines on overall usefulness.</li> <li>Shallow coverage: Even when it catches a defect it typically lists a single point and overlooks other high-impact problems present in the same diff.</li> <li>Occasional incorrect or incomplete fixes: A non-trivial number of suggestions are wrong, compile-breaking, duplicate unchanged code, or touch out-of-scope lines, reducing trust.</li> <li>Inconsistent severity tagging &amp; duplication: Sometimes mis-labels critical vs general, repeats the same suggestion, or leaves <code>improved_code</code> blocks empty.</li> </ul>"},{"location":"pr_benchmark/#appendix-example-results","title":"Appendix - Example Results","text":"<p>Some examples of benchmarked PRs and their results:</p> <ul> <li>Example 1</li> <li>Example 2</li> <li>Example 3</li> <li>Example 4</li> </ul>"},{"location":"pr_benchmark/#models-used-for-benchmarking","title":"Models Used for Benchmarking","text":"<p>The following models were used for generating the benchmark baseline:</p> <pre><code>(1) anthropic_sonnet_3.7_v1:0\n\n(2) claude-4-opus-20250514\n\n(3) claude-4-sonnet-20250514\n\n(4) claude-4-sonnet-20250514_thinking_2048\n\n(5) gemini-2.5-flash-preview-04-17\n\n(6) gemini-2.5-pro-preview-05-06\n\n(7) gemini-2.5-pro-preview-06-05_1024\n\n(8) gemini-2.5-pro-preview-06-05_4096\n\n(9) gpt-4.1\n\n(10) o3\n\n(11) o4-mini_medium\n</code></pre>"},{"location":"pr_benchmark/#programming-languages","title":"Programming Languages","text":"<p>The PR benchmark dataset includes pull requests containing code in the following programming languages:</p> <pre><code>[\"Python\", \"JavaScript\", \"TypeScript\", \"Java\", \"CSharp\", \"PHP\", \"C++\", \"Go\", \"Rust\", \"Swift\", \"Kotlin\", \"Ruby\", \"Dart\", \"Scala\"\n</code></pre> <p>Pull requests may also include non-code files such as <code>YAML</code>, <code>JSON</code>, <code>Markdown</code>, <code>Dockerfile</code> ,<code>Shell</code>, etc.  The benchmarked models should also analyze these files, as they commonly appear in real-world pull requests.</p>"},{"location":"tools/","title":"Tools","text":""},{"location":"tools/#tools","title":"Tools","text":"<p>Here is a list of PR-Agent tools, each with a dedicated page that explains how to use it:</p> Tool Description PR Description (<code>/describe</code>) Automatically generating PR description - title, type, summary, code walkthrough and labels PR Review (<code>/review</code>) Adjustable feedback about the PR, possible issues, security concerns, review effort and more Code Suggestions (<code>/improve</code>) Code suggestions for improving the PR Question Answering (<code>/ask ...</code>) Answering free-text questions about the PR, or on specific code lines Add Documentation (<code>/add_docs</code>) Generate documentation for code components that are missing it Generate Labels (<code>/generate_labels</code>) Generate custom labels for the PR based on the code changes Similar Issues (<code>/similar_issue</code>) Find similar issues in the repository based on the current issue Help (<code>/help</code>) Provides a list of all the available tools Help Docs (<code>/help_docs</code>) Answer a free-text question based on a git documentation folder Update Changelog (<code>/update_changelog</code>) Automatically updating the CHANGELOG.md file with the PR changes"},{"location":"tools/add_docs/","title":"Add Docs","text":""},{"location":"tools/add_docs/#overview","title":"Overview","text":"<p>The <code>add_docs</code> tool scans the PR code changes and suggests documentation for any code components that are missing documentation, such as functions, classes, and methods.</p> <p>It can be invoked manually by commenting on any PR:</p> <pre><code>/add_docs\n</code></pre>"},{"location":"tools/add_docs/#example-usage","title":"Example usage","text":"<p>Invoke the tool manually by commenting <code>/add_docs</code> on any PR:</p> <p></p> <p>The tool will generate documentation suggestions as inline code suggestions:</p> <p></p>"},{"location":"tools/add_docs/#language-specific-documentation-styles","title":"Language-specific documentation styles","text":"<p>The tool automatically detects the programming language and generates documentation in the appropriate format:</p> Language Documentation Format Python Docstrings (Sphinx, Google, Numpy styles) Java Javadocs JavaScript/TypeScript JSdocs C++ Doxygen Other Generic documentation"},{"location":"tools/add_docs/#configuration-options","title":"Configuration options","text":"<p>Under the section <code>[pr_add_docs]</code>, the following options are available:</p> Option Type Default Description <code>extra_instructions</code> string <code>\"\"</code> Additional instructions for the AI model <code>docs_style</code> string <code>\"Sphinx\"</code> Documentation style for Python. Options: <code>\"Sphinx\"</code>, <code>\"Google Style with Args, Returns, Attributes...etc\"</code>, <code>\"Numpy Style\"</code>, <code>\"PEP257\"</code>, <code>\"reStructuredText\"</code> <code>file</code> string <code>\"\"</code> Specific file to document (useful when multiple components have the same name) <code>class_name</code> string <code>\"\"</code> Specific class name to target (useful when methods have the same name in the same file)"},{"location":"tools/add_docs/#example-configuration","title":"Example configuration","text":"<p>To customize the documentation style, add the following to your configuration file:</p> <pre><code>[pr_add_docs]\ndocs_style = \"Google Style with Args, Returns, Attributes...etc\"\nextra_instructions = \"Focus on documenting public methods and include usage examples\"\n</code></pre>"},{"location":"tools/add_docs/#command-line-options","title":"Command line options","text":"<p>You can pass configuration options directly in the command:</p> <pre><code>/add_docs --pr_add_docs.docs_style=\"Numpy Style\"\n</code></pre>"},{"location":"tools/add_docs/#how-it-works","title":"How it works","text":"<ol> <li>The tool analyzes the PR diff to identify code components (functions, classes, methods) that lack documentation</li> <li>It uses AI to generate appropriate documentation based on the code context and language</li> <li>Documentation suggestions are published as inline code suggestions that can be applied with a single click</li> </ol>"},{"location":"tools/ask/","title":"Ask","text":""},{"location":"tools/ask/#overview","title":"Overview","text":"<p>The <code>ask</code> tool answers questions about the PR, based on the PR code changes. Make sure to be specific and clear in your questions. It can be invoked manually by commenting on any PR:</p> <pre><code>/ask \"...\"\n</code></pre>"},{"location":"tools/ask/#example-usage","title":"Example usage","text":""},{"location":"tools/ask/#ask-lines","title":"Ask lines","text":"<p>You can run <code>/ask</code> on specific lines of code in the PR from the PR's diff view. The tool will answer questions based on the code changes in the selected lines.</p> <ul> <li>Click on the '+' sign next to the line number to select the line.</li> <li>To select multiple lines, click on the '+' sign of the first line and then hold and drag to select the rest of the lines.</li> <li>write <code>/ask \"...\"</code> in the comment box and press <code>Add single comment</code> button.</li> </ul> <p></p> <p>Note that the tool does not have \"memory\" of previous questions, and answers each question independently.</p>"},{"location":"tools/ask/#ask-on-images","title":"Ask on images","text":"<p>You can also ask questions about images that appear in the comment, where the entire PR code will be used as context.  The basic syntax is:</p> <pre><code>/ask \"...\"\n\n[Image](https://real_link_to_image)\n</code></pre> <p>where <code>https://real_link_to_image</code> is the direct link to the image.</p> <p>Note that GitHub has a built-in mechanism of pasting images in comments. However, pasted image does not provide a direct link. To get a direct link to an image, we recommend using the following scheme:</p> <p>1. First, post a comment that contains only the image:</p> <p></p> <p>2. Quote reply to that comment:</p> <p></p> <p>3. In the screen opened, type the question below the image:</p> <p> </p> <p>4. Post the comment, and receive the answer:</p> <p></p> <p>See a full video tutorial here</p>"},{"location":"tools/describe/","title":"Describe","text":""},{"location":"tools/describe/#overview","title":"Overview","text":"<p>The <code>describe</code> tool scans the PR code changes, and generates a description for the PR - title, type, summary, walkthrough and labels.</p> <p>The tool can be triggered automatically every time a new PR is opened, or it can be invoked manually by commenting on any PR:</p> <pre><code>/describe\n</code></pre>"},{"location":"tools/describe/#example-usage","title":"Example usage","text":""},{"location":"tools/describe/#manual-triggering","title":"Manual triggering","text":"<p>Invoke the tool manually by commenting <code>/describe</code> on any PR:</p> <p></p> <p>After ~30 seconds, the tool will generate a description for the PR:</p> <p></p> <p>If you want to edit configurations, add the relevant ones to the command:</p> <pre><code>/describe --pr_description.some_config1=... --pr_description.some_config2=...\n</code></pre>"},{"location":"tools/describe/#automatic-triggering","title":"Automatic triggering","text":"<p>To run the <code>describe</code> automatically when a PR is opened, define in a configuration file:</p> <pre><code>[github_app]\npr_commands = [\n    \"/describe\",\n    ...\n]\n\n[pr_description]\npublish_labels = true\n...\n</code></pre> <ul> <li>The <code>pr_commands</code> lists commands that will be executed automatically when a PR is opened.</li> <li>The <code>[pr_description]</code> section contains the configurations for the <code>describe</code> tool you want to edit (if any).</li> </ul>"},{"location":"tools/describe/#preserving-the-original-user-description","title":"Preserving the original user description","text":"<p>By default, PR-Agent tries to preserve your original PR description by placing it above the generated content. This requires including your description during the initial PR creation.</p> <p>\"PR-Agent removed the original description from the PR. Why\"?</p> <p>From our experience, there are two possible reasons:</p> <ul> <li> <p>If you edit the description while the automated tool is running, a race condition may occur, potentially causing your original description to be lost. Hence, create a description before launching the PR.</p> </li> <li> <p>When updating PR descriptions, the <code>/describe</code> tool considers everything above the \"PR Type\" field as user content and will preserve it. Everything below this marker is treated as previously auto-generated content and will be replaced.</p> </li> </ul> <p></p>"},{"location":"tools/describe/#sequence-diagram-support","title":"Sequence Diagram Support","text":"<p>The <code>/describe</code> tool includes a Mermaid sequence diagram showing component/function interactions. </p> <p>This option is enabled by default via the <code>pr_description.enable_pr_diagram</code> param.</p>"},{"location":"tools/describe/#configuration-options","title":"Configuration options","text":"Possible configurations <p> publish_labels If set to true, the tool will publish labels to the PR. Default is false. publish_description_as_comment If set to true, the tool will publish the description as a comment to the PR. If false, it will overwrite the original description. Default is false. publish_description_as_comment_persistent If set to true and <code>publish_description_as_comment</code> is true, the tool will publish the description as a persistent comment to the PR. Default is true. add_original_user_description If set to true, the tool will add the original user description to the generated description. Default is true. generate_ai_title If set to true, the tool will also generate an AI title for the PR. Default is false. extra_instructions Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\" enable_pr_type If set to false, it will not show the <code>PR type</code> as a text value in the description content. Default is true. final_update_message If set to true, it will add a comment message <code>PR Description updated to latest commit...</code> after finishing calling <code>/describe</code>. Default is true. enable_semantic_files_types If set to true, \"Changes walkthrough\" section will be generated. Default is true. file_table_collapsible_open_by_default If set to true, the file list in the \"Changes walkthrough\" section will be open by default. If set to false, it will be closed by default. Default is false. collapsible_file_list If set to true, the file list in the \"Changes walkthrough\" section will be collapsible. If set to \"adaptive\", the file list will be collapsible only if there are more than 8 files. Default is \"adaptive\". enable_large_pr_handling If set to true, in case of a large PR the tool will make several calls to the AI and combine them to be able to cover more files. Default is true. enable_help_text If set to true, the tool will display a help text in the comment. Default is false. enable_pr_diagram If set to true, the tool will generate a horizontal Mermaid flowchart summarizing the main pull request changes. This field remains empty if not applicable. Default is true. auto_create_ticket If set to true, this will automatically create a ticket in the ticketing system when a PR is opened. Default is false. </p>"},{"location":"tools/describe/#markers-template","title":"Markers template","text":"<p>To enable markers, set <code>pr_description.use_description_markers=true</code>. Markers enable to easily integrate user's content and auto-generated content, with a template-like mechanism.</p> <p>For example, if the PR original description was:</p> <pre><code>User content...\n\n## PR Type:\npr_agent:type\n\n## PR Description:\npr_agent:summary\n\n## PR Walkthrough:\npr_agent:walkthrough\n\n## PR Diagram:\npr_agent:diagram\n</code></pre> <p>The marker <code>pr_agent:type</code> will be replaced with the PR type, <code>pr_agent:summary</code> will be replaced with the PR summary, <code>pr_agent:walkthrough</code> will be replaced with the PR walkthrough, and <code>pr_agent:diagram</code> will be replaced with the sequence diagram (if enabled).</p> <p></p> <p>becomes</p> <p></p> <p>Configuration params:</p> <ul> <li><code>use_description_markers</code>: if set to true, the tool will use markers template. It replaces every marker of the form <code>pr_agent:marker_name</code> with the relevant content. Default is false.</li> <li><code>include_generated_by_header</code>: if set to true, the tool will add a dedicated header: 'Generated by PR Agent at ...' to any automatic content. Default is true.</li> <li><code>diagram</code>: if present as a marker, will be replaced by the PR sequence diagram (if enabled).</li> </ul>"},{"location":"tools/describe/#custom-labels","title":"Custom labels","text":"<p>The default labels of the describe tool are quite generic, since they are meant to be used in any repo: [<code>Bug fix</code>, <code>Tests</code>, <code>Enhancement</code>, <code>Documentation</code>, <code>Other</code>].</p> <p>You can define custom labels that are relevant for your repo and use cases. Custom labels can be defined in a configuration file, or directly in the repo's labels page.</p> <p>Make sure to provide proper title, and a detailed and well-phrased description for each label, so the tool will know when to suggest it. Each label description should be a conditional statement, that indicates if to add the label to the PR or not, according to the PR content.</p> Auto-remove custom label when no longer relevant <p>If the custom label is no longer relevant, it will be automatically removed from the PR by running the <code>generate_labels</code> tool or the <code>describe</code> tool.</p>"},{"location":"tools/describe/#handle-custom-labels-from-a-configuration-file","title":"Handle custom labels from a configuration file","text":"<p>Example for a custom labels configuration setup in a configuration file:</p> <pre><code>[config]\nenable_custom_labels=true\n\n\n[custom_labels.\"sql_changes\"]\ndescription = \"Use when a PR contains changes to SQL queries\"\n\n[custom_labels.\"test\"]\ndescription = \"use when a PR primarily contains new tests\"\n\n...\n</code></pre>"},{"location":"tools/describe/#handle-custom-labels-from-the-repos-labels-page","title":"Handle custom labels from the Repo's labels page","text":"<p>You can also control the custom labels that will be suggested by the <code>describe</code> tool from the repo's labels page:</p> <ul> <li>GitHub : go to <code>https://github.com/{owner}/{repo}/labels</code> (or click on the \"Labels\" tab in the issues or PRs page)</li> <li>GitLab : go to <code>https://gitlab.com/{owner}/{repo}/-/labels</code> (or click on \"Manage\" -&gt; \"Labels\" on the left menu)</li> </ul> <p>Now add/edit the custom labels. they should be formatted as follows:</p> <ul> <li>Label name: The name of the custom label.</li> <li>Description: Start the description of with prefix <code>pr_agent:</code>, for example: <code>pr_agent: Description of when AI should suggest this label</code>.</li> </ul> <p>Examples for custom labels:</p> <ul> <li><code>Main topic:performance</code> -  pr_agent:The main topic of this PR is performance</li> <li><code>New endpoint</code> -  pr_agent:A new endpoint was added in this PR</li> <li><code>SQL query</code> -  pr_agent:A new SQL query was added in this PR</li> <li><code>Dockerfile changes</code> - pr_agent:The PR contains changes in the Dockerfile</li> <li>...</li> </ul> <p>The description should be comprehensive and detailed, indicating when to add the desired label. For example: </p>"},{"location":"tools/describe/#usage-tips","title":"Usage Tips","text":"<p>Automation</p> <ul> <li>When you first install PR-Agent app, the default mode for the describe tool is: <pre><code>pr_commands = [\"/describe\", ...]\n</code></pre> meaning the <code>describe</code> tool will run automatically on every PR, with the default configurations.</li> </ul> <ul> <li>Markers are an alternative way to control the generated description, to give maximal control to the user. If you set:</li> </ul> <pre><code>pr_commands = [\"/describe --pr_description.use_description_markers=true\", ...]\n</code></pre> <p>the tool will replace every marker of the form <code>pr_agent:marker_name</code> in the PR description with the relevant content, where <code>marker_name</code> is one of the following:          *<code>type</code>: the PR type.          * <code>summary</code>: the PR summary.          * <code>walkthrough</code>: the PR walkthrough.</p> <ul> <li>Note that when markers are enabled, if the original PR description does not contain any markers, the tool will not alter the description at all.</li> </ul>"},{"location":"tools/generate_labels/","title":"Generate Labels","text":""},{"location":"tools/generate_labels/#overview","title":"Overview","text":"<p>The <code>generate_labels</code> tool scans the PR code changes and generates custom labels for the PR based on the content and context of the changes.</p> <p>It can be invoked manually by commenting on any PR:</p> <pre><code>/generate_labels\n</code></pre>"},{"location":"tools/generate_labels/#example-usage","title":"Example usage","text":"<p>Invoke the tool manually by commenting <code>/generate_labels</code> on any PR:</p> <p></p> <p>The tool will analyze the PR and add appropriate labels:</p> <p></p>"},{"location":"tools/generate_labels/#configuration-options","title":"Configuration options","text":"<p>The <code>generate_labels</code> tool uses configurations from the <code>[pr_description]</code> section for custom labels.</p>"},{"location":"tools/generate_labels/#enabling-custom-labels","title":"Enabling custom labels","text":"<p>To use custom labels, you need to enable them in the configuration:</p> <pre><code>[config]\nenable_custom_labels = true\n</code></pre>"},{"location":"tools/generate_labels/#defining-custom-labels","title":"Defining custom labels","text":"<p>You can define your own custom labels in the <code>[custom_labels]</code> section. See the custom_labels.toml file for examples.</p> <p>Example configuration:</p> <pre><code>[custom_labels.\"Bug fix\"]\ndescription = \"A fix for a bug in the codebase\"\n\n[custom_labels.\"Feature\"]\ndescription = \"A new feature or enhancement\"\n\n[custom_labels.\"Documentation\"]\ndescription = \"Documentation changes only\"\n\n[custom_labels.\"Tests\"]\ndescription = \"Adding or modifying tests\"\n\n[custom_labels.\"Refactoring\"]\ndescription = \"Code refactoring without functional changes\"\n</code></pre>"},{"location":"tools/generate_labels/#how-labels-are-applied","title":"How labels are applied","text":"<ol> <li>The tool analyzes the PR diff and commit messages</li> <li>It uses AI to determine which labels best match the PR content</li> <li>Labels are automatically applied to the PR (if the git provider supports it)</li> <li>If labels cannot be applied directly, they are published as a comment</li> </ol>"},{"location":"tools/generate_labels/#comparison-with-describe-labels","title":"Comparison with <code>/describe</code> labels","text":"<p>The <code>/describe</code> tool also generates labels as part of its output. The key differences are:</p> Feature <code>/generate_labels</code> <code>/describe</code> Purpose Dedicated label generation Full PR description with labels Output Labels only Title, summary, walkthrough, and labels Custom labels \u2705 Supported \u2705 Supported Use case When you only need labels When you want a complete PR description"},{"location":"tools/generate_labels/#tips","title":"Tips","text":"<ul> <li>Use custom labels that match your team's workflow and labeling conventions</li> <li>Combine with automation to automatically label PRs when they are opened</li> <li>Review the generated labels and adjust custom label descriptions if the AI consistently misclassifies PRs</li> </ul>"},{"location":"tools/help/","title":"Help","text":""},{"location":"tools/help/#overview","title":"Overview","text":"<p>The <code>help</code> tool provides a list of all the available tools and their descriptions. For PR-Agent users, it also enables to trigger each tool by checking the relevant box.</p> <p>It can be invoked manually by commenting on any PR:</p> <pre><code>/help\n</code></pre>"},{"location":"tools/help/#example-usage","title":"Example usage","text":"<p>Invoke the <code>help</code> tool by commenting on a PR with:</p> <p></p> <p>Response will include a list of available tools:</p> <p></p>"},{"location":"tools/help_docs/","title":"Help Docs","text":""},{"location":"tools/help_docs/#overview","title":"Overview","text":"<p>The <code>help_docs</code> tool can answer a free-text question based on a git documentation folder.</p> <p>It can be invoked manually by commenting on any PR or Issue:</p> <pre><code>/help_docs \"...\"\n</code></pre> <p>Or configured to be triggered automatically when a new issue is opened.</p> <p>The tool assumes by default that the documentation is located in the root of the repository, at <code>/docs</code> folder. However, this can be customized by setting the <code>docs_path</code> configuration option:</p> <pre><code>[pr_help_docs]\nrepo_url = \"\"                 # The repository to use as context\ndocs_path = \"docs\"            # The documentation folder\nrepo_default_branch = \"main\"  # The branch to use in case repo_url overwritten\n</code></pre> <p>See more configuration options in the Configuration options section.</p>"},{"location":"tools/help_docs/#example-usage","title":"Example usage","text":"<p>Asking a question about another repository</p> <p></p> <p>Response:</p> <p></p>"},{"location":"tools/help_docs/#run-automatically-when-a-new-issue-is-opened","title":"Run automatically when a new issue is opened","text":"<p>You can configure PR-Agent to run <code>help_docs</code> automatically on any newly created issue. This can be useful, for example, for providing immediate feedback to users who open issues with questions on open-source projects with extensive documentation.</p> <p>Here's how:</p> <p>1) Follow the steps depicted under Run as a Github Action to create a new workflow, such as:<code>.github/workflows/help_docs.yml</code>:</p> <p>2) Edit your yaml file to the following:</p> <pre><code>name: Run pr agent on every opened issue, respond to user comments on an issue\n\n#When the action is triggered\non:\n  issues:\n    types: [opened] #New issue\n\n# Read env. variables\nenv:\n  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n  GITHUB_API_URL: ${{ github.api_url }}\n  GIT_REPO_URL: ${{ github.event.repository.clone_url }}\n  ISSUE_URL: ${{ github.event.issue.html_url || github.event.comment.html_url }}\n  ISSUE_BODY: ${{ github.event.issue.body || github.event.comment.body }}\n  OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n\n# The actual set of actions\njobs:\n  issue_agent:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.sender.type != 'Bot' }} #Do not respond to bots\n\n    # Set required permissions\n    permissions:\n      contents: read    # For reading repository contents\n      issues: write     # For commenting on issues\n\n    steps:\n      - name: Run PR Agent on Issues\n        if: ${{ env.ISSUE_URL != '' }}\n        uses: docker://codiumai/pr-agent:latest\n        with:\n          entrypoint: /bin/bash #Replace invoking cli.py directly with a shell\n          args: |\n            -c \"cd /app &amp;&amp; \\\n            echo 'Running Issue Agent action step on ISSUE_URL=$ISSUE_URL' &amp;&amp; \\\n            export config__git_provider='github' &amp;&amp; \\\n                        export github__user_token=$GITHUB_TOKEN &amp;&amp; \\\n            export github__base_url=$GITHUB_API_URL &amp;&amp; \\\n            export openai__key=$OPENAI_KEY &amp;&amp; \\\n            python -m pr_agent.cli --issue_url=$ISSUE_URL --pr_help_docs.repo_url=\"...\" --pr_help_docs.docs_path=\"...\" --pr_help_docs.openai_key=$OPENAI_KEY &amp;&amp; \\\n            help_docs \"$ISSUE_BODY\"\n</code></pre> <p>3) Following completion of the remaining steps (such as adding secrets and relevant configurations, such as <code>repo_url</code> and <code>docs_path</code>) merge this change to your main branch. When a new issue is opened, you should see a comment from <code>github-actions</code> bot with an auto response, assuming the question is related to the documentation of the repository.</p>"},{"location":"tools/help_docs/#configuration-options","title":"Configuration options","text":"<p>Under the section <code>pr_help_docs</code>, the configuration file contains options to customize the 'help docs' tool:</p> <ul> <li><code>repo_url</code>: If not overwritten, will use the repo from where the context came from (issue or PR), otherwise - use the given repo as context.</li> <li><code>repo_default_branch</code>: The branch to use in case repo_url overwritten, otherwise - has no effect.</li> <li><code>docs_path</code>: Relative path from root of repository (either the one this PR has been issued for, or above repo url).</li> <li><code>exclude_root_readme</code>:  Whether or not to exclude the root README file for querying the model.</li> <li><code>supported_doc_exts</code> : Which file extensions should be included for the purpose of querying the model.</li> </ul>"},{"location":"tools/improve/","title":"Improve","text":""},{"location":"tools/improve/#overview","title":"Overview","text":"<p>The <code>improve</code> tool scans the PR code changes, and automatically generates meaningful suggestions for improving the PR code. The tool can be triggered automatically every time a new PR is opened, or it can be invoked manually by commenting on any PR:</p> <pre><code>/improve\n</code></pre>"},{"location":"tools/improve/#how-it-looks","title":"How it looks","text":"Suggestions OverviewSelecting a specific suggestion"},{"location":"tools/improve/#example-usage","title":"Example usage","text":""},{"location":"tools/improve/#manual-triggering","title":"Manual triggering","text":"<p>Invoke the tool manually by commenting <code>/improve</code> on any PR. The code suggestions by default are presented as a single comment:</p> <p>To edit configurations related to the <code>improve</code> tool, use the following template:</p> <pre><code>/improve --pr_code_suggestions.some_config1=... --pr_code_suggestions.some_config2=...\n</code></pre> <p>For example, you can choose to present all the suggestions as committable code comments, by running the following command:</p> <pre><code>/improve --pr_code_suggestions.commitable_code_suggestions=true\n</code></pre> <p></p>"},{"location":"tools/improve/#automatic-triggering","title":"Automatic triggering","text":"<p>To run the <code>improve</code> automatically when a PR is opened, define in a configuration file:</p> <pre><code>[github_app]\npr_commands = [\n    \"/improve\",\n    ...\n]\n\n[pr_code_suggestions]\nnum_code_suggestions_per_chunk = ...\n...\n</code></pre> <ul> <li>The <code>pr_commands</code> lists commands that will be executed automatically when a PR is opened.</li> <li>The <code>[pr_code_suggestions]</code> section contains the configurations for the <code>improve</code> tool you want to edit (if any)</li> </ul>"},{"location":"tools/improve/#table-vs-committable-code-comments","title":"Table vs Committable code comments","text":"<p>PR-Agent supports two modes for presenting code suggestions: </p> <p>1) Table mode </p> <p>2) Inline Committable code comments mode.</p> <p>The table format offers several key advantages:</p> <ul> <li>Reduced noise: Creates a cleaner PR experience with less clutter</li> <li>Quick overview and prioritization: Enables quick review of one-liner summaries, impact levels, and easy prioritization</li> <li>High-level suggestions: High-level suggestions that aren't tied to specific code chunks are presented only in the table mode</li> <li>Interactive features: Provides 'more' and 'update' functionality via clickable buttons</li> <li>Centralized tracking: Shows suggestion implementation status in one place</li> <li>IDE integration: Allows applying suggestions directly in your IDE via the CLI tool</li> </ul> <p>Table mode is the default of PR-Agent, and is recommended approach for most users due to these benefits. </p> <p></p> <p>Teams with specific preferences can enable committable code comments mode in their local configuration, or use dual publishing mode.</p> <p><code>Note - due to platform limitations, Bitbucket cloud and server supports only committable code comments mode.</code></p>"},{"location":"tools/improve/#extra-instructions-and-best-practices","title":"<code>Extra instructions</code> and <code>best practices</code>","text":"<p>The <code>improve</code> tool can be further customized by providing additional instructions and best practices to the AI model.</p>"},{"location":"tools/improve/#extra-instructions","title":"Extra instructions","text":"<p>You can use the <code>extra_instructions</code> configuration option to give the AI model additional instructions for the <code>improve</code> tool. Be specific, clear, and concise in the instructions. With extra instructions, you are the prompter.</p> <p>Examples for possible instructions:</p> <pre><code>[pr_code_suggestions]\nextra_instructions=\"\"\"\\\n(1) Answer in Japanese\n(2) Don't suggest to add try-except block\n(3) Ignore changes in toml files\n...\n\"\"\"\n</code></pre> <p>Use triple quotes to write multi-line instructions. Use bullet points or numbers to make the instructions more readable.</p>"},{"location":"tools/improve/#best-practices","title":"Best practices","text":"<p><code>Platforms supported: GitHub, GitLab, Bitbucket</code></p> <p>PR-Agent supports both simple and hierarchical best practices configurations to provide guidance to the AI model for generating relevant code suggestions.</p> Writing effective best practices files <p>The following guidelines apply to all best practices files:</p> <ul> <li>Write clearly and concisely</li> <li>Include brief code examples when helpful with before/after patterns</li> <li>Focus on project-specific guidelines that will result in relevant suggestions you actually want to get</li> <li>Keep each file relatively short, under 800 lines, since:<ul> <li>AI models may not process effectively very long documents</li> <li>Long files tend to contain generic guidelines already known to AI</li> <li>Maximum multiple file accumulated content is limited to 2000 lines.</li> </ul> </li> <li>Use pattern-based structure rather than simple bullet points for better clarity</li> </ul> Example of a best practices file <p>Pattern 1: Add proper error handling with try-except blocks around external function calls.</p> <p>Example code before:</p> <pre><code># Some code that might raise an exception\nreturn process_pr_data(data)\n</code></pre> <p>Example code after:</p> <pre><code>try:\n    # Some code that might raise an exception\n    return process_pr_data(data)\nexcept Exception as e:\n    logger.exception(\"Failed to process request\", extra={\"error\": e})\n</code></pre> <p>Pattern 2: Add defensive null/empty checks before accessing object properties or performing operations on potentially null variables to prevent runtime errors.</p> <p>Example code before:</p> <pre><code>def get_pr_code(pr_data):\n    if \"changed_code\" in pr_data:\n        return pr_data.get(\"changed_code\", \"\")\n    return \"\"\n</code></pre> <p>Example code after:</p> <pre><code>def get_pr_code(pr_data):\n    if pr_data is None:\n        return \"\"\n    if \"changed_code\" in pr_data:\n        return pr_data.get(\"changed_code\", \"\")\n    return \"\"\n</code></pre>"},{"location":"tools/improve/#local-best-practices","title":"Local best practices","text":"<p>For basic usage, create a <code>best_practices.md</code> file in your repository's root directory containing a list of best practices, coding standards, and guidelines specific to your repository.</p> <p>The AI model will use this <code>best_practices.md</code> file as a reference, and in case the PR code violates any of the guidelines, it will create additional suggestions, with a dedicated label: <code>Organization best practice</code>.</p>"},{"location":"tools/improve/#combining-extra-instructions-and-best-practices","title":"Combining 'extra instructions' and 'best practices'","text":"<p>The <code>extra instructions</code> configuration is more related to the <code>improve</code> tool prompt. It can be used, for example, to avoid specific suggestions (\"Don't suggest to add try-except block\", \"Ignore changes in toml files\", ...) or to emphasize specific aspects or formats (\"Answer in Japanese\", \"Give only short suggestions\", ...)</p> <p>In contrast, the <code>best_practices.md</code> file is a general guideline for the way code should be written in the repo.</p> <p>Using a combination of both can help the AI model to provide relevant and tailored suggestions.</p>"},{"location":"tools/improve/#usage-tips","title":"Usage Tips","text":""},{"location":"tools/improve/#implementing-the-proposed-code-suggestions","title":"Implementing the proposed code suggestions","text":"<p>Each generated suggestion consists of three key elements:</p> <ol> <li>A single-line summary of the proposed change</li> <li>An expandable section containing a comprehensive description of the suggestion</li> <li>A diff snippet showing the recommended code modification (before and after)</li> </ol> <p>We advise users to apply critical analysis and judgment when implementing the proposed suggestions. In addition to mistakes (which may happen, but are rare), sometimes the presented code modification may serve more as an illustrative example than a directly applicable solution. In such cases, we recommend prioritizing the suggestion's detailed description, using the diff snippet primarily as a supporting reference.</p>"},{"location":"tools/improve/#dual-publishing-mode","title":"Dual publishing mode","text":"<p>Our recommended approach for presenting code suggestions is through a table (<code>--pr_code_suggestions.commitable_code_suggestions=false</code>). This method significantly reduces the PR footprint and allows for quick and easy digestion of multiple suggestions.</p> <p>We also offer a complementary dual publishing mode. When enabled, suggestions exceeding a certain score threshold are not only displayed in the table, but also presented as committable PR comments. This mode helps highlight suggestions deemed more critical.</p> <p>To activate dual publishing mode, use the following setting:</p> <pre><code>[pr_code_suggestions]\ndual_publishing_score_threshold = x\n</code></pre> <p>Where x represents the minimum score threshold (&gt;=) for suggestions to be presented as committable PR comments in addition to the table. Default is -1 (disabled).</p>"},{"location":"tools/improve/#self-review","title":"Self-review","text":"<p><code>Platforms supported: GitHub, GitLab</code></p> <p>If you set in a configuration file:</p> <pre><code>[pr_code_suggestions]\ndemand_code_suggestions_self_review = true\n</code></pre> <p>The <code>improve</code> tool will add a checkbox below the suggestions, prompting user to acknowledge that they have reviewed the suggestions. You can set the content of the checkbox text via:</p> <pre><code>[pr_code_suggestions]\ncode_suggestions_self_review_text = \"... (your text here) ...\"\n</code></pre> <p></p> <p>Tip - Reducing visual footprint after self-review</p> <p>The configuration parameter <code>pr_code_suggestions.fold_suggestions_on_self_review</code> (default is True) can be used to automatically fold the suggestions after the user clicks the self-review checkbox.</p> <p>This reduces the visual footprint of the suggestions, and also indicates to the PR reviewer that the suggestions have been reviewed by the PR author, and don't require further attention.</p> <p>Tip - Demanding self-review from the PR author</p> <p>By setting: </p><pre><code>[pr_code_suggestions]\napprove_pr_on_self_review = true\n</code></pre> the tool can automatically add an approval when the PR author clicks the self-review checkbox.<p></p> <ul> <li>If you set the number of required reviewers for a PR to 2, this effectively means that the PR author must click the self-review checkbox before the PR can be merged (in addition to a human reviewer).</li> </ul> <p></p> <ul> <li> <p>If you keep the number of required reviewers for a PR to 1 and enable this configuration, this effectively means that the PR author can approve the PR by actively clicking the self-review checkbox.</p> <p>To prevent unauthorized approvals, this configuration defaults to false, and cannot be altered through online comments; enabling requires a direct update to the configuration file and a commit to the repository. This ensures that utilizing the feature demands a deliberate documented decision by the repository owner.</p> </li> </ul>"},{"location":"tools/improve/#how-many-code-suggestions-are-generated","title":"How many code suggestions are generated?","text":"<p>PR-Agent uses a dynamic strategy to generate code suggestions based on the size of the pull request (PR). Here's how it works:</p>"},{"location":"tools/improve/#1-chunking-large-prs","title":"1. Chunking large PRs","text":"<ul> <li>PR-Agent divides large PRs into 'chunks'.</li> <li>Each chunk contains up to <code>config.max_model_tokens</code> tokens (default: 32,000).</li> </ul>"},{"location":"tools/improve/#2-generating-suggestions","title":"2. Generating suggestions","text":"<ul> <li>For each chunk, PR-Agent generates up to <code>pr_code_suggestions.num_code_suggestions_per_chunk</code> suggestions (default: 3).</li> </ul> <p>This approach has two main benefits:</p> <ul> <li>Scalability: The number of suggestions scales with the PR size, rather than being fixed.</li> <li>Quality: By processing smaller chunks, the AI can maintain higher quality suggestions, as larger contexts tend to decrease AI performance.</li> </ul> <p>Note: Chunking is primarily relevant for large PRs. For most PRs (up to 600 lines of code), PR-Agent will be able to process the entire code in a single call.</p>"},{"location":"tools/improve/#configuration-options","title":"Configuration options","text":"General options <p> extra_instructions Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\". commitable_code_suggestions If set to true, the tool will display the suggestions as committable code comments. Default is false. dual_publishing_score_threshold Minimum score threshold for suggestions to be presented as committable PR comments in addition to the table. Default is -1 (disabled). focus_only_on_problems If set to true, suggestions will focus primarily on identifying and fixing code problems, and less on style considerations like best practices, maintainability, or readability. Default is true. persistent_comment If set to true, the improve comment will be persistent, meaning that every new improve request will edit the previous one. Default is true. suggestions_score_threshold  Any suggestion with importance score less than this threshold will be removed. Default is 0. Highly recommend not to set this value above 7-8, since above it may clip relevant suggestions that can be useful.  enable_help_text If set to true, the tool will display a help text in the comment. Default is false. enable_chat_text If set to true, the tool will display a reference to the PR chat in the comment. Default is false. publish_output_no_suggestions If set to true, the tool will publish a comment even if no suggestions were found. Default is true. </p> Params for number of suggestions and AI calls <p> num_code_suggestions_per_chunk Number of code suggestions provided by the 'improve' tool, per chunk. Default is 3. max_number_of_calls Maximum number of chunks. Default is 3. </p>"},{"location":"tools/improve/#understanding-ai-code-suggestions","title":"Understanding AI Code Suggestions","text":"<ul> <li>AI Limitations: AI models for code are getting better and better, but they are not flawless. Not all the suggestions will be perfect, and a user should not accept all of them automatically. Critical reading and judgment are required. Mistakes of the AI are rare but can happen, and it is usually quite easy for a human to spot them.</li> <li>Purpose of Suggestions:<ul> <li>Self-reflection: The suggestions aim to enable developers to self-reflect and improve their pull requests. This process can help to identify blind spots, uncover missed edge cases, and enhance code readability and coherency. Even when a specific code suggestion isn't suitable, the underlying issue it highlights often reveals something important that might deserve attention.</li> <li>Bug detection: The suggestions also alert on any critical bugs that may have been identified during the analysis. This provides an additional safety net to catch potential issues before they make it into production. It's perfectly acceptable to implement only the suggestions you find valuable for your specific context.</li> </ul> </li> <li>Hierarchy: Presenting the suggestions in a structured hierarchical table enables the user to quickly understand them, and to decide which ones are relevant and which are not.</li> <li>Customization: To guide the model to suggestions that are more relevant to the specific needs of your project, we recommend using the <code>extra_instructions</code> and <code>best practices</code> fields.</li> <li>Model Selection: For specific programming languages or use cases, some models may perform better than others.</li> </ul>"},{"location":"tools/review/","title":"Review","text":""},{"location":"tools/review/#overview","title":"Overview","text":"<p>The <code>review</code> tool scans the PR code changes, and generates feedback about the PR, aiming to aid the reviewing process.  The tool can be triggered automatically every time a new PR is opened, or can be invoked manually by commenting on any PR:</p> <pre><code>/review\n</code></pre> <p>Note that the main purpose of the <code>review</code> tool is to provide the PR reviewer with useful feedback and insights. The PR author, in contrast, may prefer to save time and focus on the output of the improve tool, which provides actionable code suggestions.</p> <p>(Read more about the different personas in the PR process and how PR-Agent aims to assist them in our blog)</p>"},{"location":"tools/review/#example-usage","title":"Example usage","text":""},{"location":"tools/review/#manual-triggering","title":"Manual triggering","text":"<p>Invoke the tool manually by commenting <code>/review</code> on any PR:</p> <p></p> <p>After ~30 seconds, the tool will generate a review for the PR:</p> <p></p> <p>If you want to edit configurations, add the relevant ones to the command:</p> <pre><code>/review --pr_reviewer.some_config1=... --pr_reviewer.some_config2=...\n</code></pre>"},{"location":"tools/review/#automatic-triggering","title":"Automatic triggering","text":"<p>To run the <code>review</code> automatically when a PR is opened, define in a configuration file:</p> <pre><code>[github_app]\npr_commands = [\n    \"/review\",\n    ...\n]\n\n[pr_reviewer]\nextra_instructions = \"...\"\n...\n</code></pre> <ul> <li>The <code>pr_commands</code> lists commands that will be executed automatically when a PR is opened.</li> <li>The <code>[pr_reviewer]</code> section contains the configurations for the <code>review</code> tool you want to edit (if any).</li> </ul>"},{"location":"tools/review/#configuration-options","title":"Configuration options","text":"General options <p> persistent_comment If set to true, the review comment will be persistent, meaning that every new review request will edit the previous one. Default is true. final_update_message When set to true, updating a persistent review comment during online commenting will automatically add a short comment with a link to the updated review in the pull request .Default is true. extra_instructions Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\". enable_help_text If set to true, the tool will display a help text in the comment. Default is false. num_max_findings Number of maximum returned findings. Default is 3. </p> Enable\\disable specific sub-sections <p> require_score_review If set to true, the tool will add a section that scores the PR. Default is false. require_tests_review If set to true, the tool will add a section that checks if the PR contains tests. Default is true. require_estimate_effort_to_review If set to true, the tool will add a section that estimates the effort needed to review the PR. Default is true. require_estimate_contribution_time_cost If set to true, the tool will add a section that estimates the time required for a senior developer to create and submit such changes. Default is false. require_can_be_split_review If set to true, the tool will add a section that checks if the PR contains several themes, and can be split into smaller PRs. Default is false. require_security_review If set to true, the tool will add a section that checks if the PR contains a possible security or vulnerability issue. Default is true. require_todo_scan If set to true, the tool will add a section that lists TODO comments found in the PR code changes. Default is false.      require_ticket_analysis_review If set to true, and the PR contains a GitHub or Jira ticket link, the tool will add a section that checks if the PR in fact fulfilled the ticket requirements. Default is true. </p> Adding PR labels <p>You can enable\\disable the <code>review</code> tool to add specific labels to the PR:</p> <p> enable_review_labels_security If set to true, the tool will publish a 'possible security issue' label if it detects a security issue. Default is true. enable_review_labels_effort If set to true, the tool will publish a 'Review effort x/5' label (1\u20135 scale). Default is true. </p>"},{"location":"tools/review/#usage-tips","title":"Usage Tips","text":""},{"location":"tools/review/#general-guidelines","title":"General guidelines","text":"<p>The <code>review</code> tool provides a collection of configurable feedbacks about a PR. It is recommended to review the Configuration options section, and choose the relevant options for your use case.</p> <p>Some of the features that are disabled by default are quite useful, and should be considered for enabling. For example: <code>require_score_review</code>, and more.</p> <p>On the other hand, if you find one of the enabled features to be irrelevant for your use case, disable it. No default configuration can fit all use cases.</p>"},{"location":"tools/review/#automation","title":"Automation","text":"<p>When you first install PR-Agent app, the default mode for the <code>review</code> tool is: </p><pre><code>pr_commands = [\"/review\", ...]\n</code></pre> Meaning the <code>review</code> tool will run automatically on every PR, without any additional configurations. Edit this field to enable/disable the tool, or to change the configurations used.<p></p>"},{"location":"tools/review/#auto-generated-pr-labels-by-the-review-tool","title":"Auto-generated PR labels by the Review Tool","text":"<p>The <code>review</code> can tool automatically add labels to your Pull Requests:</p> <ul> <li><code>possible security issue</code>: This label is applied if the tool detects a potential security vulnerability in the PR's code. This feedback is controlled by the 'enable_review_labels_security' flag (default is true).</li> <li><code>review effort [x/5]</code>: This label estimates the effort required to review the PR on a relative scale of 1 to 5, where 'x' represents the assessed effort. This feedback is controlled by the 'enable_review_labels_effort' flag (default is true).</li> <li><code>ticket compliance</code>: Adds a label indicating code compliance level (\"Fully compliant\" | \"PR Code Verified\" | \"Partially compliant\" | \"Not compliant\") to any GitHub/Jira/Linea ticket linked in the PR. Controlled by the 'require_ticket_labels' flag (default: false). If 'require_no_ticket_labels' is also enabled, PRs without ticket links will receive a \"No ticket found\" label.</li> </ul>"},{"location":"tools/review/#auto-blocking-prs-from-being-merged-based-on-the-generated-labels","title":"Auto-blocking PRs from being merged based on the generated labels","text":"<p>You can configure a CI/CD Action to prevent merging PRs with specific labels. For example, implement a dedicated GitHub Action.</p> <p>This approach helps ensure PRs with potential security issues or ticket compliance problems will not be merged without further review.</p> <p>Since AI may make mistakes or lack complete context, use this feature judiciously. For flexibility, users with appropriate permissions can remove generated labels when necessary. When a label is removed, this action will be automatically documented in the PR discussion, clearly indicating it was a deliberate override by an authorized user to allow the merge.</p>"},{"location":"tools/review/#extra-instructions","title":"Extra instructions","text":"<p>Extra instructions are important. The <code>review</code> tool can be configured with extra instructions, which can be used to guide the model to a feedback tailored to the needs of your project.</p> <p>Be specific, clear, and concise in the instructions. With extra instructions, you are the prompter. Specify the relevant sub-tool, and the relevant aspects of the PR that you want to emphasize.</p> <p>Examples of extra instructions: </p><pre><code>[pr_reviewer]\nextra_instructions=\"\"\"\\\nIn the code feedback section, emphasize the following:\n- Does the code logic cover relevant edge cases?\n- Is the code logic clear and easy to understand?\n- Is the code logic efficient?\n...\n\"\"\"\n</code></pre> Use triple quotes to write multi-line instructions. Use bullet points to make the instructions more readable.<p></p>"},{"location":"tools/similar_issues/","title":"Similar Issues","text":""},{"location":"tools/similar_issues/#overview","title":"Overview","text":"<p>The similar issue tool retrieves the most similar issues to the current issue. It can be invoked manually by commenting on any PR:</p> <pre><code>/similar_issue\n</code></pre>"},{"location":"tools/similar_issues/#example-usage","title":"Example usage","text":"<p>Note that to perform retrieval, the <code>similar_issue</code> tool indexes all the repo previous issues (once).</p>"},{"location":"tools/similar_issues/#selecting-a-vector-database","title":"Selecting a Vector Database","text":"<p>Configure your preferred database by changing the <code>pr_similar_issue</code> parameter in <code>configuration.toml</code> file.</p>"},{"location":"tools/similar_issues/#available-options","title":"Available Options","text":"<p>Choose from the following Vector Databases:</p> <ol> <li>LanceDB</li> <li>Pinecone</li> <li>Qdrant</li> </ol>"},{"location":"tools/similar_issues/#pinecone-configuration","title":"Pinecone Configuration","text":"<p>To use Pinecone with the <code>similar issue</code> tool, add these credentials to <code>.secrets.toml</code> (or set as environment variables):</p> <pre><code>[pinecone]\napi_key = \"...\"\nenvironment = \"...\"\n</code></pre> <p>These parameters can be obtained by registering to Pinecone.</p>"},{"location":"tools/similar_issues/#qdrant-configuration","title":"Qdrant Configuration","text":"<p>To use Qdrant with the <code>similar issue</code> tool, add these credentials to <code>.secrets.toml</code> (or set as environment variables):</p> <pre><code>[qdrant]\nurl = \"https://YOUR-QDRANT-URL\" # e.g., https://xxxxxxxx-xxxxxxxx.eu-central-1-0.aws.cloud.qdrant.io\napi_key = \"...\"\n</code></pre> <p>Then select Qdrant in <code>configuration.toml</code>:</p> <pre><code>[pr_similar_issue]\nvectordb = \"qdrant\"\n</code></pre> <p>You can get a free managed Qdrant instance from Qdrant Cloud.</p>"},{"location":"tools/similar_issues/#how-to-use","title":"How to use","text":"<ul> <li> <p>To invoke the 'similar issue' tool from CLI, run: <code>python3 cli.py --issue_url=... similar_issue</code></p> </li> <li> <p>To invoke the 'similar' issue tool via online usage, comment on a PR: <code>/similar_issue</code></p> </li> <li> <p>You can also enable the 'similar issue' tool to run automatically when a new issue is opened, by adding it to the pr_commands list in the github_app section</p> </li> </ul>"},{"location":"tools/update_changelog/","title":"Update Changelog","text":""},{"location":"tools/update_changelog/#overview","title":"Overview","text":"<p>The <code>update_changelog</code> tool automatically updates the CHANGELOG.md file with the PR changes. It can be invoked manually by commenting on any PR:</p> <pre><code>/update_changelog\n</code></pre>"},{"location":"tools/update_changelog/#example-usage","title":"Example usage","text":""},{"location":"tools/update_changelog/#configuration-options","title":"Configuration options","text":"<p>Under the section <code>pr_update_changelog</code>, the configuration file contains options to customize the 'update changelog' tool:</p> <ul> <li><code>push_changelog_changes</code>: whether to push the changes to CHANGELOG.md, or just publish them as a comment. Default is false (publish as comment).</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"Use the following structure: ...\"</li> <li><code>add_pr_link</code>: whether the model should try to add a link to the PR in the changelog. Default is true.</li> <li><code>skip_ci_on_push</code>: whether the commit message (when <code>push_changelog_changes</code> is true) will include the term \"[skip ci]\", preventing CI tests to be triggered on the changelog commit. Default is true.</li> </ul>"},{"location":"usage-guide/","title":"Usage guide","text":""},{"location":"usage-guide/#usage-guide","title":"Usage guide","text":"<p>This section provides a detailed guide on how to use PR-Agent. It includes information on how to adjust PR-Agent configurations, define which tools will run automatically, and other advanced configurations.</p> <ul> <li>Introduction</li> <li>Configuration File</li> <li>Usage and Automation<ul> <li>Local Repo (CLI)</li> <li>Online Usage</li> <li>GitHub App</li> <li>GitHub Action</li> <li>GitLab Webhook</li> <li>Gitea Webhook</li> <li>BitBucket App</li> <li>Azure DevOps Provider</li> </ul> </li> <li>Managing Mail Notifications</li> <li>Changing a Model</li> <li>Additional Configurations<ul> <li>Ignoring files from analysis</li> <li>Extra instructions</li> <li>Working with large PRs</li> <li>Changing a model</li> </ul> </li> <li>FAQ</li> </ul>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/","title":"EXAMPLE BEST PRACTICE","text":""},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#recommend-python-best-practices","title":"Recommend Python Best Practices","text":"<p>This document outlines a series of recommended best practices for Python development. These guidelines aim to improve code quality, maintainability, and readability.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#imports","title":"Imports","text":"<p>Use  <code>import</code>  statements for packages and modules only, not for individual types, classes, or functions.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#definition","title":"Definition","text":"<p>Reusability mechanism for sharing code from one module to another.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision","title":"Decision","text":"<ul> <li>Use  <code>import x</code>  for importing packages and modules.</li> <li>Use  <code>from x import y</code>  where  <code>x</code>  is the package prefix and  <code>y</code>  is the module name with no prefix.</li> <li>Use  <code>from x import y as z</code>  in any of the following circumstances:</li> <li>Two modules named  <code>y</code>  are to be imported.</li> <li><code>y</code>  conflicts with a top-level name defined in the current module.</li> <li><code>y</code>  conflicts with a common parameter name that is part of the public API (e.g.,  <code>features</code>).</li> <li><code>y</code>  is an inconveniently long name, or too generic in the context of your code</li> <li>Use  <code>import y as z</code>  only when  <code>z</code>  is a standard abbreviation (e.g.,  <code>import numpy as np</code>).</li> </ul> <p>For example the module  <code>sound.effects.echo</code>  may be imported as follows:</p> <pre><code>from sound.effects import echo\n...\necho.EchoFilter(input, output, delay=0.7, atten=4)\n</code></pre> <p>Do not use relative names in imports. Even if the module is in the same package, use the full package name. This helps prevent unintentionally importing a package twice.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#exemptions","title":"Exemptions","text":"<p>Exemptions from this rule:</p> <ul> <li>Symbols from the following modules are used to support static analysis and type checking:</li> <li><code>typing</code>  module</li> <li><code>collections.abc</code>  module</li> <li><code>typing_extensions</code>  module</li> <li>Redirects from the  six.moves module.</li> </ul>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#packages","title":"Packages","text":"<p>Import each module using the full pathname location of the module.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_1","title":"Decision","text":"<p>All new code should import each module by its full package name.</p> <p>Imports should be as follows:</p> <pre><code>Yes:\n  # Reference absl.flags in code with the complete name (verbose).\n  import absl.flags\n  from doctor.who import jodie\n\n  _FOO = absl.flags.DEFINE_string(...)\n</code></pre> <pre><code>Yes:\n  # Reference flags in code with just the module name (common).\n  from absl import flags\n  from doctor.who import jodie\n\n  _FOO = flags.DEFINE_string(...)\n</code></pre> <p>(assume this file lives in  <code>doctor/who/</code>  where  <code>jodie.py</code>  also exists)</p> <pre><code>No:\n  # Unclear what module the author wanted and what will be imported.  The actual\n  # import behavior depends on external factors controlling sys.path.\n  # Which possible jodie module did the author intend to import?\n  import jodie\n</code></pre> <p>The directory the main binary is located in should not be assumed to be in  <code>sys.path</code>  despite that happening in some environments. This being the case, code should assume that  <code>import jodie</code>  refers to a third-party or top-level package named  <code>jodie</code>, not a local  <code>jodie.py</code>.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#default-iterators-and-operators","title":"Default Iterators and Operators","text":"<p>Use default iterators and operators for types that support them, like lists, dictionaries, and files.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#definition_1","title":"Definition","text":"<p>Container types, like dictionaries and lists, define default iterators and membership test operators (\u201cin\u201d and \u201cnot in\u201d).</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_2","title":"Decision","text":"<p>Use default iterators and operators for types that support them, like lists, dictionaries, and files. The built-in types define iterator methods, too. Prefer these methods to methods that return lists, except that you should not mutate a container while iterating over it.</p> <pre><code>Yes:  for key in adict: ...\n      if obj in alist: ...\n      for line in afile: ...\n      for k, v in adict.items(): ...\n</code></pre> <pre><code>No:   for key in adict.keys(): ...\n      for line in afile.readlines(): ...\n</code></pre>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#lambda-functions","title":"Lambda Functions","text":"<p>Okay for one-liners. Prefer generator expressions over  <code>map()</code>  or  <code>filter()</code>  with a  <code>lambda</code>.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_3","title":"Decision","text":"<p>Lambdas are allowed. If the code inside the lambda function spans multiple lines or is longer than 60-80 chars, it might be better to define it as a regular  nested function.</p> <p>For common operations like multiplication, use the functions from the  <code>operator</code>  module instead of lambda functions. For example, prefer  <code>operator.mul</code>  to  <code>lambda x, y: x * y</code>.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#default-argument-values","title":"Default Argument Values","text":"<p>Okay in most cases.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#definition_2","title":"Definition","text":"<p>You can specify values for variables at the end of a function\u2019s parameter list, e.g.,  <code>def foo(a, b=0):</code>. If  <code>foo</code>  is called with only one argument,  <code>b</code>  is set to 0. If it is called with two arguments,  <code>b</code>  has the value of the second argument.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_4","title":"Decision","text":"<p>Okay to use with the following caveat:</p> <p>Do not use mutable objects as default values in the function or method definition.</p> <pre><code>Yes: def foo(a, b=None):\n         if b is None:\n             b = []\nYes: def foo(a, b: Sequence | None = None):\n         if b is None:\n             b = []\nYes: def foo(a, b: Sequence = ()):  # Empty tuple OK since tuples are immutable.\n         ...\n</code></pre> <pre><code>from absl import flags\n_FOO = flags.DEFINE_string(...)\n\nNo:  def foo(a, b=[]):\n         ...\nNo:  def foo(a, b=time.time()):  # Is `b` supposed to represent when this module was loaded?\n         ...\nNo:  def foo(a, b=_FOO.value):  # sys.argv has not yet been parsed...\n         ...\nNo:  def foo(a, b: Mapping = {}):  # Could still get passed to unchecked code.\n         ...\n</code></pre>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#truefalse-evaluations","title":"True/False Evaluations","text":"<p>Use the \u201cimplicit\u201d false if possible, e.g.,  <code>if foo:</code>  rather than  <code>if foo != []:</code></p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#lexical-scoping","title":"Lexical Scoping","text":"<p>Okay to use.</p> <p>An example of the use of this feature is:</p> <pre><code>def get_adder(summand1: float) -&gt; Callable[[float], float]:\n    \"\"\"Returns a function that adds numbers to a given number.\"\"\"\n    def adder(summand2: float) -&gt; float:\n        return summand1 + summand2\n\n    return adder\n</code></pre>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_5","title":"Decision","text":"<p>Okay to use.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#threading","title":"Threading","text":"<p>Do not rely on the atomicity of built-in types.</p> <p>While Python\u2019s built-in data types such as dictionaries appear to have atomic operations, there are corner cases where they aren\u2019t atomic (e.g. if  <code>__hash__</code>  or  <code>__eq__</code>  are implemented as Python methods) and their atomicity should not be relied upon. Neither should you rely on atomic variable assignment (since this in turn depends on dictionaries).</p> <p>Use the  <code>queue</code>  module\u2019s  <code>Queue</code>  data type as the preferred way to communicate data between threads. Otherwise, use the  <code>threading</code>  module and its locking primitives. Prefer condition variables and  <code>threading.Condition</code>  instead of using lower-level locks.</p>"},{"location":"usage-guide/additional_configurations/","title":"Additional Configurations","text":""},{"location":"usage-guide/additional_configurations/#show-possible-configurations","title":"Show possible configurations","text":"<p>The possible configurations of PR-Agent are stored in here. In the tools page you can find explanations on how to use these configurations for each tool.</p> <p>To print all the available configurations as a comment on your PR, you can use the following command:</p> <pre><code>/config\n</code></pre> <p></p> <p>To view the actual configurations used for a specific tool, after all the user settings are applied, you can add for each tool a <code>--config.output_relevant_configurations=true</code> suffix. For example:</p> <pre><code>/improve --config.output_relevant_configurations=true\n</code></pre> <p>Will output an additional field showing the actual configurations used for the <code>improve</code> tool.</p> <p></p>"},{"location":"usage-guide/additional_configurations/#ignoring-files-from-analysis","title":"Ignoring files from analysis","text":"<p>In some cases, you may want to exclude specific files or directories from the analysis performed by PR-Agent. This can be useful, for example, when you have files that are generated automatically or files that shouldn't be reviewed, like vendor code.</p> <p>You can ignore files or folders using the following methods:</p> <ul> <li><code>IGNORE.GLOB</code></li> <li><code>IGNORE.REGEX</code></li> </ul> <p>which you can edit to ignore files or folders based on glob or regex patterns.</p>"},{"location":"usage-guide/additional_configurations/#example-usage","title":"Example usage","text":"<p>Let's look at an example where we want to ignore all files with <code>.py</code> extension from the analysis.</p> <p>To ignore Python files in a PR with online usage, comment on a PR: <code>/review --ignore.glob=\"['*.py']\"</code></p> <p>To ignore Python files in all PRs using <code>glob</code> pattern, set in a configuration file:</p> <pre><code>[ignore]\nglob = ['*.py']\n</code></pre> <p>And to ignore Python files in all PRs using <code>regex</code> pattern, set in a configuration file:</p> <pre><code>[ignore]\nregex = ['.*\\.py$']\n</code></pre>"},{"location":"usage-guide/additional_configurations/#extra-instructions","title":"Extra instructions","text":"<p>All PR-Agent tools have a parameter called <code>extra_instructions</code>, that enables to add free-text extra instructions. Example usage:</p> <pre><code>/update_changelog --pr_update_changelog.extra_instructions=\"Make sure to update also the version ...\"\n</code></pre>"},{"location":"usage-guide/additional_configurations/#language-settings","title":"Language Settings","text":"<p>The default response language for PR-Agent is U.S. English. However, some development teams may prefer to display information in a different language. For example, your team's workflow might improve if PR descriptions and code suggestions are set to your country's native language.</p> <p>To configure this, set the <code>response_language</code> parameter in the configuration file. This will prompt the model to respond in the specified language. Use a standard locale code based on ISO 3166 (country codes) and ISO 639 (language codes) to define a language-country pair. See this comprehensive list of locale codes.</p> <p>Example:</p> <pre><code>[config]\nresponse_language = \"it-IT\"\n</code></pre> <p>This will set the response language globally for all the commands to Italian.</p> <p>Important: Note that only dynamic text generated by the AI model is translated to the configured language. Static text such as labels and table headers that are not part of the AI models response will remain in US English. In addition, the model you are using must have good support for the specified language.</p>"},{"location":"usage-guide/additional_configurations/#expand-gitlab-submodule-diffs","title":"Expand GitLab submodule diffs","text":"<p>By default, GitLab merge requests show submodule updates as <code>Subproject commit</code> lines. To include the actual file-level changes from those submodules in PR-Agent analysis, enable:</p> <pre><code>[gitlab]\nexpand_submodule_diffs = true\n</code></pre> <p>When enabled, PR-Agent will fetch and attach diffs from the submodule repositories. The default is <code>false</code> to avoid extra GitLab API calls.</p>"},{"location":"usage-guide/additional_configurations/#log-level","title":"Log Level","text":"<p>PR-Agent allows you to control the verbosity of logging by using the <code>log_level</code> configuration parameter. This is particularly useful for troubleshooting and debugging issues with your PR workflows.</p> <pre><code>[config]\nlog_level = \"DEBUG\"  # Options: \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"\n</code></pre> <p>The default log level is \"DEBUG\", which provides detailed output of all operations. If you prefer less verbose logs, you can set higher log levels like \"INFO\" or \"WARNING\".</p>"},{"location":"usage-guide/additional_configurations/#integrating-with-logging-observability-platforms","title":"Integrating with Logging Observability Platforms","text":"<p>Various logging observability tools can be used out-of-the box when using the default LiteLLM AI Handler. Simply configure the LiteLLM callback settings in <code>configuration.toml</code> and set environment variables according to the LiteLLM documentation.</p> <p>For example, to use LangSmith you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[litellm]\nenable_callbacks = true\nsuccess_callback = [\"langsmith\"]\nfailure_callback = [\"langsmith\"]\nservice_callback = []\n</code></pre> <p>Then set the following environment variables:</p> <pre><code>LANGSMITH_API_KEY=&lt;api_key&gt;\nLANGSMITH_PROJECT=&lt;project&gt;\nLANGSMITH_BASE_URL=&lt;url&gt;\n</code></pre>"},{"location":"usage-guide/additional_configurations/#bringing-additional-repository-metadata-to-pr-agent","title":"Bringing additional repository metadata to PR-Agent","text":"<p>To provide PR-Agent tools with additional context about your project, you can enable automatic repository metadata detection. </p> <p>If you set:</p> <pre><code>[config]\nadd_repo_metadata = true\n</code></pre> <p>PR-Agent automatically searches for repository metadata files in your PR's head branch root directory. By default, it looks for: AGENTS.MD, QODO.MD, CLAUDE.MD.</p> <p>You can also specify custom filenames to search for:</p> <pre><code>[config]\nadd_repo_metadata_file_list= [\"file1.md\", \"file2.md\", ...]\n</code></pre>"},{"location":"usage-guide/additional_configurations/#ignoring-automatic-commands-in-prs","title":"Ignoring automatic commands in PRs","text":"<p>PR-Agent allows you to automatically ignore certain PRs based on various criteria:</p> <ul> <li>PRs with specific titles (using regex matching)</li> <li>PRs between specific branches (using regex matching)</li> <li>PRs from specific repositories (using regex matching)</li> <li>PRs not from specific folders</li> <li>PRs containing specific labels</li> <li>PRs opened by specific users</li> </ul>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-with-specific-titles","title":"Ignoring PRs with specific titles","text":"<p>To ignore PRs with a specific title such as \"[Bump]: ...\", you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_pr_title = [\"\\\\[Bump\\\\]\"]\n</code></pre> <p>Where the <code>ignore_pr_title</code> is a list of regex patterns to match the PR title you want to ignore. Default is <code>ignore_pr_title = [\"^\\\\[Auto\\\\]\", \"^Auto\"]</code>.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-between-specific-branches","title":"Ignoring PRs between specific branches","text":"<p>To ignore PRs from specific source or target branches, you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_pr_source_branches = ['develop', 'main', 'master', 'stage']\nignore_pr_target_branches = [\"qa\"]\n</code></pre> <p>Where the <code>ignore_pr_source_branches</code> and <code>ignore_pr_target_branches</code> are lists of regex patterns to match the source and target branches you want to ignore. They are not mutually exclusive, you can use them together or separately.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-from-specific-repositories","title":"Ignoring PRs from specific repositories","text":"<p>To ignore PRs from specific repositories, you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_repositories = [\"my-org/my-repo1\", \"my-org/my-repo2\"]\n</code></pre> <p>Where the <code>ignore_repositories</code> is a list of regex patterns to match the repositories you want to ignore. This is useful when you have multiple repositories and want to exclude certain ones from analysis.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-not-from-specific-folders","title":"Ignoring PRs not from specific folders","text":"<p>To allow only specific folders (often needed in large monorepos), set:</p> <pre><code>[config]\nallow_only_specific_folders=['folder1','folder2']\n</code></pre> <p>For the configuration above, automatic feedback will only be triggered when the PR changes include files where 'folder1' or 'folder2' is in the file path</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-containing-specific-labels","title":"Ignoring PRs containing specific labels","text":"<p>To ignore PRs containing specific labels, you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_pr_labels = [\"do-not-merge\"]\n</code></pre> <p>Where the <code>ignore_pr_labels</code> is a list of labels that when present in the PR, the PR will be ignored.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-from-specific-users","title":"Ignoring PRs from specific users","text":"<p>PR-Agent tries to automatically identify and ignore pull requests created by bots using:</p> <ul> <li>GitHub's native bot detection system</li> <li>Name-based pattern matching</li> </ul> <p>While this detection is robust, it may not catch all cases, particularly when:</p> <ul> <li>Bots are registered as regular user accounts</li> <li>Bot names don't match common patterns</li> </ul> <p>To supplement the automatic bot detection, you can manually specify users to ignore. Add the following to your <code>configuration.toml</code> file to ignore PRs from specific users:</p> <pre><code>[config]\nignore_pr_authors = [\"my-special-bot-user\", ...]\n</code></pre> <p>Where the <code>ignore_pr_authors</code> is a regex list of usernames that you want to ignore.</p> <p>Note</p> <p>There is one specific case where bots will receive an automatic response - when they generated a PR with a failed test.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-generated-files-by-languageframework","title":"Ignoring Generated Files by Language/Framework","text":"<p>To automatically exclude files generated by specific languages or frameworks, you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_language_framework = ['protobuf', ...]\n</code></pre> <p>You can view the list of auto-generated file patterns in <code>generated_code_ignore.toml</code>. Files matching these glob patterns will be automatically excluded from PR Agent analysis.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-tickets-with-specific-labels","title":"Ignoring Tickets with Specific Labels","text":"<p>When PR-Agent analyzes tickets (JIRA, GitHub Issues, GitLab Issues, etc.) referenced in your PR, you may want to exclude tickets that have certain labels from the analysis. This is useful for filtering out tickets marked as \"ignore-compliance\", \"skip-review\", or other labels that indicate the ticket should not be considered during PR review.</p> <p>To ignore tickets with specific labels, add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_ticket_labels = [\"ignore-compliance\", \"skip-review\", \"wont-fix\"]\n</code></pre> <p>Where <code>ignore_ticket_labels</code> is a list of label names that should be ignored during ticket analysis.</p>"},{"location":"usage-guide/automations_and_usage/","title":"Usage and Automation","text":""},{"location":"usage-guide/automations_and_usage/#local-repo-cli","title":"Local repo (CLI)","text":"<p>When running from your locally cloned PR-Agent repo (CLI), your local configuration file will be used. Examples of invoking the different tools via the CLI:</p> <ul> <li>Review:       <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  review</code></li> <li>Describe:     <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  describe</code></li> <li>Improve:      <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  improve</code></li> <li>Ask:          <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  ask \"Write me a poem about this PR\"</code></li> <li>Update Changelog:      <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  update_changelog</code></li> </ul> <p><code>&lt;pr_url&gt;</code> is the url of the relevant PR (for example: #50).</p> <p>Notes:</p> <ol> <li>in addition to editing your local configuration file, you can also change any configuration value by adding it to the command line:</li> </ol> <pre><code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  /review --pr_reviewer.extra_instructions=\"focus on the file: ...\"\n</code></pre> <ol> <li>You can print results locally, without publishing them, by setting in <code>configuration.toml</code>:</li> </ol> <pre><code>[config]\npublish_output=false\nverbosity_level=2\n</code></pre> <p>This is useful for debugging or experimenting with different tools.</p> <ol> <li>git provider: The git_provider field in a configuration file determines the GIT provider that will be used by PR-Agent. Currently, the following providers are supported: <code>github</code> (default), <code>gitlab</code>, <code>bitbucket</code>, <code>azure</code>, <code>codecommit</code>, <code>local</code>, and <code>gitea</code>.</li> </ol>"},{"location":"usage-guide/automations_and_usage/#cli-health-check","title":"CLI Health Check","text":"<p>To verify that PR-Agent has been configured correctly, you can run this health check command from the repository root:</p> <pre><code>python -m tests.health_test.main\n</code></pre> <p>If the health check passes, you will see the following output:</p> <pre><code>========\nHealth test passed successfully\n========\n</code></pre> <p>At the end of the run.</p> <p>Before running the health check, ensure you have:</p> <ul> <li>Configured your LLM provider</li> <li>Added a valid GitHub token to your configuration file</li> </ul>"},{"location":"usage-guide/automations_and_usage/#online-usage","title":"Online usage","text":"<p>Online usage means invoking PR-Agent tools by comments on a PR. Commands for invoking the different tools via comments:</p> <ul> <li>Review:       <code>/review</code></li> <li>Describe:     <code>/describe</code></li> <li>Improve:      <code>/improve</code>  (or <code>/improve_code</code> for bitbucket, since <code>/improve</code> is sometimes reserved)</li> <li>Ask:          <code>/ask \"...\"</code></li> <li>Update Changelog:      <code>/update_changelog</code></li> </ul> <p>To edit a specific configuration value, just add <code>--config_path=&lt;value&gt;</code> to any command. For example, if you want to edit the <code>review</code> tool configurations, you can run:</p> <pre><code>/review --pr_reviewer.extra_instructions=\"...\" --pr_reviewer.require_score_review=false\n</code></pre> <p>Any configuration value in configuration file file can be similarly edited. Comment <code>/config</code> to see the list of available configurations.</p>"},{"location":"usage-guide/automations_and_usage/#pr-agent-automatic-feedback","title":"PR-Agent Automatic Feedback","text":""},{"location":"usage-guide/automations_and_usage/#disabling-all-automatic-feedback","title":"Disabling all automatic feedback","text":"<p>To easily disable all automatic feedback from PR-Agent (GitHub App, GitLab Webhook, BitBucket App, Azure DevOps Webhook), set in a configuration file:</p> <pre><code>[config]\ndisable_auto_feedback = true\n</code></pre> <p>When this parameter is set to <code>true</code>, PR-Agent will not run any automatic tools (like <code>describe</code>, <code>review</code>, <code>improve</code>) when a new PR is opened, or when new code is pushed to an open PR.</p>"},{"location":"usage-guide/automations_and_usage/#github-app","title":"GitHub App","text":"<p>Configurations for PR-Agent</p> <p>PR-Agent for GitHub is an App, hosted by Codium. So all the instructions below are relevant for PR-Agent users. Same goes for GitLab webhook and BitBucket App sections.</p>"},{"location":"usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened","title":"GitHub app automatic tools when a new PR is opened","text":"<p>The github_app section defines GitHub app specific configurations.</p> <p>The configuration parameter <code>pr_commands</code> defines the list of tools that will be run automatically when a new PR is opened:</p> <pre><code>[github_app]\npr_commands = [\n    \"/describe\",\n    \"/review\",\n    \"/improve\",\n]\n</code></pre> <p>This means that when a new PR is opened/reopened or marked as ready for review, PR-Agent will run the <code>describe</code>, <code>review</code> and <code>improve</code> tools.  </p> <p>Draft PRs: </p> <p>By default, draft PRs are not considered for automatic tools, but you can change this by setting the <code>feedback_on_draft_pr</code> parameter to <code>true</code> in the configuration file.</p> <pre><code>[github_app]\nfeedback_on_draft_pr = true\n</code></pre> <p>Changing default tool parameters:</p> <p>You can override the default tool parameters by using one the three options for a configuration file: wiki, local, or global. For example, if your configuration file contains:</p> <pre><code>[pr_description]\ngenerate_ai_title = true\n</code></pre> <p>Every time you run the <code>describe</code> tool (including automatic runs) the PR title will be generated by the AI.</p> <p>Parameters for automated runs:</p> <p>You can customize configurations specifically for automated runs by using the <code>--config_path=&lt;value&gt;</code> parameter. For instance, to modify the <code>review</code> tool settings only for newly opened PRs, use:</p> <pre><code>[github_app]\npr_commands = [\n    \"/describe\",\n    \"/review --pr_reviewer.extra_instructions='focus on the file: ...'\",\n    \"/improve\",\n]\n</code></pre>"},{"location":"usage-guide/automations_and_usage/#github-app-automatic-tools-for-push-actions-commits-to-an-open-pr","title":"GitHub app automatic tools for push actions (commits to an open PR)","text":"<p>In addition to running automatic tools when a PR is opened, the GitHub app can also respond to new code that is pushed to an open PR.</p> <p>The configuration toggle <code>handle_push_trigger</code> can be used to enable this feature. The configuration parameter <code>push_commands</code> defines the list of tools that will be run automatically when new code is pushed to the PR.</p> <pre><code>[github_app]\nhandle_push_trigger = true\npush_commands = [\n    \"/describe\",\n    \"/review\",\n]\n</code></pre> <p>This means that when new code is pushed to the PR, PR-Agent will run the <code>describe</code> and <code>review</code> tools, with the specified parameters.</p>"},{"location":"usage-guide/automations_and_usage/#github-action","title":"GitHub Action","text":"<p><code>GitHub Action</code> is a different way to trigger PR-Agent tools, and uses a different configuration mechanism than <code>GitHub App</code>. You can configure settings for <code>GitHub Action</code> by adding environment variables under the env section in <code>.github/workflows/pr_agent.yml</code> file. Specifically, start by setting the following environment variables:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }} # Make sure to add your OpenAI key to your repo secrets\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Make sure to add your GitHub token to your repo secrets\n        github_action_config.auto_review: \"true\" # enable\\disable auto review\n        github_action_config.auto_describe: \"true\" # enable\\disable auto describe\n        github_action_config.auto_improve: \"true\" # enable\\disable auto improve\n        github_action_config.pr_actions: '[\"opened\", \"reopened\", \"ready_for_review\", \"review_requested\"]'\n</code></pre> <p><code>github_action_config.auto_review</code>, <code>github_action_config.auto_describe</code> and <code>github_action_config.auto_improve</code> are used to enable/disable automatic tools that run when a new PR is opened. If not set, the default configuration is for all three tools to run automatically when a new PR is opened.</p> <p><code>github_action_config.pr_actions</code> is used to configure which <code>pull_requests</code> events will trigger the enabled auto flags If not set, the default configuration is <code>[\"opened\", \"reopened\", \"ready_for_review\", \"review_requested\"]</code></p> <p><code>github_action_config.enable_output</code> are used to enable/disable github actions output parameter (default is <code>true</code>). Review result is output as JSON to <code>steps.{step-id}.outputs.review</code> property. The JSON structure is equivalent to the yaml data structure defined in pr_reviewer_prompts.toml.</p> <p>Note that you can give additional config parameters by adding environment variables to <code>.github/workflows/pr_agent.yml</code>, or by using a <code>.pr_agent.toml</code> configuration file in the root of your repo</p> <p>For example, you can set an environment variable: <code>pr_description.publish_labels=false</code>, or add a <code>.pr_agent.toml</code> file with the following content:</p> <pre><code>[pr_description]\npublish_labels = false\n</code></pre> <p>to prevent PR-Agent from publishing labels when running the <code>describe</code> tool.</p>"},{"location":"usage-guide/automations_and_usage/#enable-using-commands-in-pr","title":"Enable using commands in PR","text":"<p>You can configure your GitHub Actions workflow to trigger on <code>issue_comment</code> events (<code>created</code> and <code>edited</code>).</p> <p>Example GitHub Actions workflow configuration:</p> <pre><code>on:\n  issue_comment:\n    types: [created, edited]\n</code></pre> <p>When this is configured, PR-Agent can be invoked by commenting on the PR.</p>"},{"location":"usage-guide/automations_and_usage/#quick-reference-model-configuration-in-github-actions","title":"Quick Reference: Model Configuration in GitHub Actions","text":"<p>For detailed step-by-step examples of configuring different models (Gemini, Claude, Azure OpenAI, etc.) in GitHub Actions, see the Configuration Examples section in the installation guide.</p> <p>Common Model Configuration Patterns:</p> <ul> <li>OpenAI: Set <code>config.model: \"gpt-4o\"</code> and <code>OPENAI_KEY</code></li> <li>Gemini: Set <code>config.model: \"gemini/gemini-1.5-flash\"</code> and <code>GOOGLE_AI_STUDIO.GEMINI_API_KEY</code> (no <code>OPENAI_KEY</code> needed)</li> <li>Claude: Set <code>config.model: \"anthropic/claude-3-opus-20240229\"</code> and <code>ANTHROPIC.KEY</code> (no <code>OPENAI_KEY</code> needed)</li> <li>Azure OpenAI: Set <code>OPENAI.API_TYPE: \"azure\"</code>, <code>OPENAI.API_BASE</code>, and <code>OPENAI.DEPLOYMENT_ID</code></li> <li>Local Models: Set <code>config.model: \"ollama/model-name\"</code> and <code>OLLAMA.API_BASE</code></li> </ul> <p>Environment Variable Format: - Use dots (<code>.</code>) to separate sections and keys: <code>config.model</code>, <code>pr_reviewer.extra_instructions</code> - Boolean values as strings: <code>\"true\"</code> or <code>\"false\"</code> - Arrays as JSON strings: <code>'[\"item1\", \"item2\"]'</code></p> <p>For complete model configuration details, see Changing a model in PR-Agent.</p>"},{"location":"usage-guide/automations_and_usage/#gitlab-webhook","title":"GitLab Webhook","text":"<p>After setting up a GitLab webhook, to control which commands will run automatically when a new MR is opened, you can set the <code>pr_commands</code> parameter in the configuration file, similar to the GitHub App:</p> <pre><code>[gitlab]\npr_commands = [\n    \"/describe\",\n    \"/review\",\n    \"/improve\",\n]\n</code></pre> <p>the GitLab webhook can also respond to new code that is pushed to an open MR. The configuration toggle <code>handle_push_trigger</code> can be used to enable this feature. The configuration parameter <code>push_commands</code> defines the list of tools that will be run automatically when new code is pushed to the MR.</p> <pre><code>[gitlab]\nhandle_push_trigger = true\npush_commands = [\n    \"/describe\",\n    \"/review\",\n]\n</code></pre> <p>Note that to use the 'handle_push_trigger' feature, you need to give the gitlab webhook also the \"Push events\" scope.</p>"},{"location":"usage-guide/automations_and_usage/#bitbucket-app","title":"BitBucket App","text":"<p>Similar to GitHub app, when running PR-Agent from BitBucket App, the default configuration file will be initially loaded.</p> <p>By uploading a local <code>.pr_agent.toml</code> file to the root of the repo's default branch, you can edit and customize any configuration parameter. Note that you need to upload <code>.pr_agent.toml</code> prior to creating a PR, in order for the configuration to take effect.</p> <p>For example, if your local <code>.pr_agent.toml</code> file contains:</p> <pre><code>[pr_reviewer]\nextra_instructions = \"Answer in japanese\"\n</code></pre> <p>Each time you invoke a <code>/review</code> tool, it will use the extra instructions you set in the local configuration file.</p> <p>Note that among other limitations, BitBucket provides relatively low rate-limits for applications (up to 1000 requests per hour), and does not provide an API to track the actual rate-limit usage. If you experience a lack of responses from PR-Agent, you might want to set: <code>bitbucket_app.avoid_full_files=true</code> in your configuration file. This will prevent PR-Agent from acquiring the full file content, and will only use the diff content. This will reduce the number of requests made to BitBucket, at the cost of small decrease in accuracy, as dynamic context will not be applicable.</p>"},{"location":"usage-guide/automations_and_usage/#bitbucket-self-hosted-app-automatic-tools","title":"BitBucket Self-Hosted App automatic tools","text":"<p>To control which commands will run automatically when a new PR is opened, you can set the <code>pr_commands</code> parameter in the configuration file: Specifically, set the following values:</p> <pre><code>[bitbucket_app]\npr_commands = [\n    \"/review\",\n    \"/improve --pr_code_suggestions.commitable_code_suggestions=true --pr_code_suggestions.suggestions_score_threshold=7\",\n]\n</code></pre> <p>Note that we set specifically for bitbucket, we recommend using: <code>--pr_code_suggestions.suggestions_score_threshold=7</code> and that is the default value we set for bitbucket. Since this platform only supports inline code suggestions, we want to limit the number of suggestions, and only present a limited number.</p> <p>To enable BitBucket app to respond to each push to the PR, set (for example):</p> <pre><code>[bitbucket_app]\nhandle_push_trigger = true\npush_commands = [\n    \"/describe\",\n    \"/review\",\n]\n</code></pre>"},{"location":"usage-guide/automations_and_usage/#azure-devops-provider","title":"Azure DevOps provider","text":"<p>To use Azure DevOps provider use the following settings in configuration.toml:</p> <pre><code>[config]\ngit_provider=\"azure\"\n</code></pre> <p>Azure DevOps provider supports PAT token or DefaultAzureCredential authentication. PAT is faster to create, but has build in expiration date, and will use the user identity for API calls. Using DefaultAzureCredential you can use managed identity or Service principle, which are more secure and will create separate ADO user identity (via AAD) to the agent.</p> <p>If PAT was chosen, you can assign the value in .secrets.toml. If DefaultAzureCredential was chosen, you can assigned the additional env vars like AZURE_CLIENT_SECRET directly, or use managed identity/az cli (for local development) without any additional configuration. in any case, 'org' value must be assigned in .secrets.toml:</p> <pre><code>[azure_devops]\norg = \"https://dev.azure.com/YOUR_ORGANIZATION/\"\n# pat = \"YOUR_PAT_TOKEN\" needed only if using PAT for authentication\n</code></pre>"},{"location":"usage-guide/automations_and_usage/#azure-devops-webhook","title":"Azure DevOps Webhook","text":"<p>To control which commands will run automatically when a new PR is opened, you can set the <code>pr_commands</code> parameter in the configuration file, similar to the GitHub App:</p> <pre><code>[azure_devops_server]\npr_commands = [\n    \"/describe\",\n    \"/review\",\n    \"/improve\",\n]\n</code></pre>"},{"location":"usage-guide/automations_and_usage/#gitea-webhook","title":"Gitea Webhook","text":"<p>After setting up a Gitea webhook, to control which commands will run automatically when a new MR is opened, you can set the <code>pr_commands</code> parameter in the configuration file, similar to the GitHub App:</p> <pre><code>[gitea]\npr_commands = [\n    \"/describe\",\n    \"/review\",\n    \"/improve\",\n]\n</code></pre>"},{"location":"usage-guide/changing_a_model/","title":"Changing a Model","text":""},{"location":"usage-guide/changing_a_model/#changing-a-model-in-pr-agent","title":"Changing a model in PR-Agent","text":"<p>See here for a list of supported models in PR-Agent. The default model of PR-Agent is <code>GPT-5</code> from OpenAI. To use a different model than the default, you need to edit in the configuration file the fields:</p> <pre><code>[config]\nmodel = \"...\"\nfallback_models = [\"...\"]\n</code></pre> <p>For models and environments not from OpenAI, you might need to provide additional keys and other parameters. You can give parameters via a configuration file, or from environment variables.</p> <p>Model-specific environment variables</p> <p>See litellm documentation for the environment variables needed per model, as they may vary and change over time. Our documentation per-model may not always be up-to-date with the latest changes. Failing to set the needed keys of a specific model will usually result in litellm not identifying the model type, and failing to utilize it.</p>"},{"location":"usage-guide/changing_a_model/#openai-like-api","title":"OpenAI like API","text":"<p>To use an OpenAI like API, set the following in your <code>.secrets.toml</code> file:</p> <pre><code>[openai]\napi_base = \"https://api.openai.com/v1\"\napi_key = \"sk-...\"\n</code></pre> <p>or use the environment variables (make sure to use double underscores <code>__</code>):</p> <pre><code>OPENAI__API_BASE=https://api.openai.com/v1\nOPENAI__KEY=sk-...\n</code></pre>"},{"location":"usage-guide/changing_a_model/#openai-flex-processing","title":"OpenAI Flex Processing","text":"<p>To reduce costs for non-urgent/background tasks, enable Flex Processing:</p> <pre><code>[litellm]\nextra_body='{\"processing_mode\": \"flex\"}'\n</code></pre> <p>See OpenAI Flex Processing docs for details.</p>"},{"location":"usage-guide/changing_a_model/#azure","title":"Azure","text":"<p>To use Azure, set in your <code>.secrets.toml</code> (working from CLI), or in the GitHub <code>Settings &gt; Secrets and variables</code> (working from GitHub App or GitHub Action):</p> <pre><code>[openai]\nkey = \"\" # your azure api key\napi_type = \"azure\"\napi_version = '2023-05-15'  # Check Azure documentation for the current API version\napi_base = \"\"  # The base URL for your Azure OpenAI resource. e.g. \"https://&lt;your resource name&gt;.openai.azure.com\"\ndeployment_id = \"\"  # The deployment name you chose when you deployed the engine\n</code></pre> <p>and set in your configuration file:</p> <pre><code>[config]\nmodel=\"\" # the OpenAI model you've deployed on Azure (e.g. gpt-4o)\nfallback_models=[\"...\"]\n</code></pre> <p>To use Azure AD (Entra id) based authentication set in your <code>.secrets.toml</code> (working from CLI), or in the GitHub <code>Settings &gt; Secrets and variables</code> (working from GitHub App or GitHub Action):</p> <pre><code>[azure_ad]\nclient_id = \"\"  # Your Azure AD application client ID\nclient_secret = \"\"  # Your Azure AD application client secret\ntenant_id = \"\"  # Your Azure AD tenant ID\napi_base = \"\"  # Your Azure OpenAI service base URL (e.g., https://openai.xyz.com/)\n</code></pre> <p>Passing custom headers to the underlying LLM Model API can be done by setting extra_headers parameter to litellm.</p> <pre><code>[litellm]\nextra_headers='{\"projectId\": \"&lt;authorized projectId &gt;\", ...}') #The value of this setting should be a JSON string representing the desired headers, a ValueError is thrown otherwise.\n</code></pre> <p>This enables users to pass authorization tokens or API keys, when routing requests through an API management gateway.</p>"},{"location":"usage-guide/changing_a_model/#ollama","title":"Ollama","text":"<p>You can run models locally through either VLLM or Ollama</p> <p>E.g. to use a new model locally via Ollama, set in <code>.secrets.toml</code> or in a configuration file:</p> <pre><code>[config]\nmodel = \"ollama/qwen2.5-coder:32b\"\nfallback_models=[\"ollama/qwen2.5-coder:32b\"]\ncustom_model_max_tokens=128000 # set the maximal input tokens for the model\nduplicate_examples=true # will duplicate the examples in the prompt, to help the model to generate structured output\n\n[ollama]\napi_base = \"http://localhost:11434\" # or whatever port you're running Ollama on\n</code></pre> <p>By default, Ollama uses a context window size of 2048 tokens. In most cases this is not enough to cover pr-agent prompt and pull-request diff. Context window size can be overridden with the <code>OLLAMA_CONTEXT_LENGTH</code> environment variable. For example, to set the default context length to 8K, use: <code>OLLAMA_CONTEXT_LENGTH=8192 ollama serve</code>. More information you can find on the official ollama faq.</p> <p>Please note that the <code>custom_model_max_tokens</code> setting should be configured in accordance with the <code>OLLAMA_CONTEXT_LENGTH</code>. Failure to do so may result in unexpected model output.</p> <p>Local models vs commercial models</p> <p>PR-Agent is compatible with almost any AI model, but analyzing complex code repositories and pull requests requires a model specifically optimized for code analysis.</p> <p>Commercial models such as GPT-5, Claude Sonnet, and Gemini have demonstrated robust capabilities in generating structured output for code analysis tasks with large input. In contrast, most open-source models currently available (as of January 2025) face challenges with these complex tasks.</p> <p>Based on our testing, local open-source models are suitable for experimentation and learning purposes (mainly for the <code>ask</code> command), but they are not suitable for production-level code analysis tasks.</p> <p>Hence, for production workflows and real-world usage, we recommend using commercial models.</p>"},{"location":"usage-guide/changing_a_model/#hugging-face","title":"Hugging Face","text":"<p>To use a new model with Hugging Face Inference Endpoints, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"huggingface/meta-llama/Llama-2-7b-chat-hf\"\nfallback_models=[\"huggingface/meta-llama/Llama-2-7b-chat-hf\"]\ncustom_model_max_tokens=... # set the maximal input tokens for the model\n\n[huggingface] # in .secrets.toml\nkey = ... # your Hugging Face api key\napi_base = ... # the base url for your Hugging Face inference endpoint\n</code></pre> <p>(you can obtain a Llama2 key from here)</p>"},{"location":"usage-guide/changing_a_model/#replicate","title":"Replicate","text":"<p>To use Llama2 model with Replicate, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"replicate/llama-2-70b-chat:2c1608e18606fad2812020dc541930f2d0495ce32eee50074220b87300bc16e1\"\nfallback_models=[\"replicate/llama-2-70b-chat:2c1608e18606fad2812020dc541930f2d0495ce32eee50074220b87300bc16e1\"]\n[replicate] # in .secrets.toml\nkey = ...\n</code></pre> <p>(you can obtain a Llama2 key from here)</p> <p>Also, review the AiHandler file for instructions on how to set keys for other models.</p>"},{"location":"usage-guide/changing_a_model/#groq","title":"Groq","text":"<p>To use Llama3 model with Groq, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"llama3-70b-8192\"\nfallback_models = [\"groq/llama3-70b-8192\"]\n[groq] # in .secrets.toml\nkey = ... # your Groq api key\n</code></pre> <p>(you can obtain a Groq key from here)</p>"},{"location":"usage-guide/changing_a_model/#xai","title":"xAI","text":"<p>To use xAI's models with PR-Agent, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"xai/grok-2-latest\"\nfallback_models = [\"xai/grok-2-latest\"] # or any other model as fallback\n\n[xai] # in .secrets.toml\nkey = \"...\" # your xAI API key\n</code></pre> <p>You can obtain an xAI API key from xAI's console by creating an account and navigating to the developer settings page.</p>"},{"location":"usage-guide/changing_a_model/#vertex-ai","title":"Vertex AI","text":"<p>To use Google's Vertex AI platform and its associated models (chat-bison/codechat-bison) set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"vertex_ai/codechat-bison\"\nfallback_models=\"vertex_ai/codechat-bison\"\n\n[vertexai] # in .secrets.toml\nvertex_project = \"my-google-cloud-project\"\nvertex_location = \"\"\n</code></pre> <p>Your application default credentials will be used for authentication so there is no need to set explicit credentials in most environments.</p> <p>If you do want to set explicit credentials, then you can use the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable set to a path to a json credentials file.</p>"},{"location":"usage-guide/changing_a_model/#google-ai-studio","title":"Google AI Studio","text":"<p>To use Google AI Studio models, set the relevant models in the configuration section of the configuration file:</p> <pre><code>[config] # in configuration.toml\nmodel=\"gemini/gemini-1.5-flash\"\nfallback_models=[\"gemini/gemini-1.5-flash\"]\n\n[google_ai_studio] # in .secrets.toml\ngemini_api_key = \"...\"\n</code></pre> <p>If you don't want to set the API key in the .secrets.toml file, you can set the <code>GOOGLE_AI_STUDIO.GEMINI_API_KEY</code> environment variable.</p>"},{"location":"usage-guide/changing_a_model/#anthropic","title":"Anthropic","text":"<p>To use Anthropic models, set the relevant models in the configuration section of the configuration file:</p> <pre><code>[config]\nmodel=\"anthropic/claude-3-opus-20240229\"\nfallback_models=[\"anthropic/claude-3-opus-20240229\"]\n</code></pre> <p>And also set the api key in the .secrets.toml file:</p> <pre><code>[anthropic]\nKEY = \"...\"\n</code></pre> <p>See litellm documentation for more information about the environment variables required for Anthropic.</p>"},{"location":"usage-guide/changing_a_model/#amazon-bedrock","title":"Amazon Bedrock","text":"<p>To use Amazon Bedrock and its foundational models, add the below configuration:</p> <pre><code>[config] # in configuration.toml\nmodel=\"bedrock/anthropic.claude-3-5-sonnet-20240620-v1:0\"\nfallback_models=[\"bedrock/anthropic.claude-3-5-sonnet-20240620-v1:0\"]\n\n[aws]\nAWS_ACCESS_KEY_ID=\"...\"\nAWS_SECRET_ACCESS_KEY=\"...\"\nAWS_REGION_NAME=\"...\"\n</code></pre> <p>You can also use the new Meta Llama 4 models available on Amazon Bedrock:</p> <pre><code>[config] # in configuration.toml\nmodel=\"bedrock/us.meta.llama4-scout-17b-instruct-v1:0\"\nfallback_models=[\"bedrock/us.meta.llama4-maverick-17b-instruct-v1:0\"]\n</code></pre>"},{"location":"usage-guide/changing_a_model/#custom-inference-profiles","title":"Custom Inference Profiles","text":"<p>To use a custom inference profile with Amazon Bedrock (for cost allocation tags and other configuration settings), add the <code>model_id</code> parameter to your configuration:</p> <pre><code>[config] # in configuration.toml\nmodel=\"bedrock/anthropic.claude-3-5-sonnet-20240620-v1:0\"\nfallback_models=[\"bedrock/anthropic.claude-3-5-sonnet-20240620-v1:0\"]\n\n[aws]\nAWS_ACCESS_KEY_ID=\"...\"\nAWS_SECRET_ACCESS_KEY=\"...\"\nAWS_REGION_NAME=\"...\"\n\n[litellm]\nmodel_id = \"your-custom-inference-profile-id\"\n</code></pre> <p>The <code>model_id</code> parameter will be passed to all Bedrock completion calls, allowing you to use custom inference profiles for better cost allocation and reporting.</p> <p>See litellm documentation for more information about the environment variables required for Amazon Bedrock.</p>"},{"location":"usage-guide/changing_a_model/#deepseek","title":"DeepSeek","text":"<p>To use deepseek-chat model with DeepSeek, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"deepseek/deepseek-chat\"\nfallback_models=[\"deepseek/deepseek-chat\"]\n</code></pre> <p>and fill up your key</p> <pre><code>[deepseek] # in .secrets.toml\nkey = ...\n</code></pre> <p>(you can obtain a deepseek-chat key from here)</p>"},{"location":"usage-guide/changing_a_model/#deepinfra","title":"DeepInfra","text":"<p>To use DeepSeek model with DeepInfra, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"deepinfra/deepseek-ai/DeepSeek-R1-Distill-Llama-70B\"\nfallback_models = [\"deepinfra/deepseek-ai/DeepSeek-R1-Distill-Qwen-32B\"]\n[deepinfra] # in .secrets.toml\nkey = ... # your DeepInfra api key\n</code></pre> <p>(you can obtain a DeepInfra key from here)</p>"},{"location":"usage-guide/changing_a_model/#mistral","title":"Mistral","text":"<p>To use models like Mistral or Codestral with Mistral, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"mistral/mistral-small-latest\"\nfallback_models = [\"mistral/mistral-medium-latest\"]\n[mistral] # in .secrets.toml\nkey = \"...\" # your Mistral api key\n</code></pre> <p>(you can obtain a Mistral key from here)</p>"},{"location":"usage-guide/changing_a_model/#codestral","title":"Codestral","text":"<p>To use Codestral model with Codestral, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"codestral/codestral-latest\"\nfallback_models = [\"codestral/codestral-2405\"]\n[codestral] # in .secrets.toml\nkey = \"...\" # your Codestral api key\n</code></pre> <p>(you can obtain a Codestral key from here)</p>"},{"location":"usage-guide/changing_a_model/#openrouter","title":"Openrouter","text":"<p>To use model from Openrouter, for example, set:</p> <pre><code>[config] # in configuration.toml \nmodel=\"openrouter/anthropic/claude-3.7-sonnet\"\nfallback_models=[\"openrouter/deepseek/deepseek-chat\"]\ncustom_model_max_tokens=20000\n\n[openrouter]  # in .secrets.toml or passed an environment variable openrouter__key\nkey = \"...\" # your openrouter api key\n</code></pre> <p>(you can obtain an Openrouter API key from here)</p>"},{"location":"usage-guide/changing_a_model/#custom-models","title":"Custom models","text":"<p>If the relevant model doesn't appear here, you can still use it as a custom model:</p> <ol> <li>Set the model name in the configuration file:</li> </ol> <pre><code>[config]\nmodel=\"custom_model_name\"\nfallback_models=[\"custom_model_name\"]\n</code></pre> <ol> <li>Set the maximal tokens for the model:</li> </ol> <pre><code>[config]\ncustom_model_max_tokens= ...\n</code></pre> <ol> <li> <p>Go to litellm documentation, find the model you want to use, and set the relevant environment variables.</p> </li> <li> <p>Most reasoning models do not support chat-style inputs (<code>system</code> and <code>user</code> messages) or temperature settings. To bypass chat templates and temperature controls, set <code>config.custom_reasoning_model = true</code> in your configuration file.</p> </li> </ol>"},{"location":"usage-guide/changing_a_model/#dedicated-parameters","title":"Dedicated parameters","text":""},{"location":"usage-guide/changing_a_model/#openai-models","title":"OpenAI models","text":"<pre><code>[config]\nreasoning_effort = \"medium\" # \"low\", \"medium\", \"high\"\n</code></pre> <p>With the OpenAI models that support reasoning effort (eg: o4-mini), you can specify its reasoning effort via <code>config</code> section. The default value is <code>medium</code>. You can change it to <code>high</code> or <code>low</code> based on your usage.</p>"},{"location":"usage-guide/changing_a_model/#anthropic-models","title":"Anthropic models","text":"<pre><code>[config]\nenable_claude_extended_thinking = false # Set to true to enable extended thinking feature\nextended_thinking_budget_tokens = 2048\nextended_thinking_max_output_tokens = 4096\n</code></pre>"},{"location":"usage-guide/configuration_options/","title":"Configuration File","text":"<p>The different tools and sub-tools used by PR-Agent are adjustable via a Git configuration file. There are three main ways to set persistent configurations:</p> <ol> <li>Wiki configuration page</li> <li>Local configuration file</li> <li>Global configuration file</li> </ol> <p>In terms of precedence, wiki configurations will override local configurations, and local configurations will override global configurations.</p> <p>For a list of all possible configurations, see the configuration options page. In addition to general configuration options, each tool has its own configurations. For example, the <code>review</code> tool will use parameters from the pr_reviewer section in the configuration file.</p> <p>Tip1: Edit only what you need</p> <p>Your configuration file should be minimal, and edit only the relevant values. Don't copy the entire configuration options, since it can lead to legacy problems when something changes.</p> <p>Tip2: Show relevant configurations</p> <p>If you set <code>config.output_relevant_configurations</code> to True, each tool will also output in a collapsible section its relevant configurations. This can be useful for debugging, or getting to know the configurations better.</p>"},{"location":"usage-guide/configuration_options/#wiki-configuration-file","title":"Wiki configuration file","text":"<p><code>Platforms supported: GitHub, GitLab, Bitbucket</code></p> <p>With PR-Agent, you can set configurations by creating a page called <code>.pr_agent.toml</code> in the wiki of the repo. The advantage of this method is that it allows to set configurations without needing to commit new content to the repo - just edit the wiki page and save.</p> <p></p> <p>Click here to see a short instructional video. We recommend surrounding the configuration content with triple-quotes (or ```toml), to allow better presentation when displayed in the wiki as markdown. An example content:</p> <pre><code>[pr_description]\ngenerate_ai_title=true\n</code></pre> <p>PR-Agent will know to remove the surrounding quotes when reading the configuration content.</p>"},{"location":"usage-guide/configuration_options/#local-configuration-file","title":"Local configuration file","text":"<p><code>Platforms supported: GitHub, GitLab, Bitbucket, Azure DevOps</code></p> <p>By uploading a local <code>.pr_agent.toml</code> file to the root of the repo's default branch, you can edit and customize any configuration parameter. Note that you need to upload or update <code>.pr_agent.toml</code> before using the PR Agent tools (either at PR creation or via manual trigger) for the configuration to take effect.</p> <p>For example, if you set in <code>.pr_agent.toml</code>:</p> <pre><code>[pr_reviewer]\nextra_instructions=\"\"\"\\\n- instruction a\n- instruction b\n...\n\"\"\"\n</code></pre> <p>Then you can give a list of extra instructions to the <code>review</code> tool.</p>"},{"location":"usage-guide/configuration_options/#global-configuration-file","title":"Global configuration file","text":"<p><code>Platforms supported: GitHub, GitLab (cloud), Bitbucket (cloud)</code></p> <p>If you create a repo called <code>pr-agent-settings</code> in your organization, its configuration file <code>.pr_agent.toml</code> will be used as a global configuration file for any other repo that belongs to the same organization. Parameters from a local <code>.pr_agent.toml</code> file, in a specific repo, will override the global configuration parameters.</p> <p>For example, in the GitHub organization <code>qodo-ai</code>:</p> <ul> <li> <p>The file <code>https://github.com/qodo-ai/pr-agent-settings/.pr_agent.toml</code>  serves as a global configuration file for all the repos in the GitHub organization <code>qodo-ai</code>.</p> </li> <li> <p>The repo <code>https://github.com/qodo-ai/pr-agent</code> inherits the global configuration file from <code>pr-agent-settings</code>.</p> </li> </ul>"},{"location":"usage-guide/configuration_options/#projectgroup-level-configuration-file","title":"Project/Group level configuration file","text":"<p><code>Platforms supported: GitLab, Bitbucket Data Center</code></p> <p>Create a repository named <code>pr-agent-settings</code> within a specific project (Bitbucket) or a group/subgroup (Gitlab).  The configuration file in this repository will apply to all repositories directly under the same project/group/subgroup.</p> <p>Note</p> <p>For Gitlab, in case of a repository nested in several sub groups, the lookup for a pr-agent-settings repo will be only on one level above such repository.</p>"},{"location":"usage-guide/configuration_options/#organization-level-configuration-file","title":"Organization level configuration file","text":"<p><code>Relevant platforms: Bitbucket Data Center</code></p> <p>Create a dedicated project to hold a global configuration file that affects all repositories across all projects in your organization.</p> <p>Setting up organization-level global configuration:</p> <ol> <li>Create a new project with both the name and key: PR_AGENT_SETTINGS.</li> <li>Inside the PR_AGENT_SETTINGS project, create a repository named pr-agent-settings.</li> <li>In this repository, add a <code>.pr_agent.toml</code> configuration file\u2014structured similarly to the global configuration file described above.</li> <li>Optionally, you can add organizational-level global best practices.</li> </ol> <p>Repositories across your entire Bitbucket organization will inherit the configuration from this file.</p> <p>Note</p> <p>If both organization-level and project-level global settings are defined, the project-level settings will take precedence over the organization-level configuration. Additionally, parameters from a repository\u2019s local .pr_agent.toml file will always override both global settings.</p>"},{"location":"usage-guide/introduction/","title":"Introduction","text":"<p>After installation, there are three basic ways to invoke PR-Agent:</p> <ol> <li>Locally running a CLI command</li> <li>Online usage - by commenting on a PR</li> <li>Enabling PR-Agent tools to run automatically when a new PR is opened</li> </ol> <p>Specifically, CLI commands can be issued by invoking a pre-built docker image, or by invoking a locally cloned repo.</p> <p>For online usage, you will need to setup either a GitHub App or a GitHub Action (GitHub), a GitLab webhook (GitLab), or a BitBucket App (BitBucket). These platforms also enable to run PR-Agent specific tools automatically when a new PR is opened, or on each push to a branch.</p>"},{"location":"usage-guide/mail_notifications/","title":"Managing Mail Notifications","text":"<p>Unfortunately, it is not possible in GitHub to disable mail notifications from a specific user. If you are subscribed to notifications for a repo with PR-Agent, we recommend turning off notifications for PR comments, to avoid lengthy emails:</p> <p></p> <p>As an alternative, you can filter in your mail provider the notifications specifically from the PR-Agent bot, see how.</p> <p></p> <p>Another option to reduce the mail overload, yet still receive notifications on PR-Agent tools, is to disable the help collapsible section in PR-Agent bot comments. This can done by setting <code>enable_help_text=false</code> for the relevant tool in the configuration file. For example, to disable the help text for the <code>pr_reviewer</code> tool, set:</p> <pre><code>[pr_reviewer]\nenable_help_text = false\n</code></pre>"}]}