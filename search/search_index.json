{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#overview","title":"Overview","text":"<p>PR-Agent is an open-source tool to help efficiently review and handle pull requests. Qodo Merge is a hosted version of PR-Agent, designed for companies and teams that require additional features and capabilities</p> <ul> <li> <p>See the Installation Guide for instructions on installing and running the tool on different git platforms.</p> </li> <li> <p>See the Usage Guide for instructions on running commands via different interfaces, including CLI, online usage, or by automatically triggering them when a new PR is opened.</p> </li> <li> <p>See the Tools Guide for a detailed description of the different tools.</p> </li> <li> <p>See the video tutorials [1, 2] for practical demonstrations on how to use the tools.</p> </li> </ul>"},{"location":"#docs-smart-search","title":"Docs Smart Search","text":"<p>To search the documentation site using natural language:</p> <p>1) Comment <code>/help \"your question\"</code> in either:</p> <ul> <li>A pull request where Qodo Merge is installed</li> <li>A PR Chat</li> </ul> <p>2) The bot will respond with an answer that includes relevant documentation links.</p>"},{"location":"#features","title":"Features","text":"<p>PR-Agent and Qodo Merge offer comprehensive pull request functionalities integrated with various git providers:</p> GitHub GitLab Bitbucket Azure DevOps Gitea TOOLS Describe \u2705 \u2705 \u2705 \u2705 \u2705 Review \u2705 \u2705 \u2705 \u2705 \u2705 Improve \u2705 \u2705 \u2705 \u2705 \u2705 Ask \u2705 \u2705 \u2705 \u2705 \u2b91 Ask on code lines \u2705 \u2705 Help Docs \u2705 \u2705 \u2705 Update CHANGELOG \u2705 \u2705 \u2705 \u2705 Add Documentation \ud83d\udc8e \u2705 \u2705 Analyze \ud83d\udc8e \u2705 \u2705 Auto-Approve \ud83d\udc8e \u2705 \u2705 \u2705 CI Feedback \ud83d\udc8e \u2705 Compliance \ud83d\udc8e \u2705 \u2705 \u2705 Custom Prompt \ud83d\udc8e \u2705 \u2705 \u2705 Generate Custom Labels \ud83d\udc8e \u2705 \u2705 Generate Tests \ud83d\udc8e \u2705 \u2705 Implement \ud83d\udc8e \u2705 \u2705 \u2705 PR Chat \ud83d\udc8e \u2705 PR to Ticket \ud83d\udc8e \u2705 \u2705 \u2705 Scan Repo Discussions \ud83d\udc8e \u2705 Similar Code \ud83d\udc8e \u2705 Suggestion Tracking \ud83d\udc8e \u2705 \u2705 Utilizing Best Practices \ud83d\udc8e \u2705 \u2705 \u2705 USAGE CLI \u2705 \u2705 \u2705 \u2705 \u2705 App / webhook \u2705 \u2705 \u2705 \u2705 \u2705 Tagging bot \u2705 Actions \u2705 \u2705 \u2705 \u2705 CORE Adaptive and token-aware file patch fitting \u2705 \u2705 \u2705 \u2705 Auto Best Practices \ud83d\udc8e \u2705 Chat on code suggestions \u2705 \u2705 Code Validation \ud83d\udc8e \u2705 \u2705 \u2705 \u2705 Dynamic context \u2705 \u2705 \u2705 \u2705 Fetching ticket context \u2705 \u2705 \u2705 Global and wiki configurations \ud83d\udc8e \u2705 \u2705 \u2705 Impact Evaluation \ud83d\udc8e \u2705 \u2705 Incremental Update \ud83d\udc8e \u2705 Interactivity \u2705 \u2705 Local and global metadata \u2705 \u2705 \u2705 \u2705 Multiple models support \u2705 \u2705 \u2705 \u2705 PR compression \u2705 \u2705 \u2705 \u2705 PR interactive actions \ud83d\udc8e \u2705 \u2705 RAG context enrichment \u2705 \u2705 Self reflection \u2705 \u2705 \u2705 \u2705 Static code analysis \ud83d\udc8e \u2705 \u2705 <p>\ud83d\udc8e means Qodo Merge only</p> <p>All along the documentation, \ud83d\udc8e marks a feature available only in Qodo Merge, and not in the open-source version.</p>"},{"location":"#example-results","title":"Example Results","text":""},{"location":"#describe","title":"/describe","text":""},{"location":"#review","title":"/review","text":""},{"location":"#improve","title":"/improve","text":""},{"location":"#generate_labels","title":"/generate_labels","text":""},{"location":"#how-it-works","title":"How it Works","text":"<p>The following diagram illustrates Qodo Merge tools and their flow:</p> <p></p> <p>Check out the PR Compression strategy page for more details on how we convert a code diff to a manageable LLM prompt</p>"},{"location":"summary/","title":"Table of contents","text":""},{"location":"summary/#table-of-contents","title":"Table of contents","text":"<ul> <li>Overview</li> <li>\ud83d\udc8e Qodo Merge</li> <li>Data Privacy</li> </ul>"},{"location":"summary/#installation","title":"Installation","text":"<ul> <li>Installation</li> <li>PR-Agent</li> <li>\ud83d\udc8e Qodo Merge</li> </ul>"},{"location":"summary/#usage-guide","title":"Usage Guide","text":"<ul> <li>Usage Guide</li> <li>Introduction</li> <li>Enabling a Wiki</li> <li>Configuration File</li> <li>Usage and Automation</li> <li>Managing Mail Notifications</li> <li>Changing a Model</li> <li>Additional Configurations</li> <li>Frequently Asked Questions</li> <li>Qodo Merge Models</li> </ul>"},{"location":"summary/#tools","title":"Tools","text":"<ul> <li>Tools</li> <li>Describe</li> <li>Review</li> <li>Improve</li> <li>Ask</li> <li>Help</li> <li>Help Docs</li> <li>Update Changelog</li> <li>\ud83d\udc8e Add Documentation</li> <li>\ud83d\udc8e Analyze</li> <li>\ud83d\udc8e CI Feedback</li> <li>\ud83d\udc8e Compliance</li> <li>\ud83d\udc8e Custom Prompt</li> <li>\ud83d\udc8e Generate Labels</li> <li>\ud83d\udc8e Generate Tests</li> <li>\ud83d\udc8e Implement</li> <li>\ud83d\udc8e Improve Components</li> <li>\ud83d\udc8e PR to Ticket</li> <li>\ud83d\udc8e Scan Repo Discussions</li> <li>\ud83d\udc8e Similar Code</li> </ul>"},{"location":"summary/#core-abilities","title":"Core Abilities","text":"<ul> <li>Core Abilities</li> <li>Auto approval</li> <li>Auto best practices</li> <li>Chat on code suggestions</li> <li>Chrome extension</li> <li>Code validation</li> <li>Dynamic context</li> <li>Fetching ticket context</li> <li>High-level Suggestions</li> <li>Impact evaluation</li> <li>Incremental Update</li> <li>Interactivity</li> <li>Local and global metadata</li> <li>RAG context enrichment</li> <li>Self-reflection</li> <li>Static code analysis</li> </ul>"},{"location":"summary/#qodo-merge-cli","title":"Qodo Merge CLI","text":"<ul> <li>Overview</li> <li>Installation</li> <li>Usage</li> </ul>"},{"location":"summary/#pr-benchmark","title":"PR Benchmark","text":"<ul> <li>PR Benchmark</li> </ul>"},{"location":"summary/#recent-updates","title":"Recent Updates","text":"<ul> <li>Recent Updates</li> </ul>"},{"location":"summary/#ai-docs-search","title":"AI Docs Search","text":"<ul> <li>AI Docs Search</li> </ul>"},{"location":"ai_search/","title":"AI Docs Search","text":"AI Docs Search <p>         Search through our documentation using AI-powered natural language queries.     </p> Search"},{"location":"chrome-extension/","title":"Chrome extension","text":"<p><code>Platforms supported: GitHub Cloud</code></p> <p>Qodo Merge Chrome extension is a collection of tools that integrates seamlessly with your GitHub environment, aiming to enhance your Git usage experience, and providing AI-powered capabilities to your PRs.</p> <p>With a single-click installation you will gain access to a context-aware chat on your pull requests code, a toolbar extension with multiple AI feedbacks, Qodo Merge filters, and additional abilities.</p> <p>The extension is powered by top code models like GPT-5. All the extension's features are free to use on public repositories.</p> <p>For private repositories, you will need to install Qodo Merge in addition to the extension. For a demonstration of how to install Qodo Merge and use it with the Chrome extension, please refer to the tutorial video at the provided link.</p> <p></p>"},{"location":"chrome-extension/#supported-browsers","title":"Supported browsers","text":"<p>The extension is supported on all Chromium-based browsers, including Google Chrome, Arc, Opera, Brave, and Microsoft Edge.</p>"},{"location":"chrome-extension/#features","title":"Features","text":""},{"location":"chrome-extension/#pr-chat","title":"PR chat","text":"<p>The PR-Chat feature allows to freely chat with your PR code, within your GitHub environment. It will seamlessly use the PR as context to your chat session, and provide AI-powered feedback.</p> <p>To enable private chat, simply install the Qodo Merge Chrome extension. After installation, each PR's file-changed tab will include a chat box, where you may ask questions about your code. This chat session is private, and won't be visible to other users.</p> <p>All open-source repositories are supported. For private repositories, you will also need to install Qodo Merge. After installation, make sure to open at least one new PR to fully register your organization. Once done, you can chat with both new and existing PRs across all installed repositories.</p>"},{"location":"chrome-extension/#context-aware-pr-chat","title":"Context-aware PR chat","text":"<p>Qodo Merge constructs a comprehensive context for each pull request, incorporating the PR description, commit messages, and code changes with extended dynamic context. This contextual information, along with additional PR-related data, forms the foundation for an AI-powered chat session. The agent then leverages this rich context to provide intelligent, tailored responses to user inquiries about the pull request.</p> <p> </p>"},{"location":"chrome-extension/#toolbar-extension","title":"Toolbar extension","text":"<p>With Qodo Merge Chrome extension, it's easier than ever to interactively configure and experiment with the different tools and configuration options.</p> <p>For private repositories, after you found the setup that works for you, you can also easily export it as a persistent configuration file, and use it for automatic commands.</p> <p></p> <p></p>"},{"location":"chrome-extension/#qodo-merge-filters","title":"Qodo Merge filters","text":"<p>Qodo Merge filters is a sidepanel option. that allows you to filter different message in the conversation tab.</p> <p>For example, you can choose to present only message from Qodo Merge, or filter those messages, focusing only on user's comments.</p> <p></p> <p></p>"},{"location":"chrome-extension/#enhanced-code-suggestions","title":"Enhanced code suggestions","text":"<p>Qodo Merge Chrome extension adds the following capabilities to code suggestions tool's comments:</p> <ul> <li>Auto-expand the table when you are viewing a code block, to avoid clipping.</li> <li>Adding a \"quote-and-reply\" button, that enables to address and comment on a specific suggestion (for example, asking the author to fix the issue)</li> </ul> <p></p> <p></p>"},{"location":"chrome-extension/#data-privacy","title":"Data Privacy","text":"<p>We take your code's security and privacy seriously:</p> <ul> <li>The Chrome extension will not send your code to any external servers.</li> <li>For private repositories, we will first validate the user's identity and permissions. After authentication, we generate responses using the existing Qodo Merge integration.</li> </ul>"},{"location":"chrome-extension/#options-and-configurations","title":"Options and Configurations","text":""},{"location":"chrome-extension/#accessing-the-options-page","title":"Accessing the Options Page","text":"<p>To access the options page for the Qodo Merge Chrome extension:</p> <ol> <li>Find the extension icon in your Chrome toolbar (usually in the top-right corner of your browser)</li> <li>Right-click on the extension icon</li> <li>Select \"Options\" from the context menu that appears</li> </ol> <p>Alternatively, you can access the options page directly using this URL:</p> <p>chrome-extension://ephlnjeghhogofkifjloamocljapahnl/options.html</p> <p></p>"},{"location":"chrome-extension/#configuration-options","title":"Configuration Options","text":""},{"location":"chrome-extension/#api-base-host","title":"API Base Host","text":"<p>For single-tenant customers, you can configure the extension to communicate directly with your company's Qodo Merge server instance.</p> <p>To set this up:</p> <ul> <li>Enter your organization's Qodo Merge API endpoint in the \"API Base Host\" field</li> <li>This endpoint should be provided by your Qodo DevOps Team</li> </ul> <p>Note: The extension does not send your code to the server, but only triggers your previously installed Qodo Merge application.</p>"},{"location":"chrome-extension/#interface-options","title":"Interface Options","text":"<p>You can customize the extension's interface by:</p> <ul> <li>Toggling the \"Show Qodo Merge Toolbar\" option</li> <li>When disabled, the toolbar will not appear in your Github comment bar</li> </ul> <p>Remember to click \"Save Settings\" after making any changes.</p>"},{"location":"chrome-extension/data_privacy/","title":"Data privacy","text":"<p>We take your code's security and privacy seriously:</p> <ul> <li>The Chrome extension will not send your code to any external servers.</li> <li>For private repositories, we will first validate the user's identity and permissions. After authentication, we generate responses using the existing Qodo Merge integration.</li> </ul>"},{"location":"chrome-extension/features/","title":"Features","text":""},{"location":"chrome-extension/features/#pr-chat","title":"PR chat","text":"<p>The PR-Chat feature allows to freely chat with your PR code, within your GitHub environment. It will seamlessly use the PR as context to your chat session, and provide AI-powered feedback.</p> <p>To enable private chat, simply install the Qodo Merge Chrome extension. After installation, each PR's file-changed tab will include a chat box, where you may ask questions about your code. This chat session is private, and won't be visible to other users.</p> <p>All open-source repositories are supported. For private repositories, you will also need to install Qodo Merge. After installation, make sure to open at least one new PR to fully register your organization. Once done, you can chat with both new and existing PRs across all installed repositories.</p>"},{"location":"chrome-extension/features/#context-aware-pr-chat","title":"Context-aware PR chat","text":"<p>Qodo Merge constructs a comprehensive context for each pull request, incorporating the PR description, commit messages, and code changes with extended dynamic context. This contextual information, along with additional PR-related data, forms the foundation for an AI-powered chat session. The agent then leverages this rich context to provide intelligent, tailored responses to user inquiries about the pull request.</p> <p> </p>"},{"location":"chrome-extension/features/#toolbar-extension","title":"Toolbar extension","text":"<p>With Qodo Merge Chrome extension, it's easier than ever to interactively configure and experiment with the different tools and configuration options.</p> <p>For private repositories, after you found the setup that works for you, you can also easily export it as a persistent configuration file, and use it for automatic commands.</p> <p></p> <p></p>"},{"location":"chrome-extension/features/#qodo-merge-filters","title":"Qodo Merge filters","text":"<p>Qodo Merge filters is a sidepanel option. that allows you to filter different message in the conversation tab.</p> <p>For example, you can choose to present only message from Qodo Merge, or filter those messages, focusing only on user's comments.</p> <p></p> <p></p>"},{"location":"chrome-extension/features/#enhanced-code-suggestions","title":"Enhanced code suggestions","text":"<p>Qodo Merge Chrome extension adds the following capabilities to code suggestions tool's comments:</p> <ul> <li>Auto-expand the table when you are viewing a code block, to avoid clipping.</li> <li>Adding a \"quote-and-reply\" button, that enables to address and comment on a specific suggestion (for example, asking the author to fix the issue)</li> </ul> <p></p> <p></p>"},{"location":"chrome-extension/options/","title":"Options","text":""},{"location":"chrome-extension/options/#options-and-configurations","title":"Options and Configurations","text":""},{"location":"chrome-extension/options/#accessing-the-options-page","title":"Accessing the Options Page","text":"<p>To access the options page for the Qodo Merge Chrome extension:</p> <ol> <li>Find the extension icon in your Chrome toolbar (usually in the top-right corner of your browser)</li> <li>Right-click on the extension icon</li> <li>Select \"Options\" from the context menu that appears</li> </ol> <p>Alternatively, you can access the options page directly using this URL:</p> <p>chrome-extension://ephlnjeghhogofkifjloamocljapahnl/options.html</p> <p></p>"},{"location":"chrome-extension/options/#configuration-options","title":"Configuration Options","text":""},{"location":"chrome-extension/options/#api-base-host","title":"API Base Host","text":"<p>For single-tenant customers, you can configure the extension to communicate directly with your company's Qodo Merge server instance.</p> <p>To set this up:</p> <ul> <li>Enter your organization's Qodo Merge API endpoint in the \"API Base Host\" field</li> <li>This endpoint should be provided by your Qodo DevOps Team</li> </ul> <p>Note: The extension does not send your code to the server, but only triggers your previously installed Qodo Merge application.</p>"},{"location":"chrome-extension/options/#interface-options","title":"Interface Options","text":"<p>You can customize the extension's interface by:</p> <ul> <li>Toggling the \"Show Qodo Merge Toolbar\" option</li> <li>When disabled, the toolbar will not appear in your Github comment bar</li> </ul> <p>Remember to click \"Save Settings\" after making any changes.</p>"},{"location":"core-abilities/","title":"Core Abilities","text":""},{"location":"core-abilities/#core-abilities","title":"Core Abilities","text":"<p>Qodo Merge utilizes a variety of core abilities to provide a comprehensive and efficient code review experience. These abilities include:</p> <ul> <li>Auto approval</li> <li>Auto best practices</li> <li>Chat on code suggestions</li> <li>Chrome extension</li> <li>Code validation </li> <li>Dynamic context</li> <li>Fetching ticket context</li> <li>High-level Suggestions</li> <li>Impact evaluation</li> <li>Incremental Update</li> <li>Interactivity</li> <li>Local and global metadata</li> <li>RAG context enrichment</li> <li>Self-reflection</li> <li>Static code analysis</li> </ul>"},{"location":"core-abilities/#blogs","title":"Blogs","text":"<p>Here are some additional technical blogs from Qodo, that delve deeper into the core capabilities and features of Large Language Models (LLMs) when applied to coding tasks. These resources provide more comprehensive insights into leveraging LLMs for software development.</p>"},{"location":"core-abilities/#code-generation-and-llms","title":"Code Generation and LLMs","text":"<ul> <li>Effective AI code suggestions: less is more</li> <li>State-of-the-art Code Generation with AlphaCodium \u2013 From Prompt Engineering to Flow Engineering</li> <li>RAG for a Codebase with 10k Repos</li> </ul>"},{"location":"core-abilities/#development-processes","title":"Development Processes","text":"<ul> <li>Understanding the Challenges and Pain Points of the Pull Request Cycle</li> <li>Introduction to Code Coverage Testing</li> </ul>"},{"location":"core-abilities/#cost-optimization","title":"Cost Optimization","text":"<ul> <li>Reduce Your Costs by 30% When Using GPT for Python Code</li> </ul>"},{"location":"core-abilities/auto_approval/","title":"Auto approval","text":""},{"location":"core-abilities/auto_approval/#auto-approval","title":"Auto-approval \ud83d\udc8e","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p> <p>Under specific conditions, Qodo Merge can auto-approve a PR when a manual comment is invoked, or when the PR meets certain criteria.</p> <p>To ensure safety, the auto-approval feature is disabled by default. To enable auto-approval features, you need to actively set one or both of the following options in a pre-defined configuration file:</p> <pre><code>[config]\nenable_comment_approval = true # For approval via comments\nenable_auto_approval = true   # For criteria-based auto-approval\n</code></pre> <p>Notes</p> <ul> <li>These flags above cannot be set with a command line argument, only in the configuration file, committed to the repository.</li> <li>Enabling auto-approval must be a deliberate decision by the repository owner.</li> </ul>"},{"location":"core-abilities/auto_approval/#approval-by-commenting","title":"Approval by commenting","text":"<p>To enable approval by commenting, set in the configuration file:</p> <pre><code>[config]\nenable_comment_approval = true\n</code></pre> <p>After enabling, by commenting on a PR:</p> <pre><code>/review auto_approve\n</code></pre> <p>Qodo Merge will approve the PR and add a comment with the reason for the approval.</p>"},{"location":"core-abilities/auto_approval/#auto-approval-when-the-pr-meets-certain-criteria","title":"Auto-approval when the PR meets certain criteria","text":"<p>To enable auto-approval based on specific criteria, first, you need to enable the top-level flag:</p> <pre><code>[config]\nenable_auto_approval = true\n</code></pre> <p>There are two possible paths leading to this auto-approval - one via the <code>review</code> tool, and one via the <code>improve</code> tool. Each tool can independently trigger auto-approval.</p>"},{"location":"core-abilities/auto_approval/#auto-approval-via-the-review-tool","title":"Auto-approval via the <code>review</code> tool","text":"<ul> <li> <p>Review effort score criteria</p> <pre><code>[config]\nenable_auto_approval = true\nauto_approve_for_low_review_effort = X # X is a number between 1 and 5\n</code></pre> <p>When the review effort score is lower than or equal to X, the PR will be auto-approved (unless ticket compliance is enabled and fails, see below).</p> </li> <li> <p>Ticket compliance criteria</p> <pre><code>[config]\nenable_auto_approval = true\nensure_ticket_compliance = true # Default is false\n</code></pre> <p>If <code>ensure_ticket_compliance</code> is set to <code>true</code>, auto-approval for the <code>review</code> toll path will be disabled if no ticket is linked to the PR, or if the PR is not fully compliant with a linked ticket. This ensures that PRs are only auto-approved if their associated tickets are properly resolved.</p> <p>You can also prevent auto-approval if the PR exceeds the ticket's scope (see here).</p> </li> </ul>"},{"location":"core-abilities/auto_approval/#auto-approval-via-the-improve-tool","title":"Auto-approval via the <code>improve</code> tool","text":"<p>PRs can be auto-approved when the <code>improve</code> tool doesn't find code suggestions. To enable this feature, set the following in the configuration file:</p> <pre><code>[config]\nenable_auto_approval = true\nauto_approve_for_no_suggestions = true\n</code></pre>"},{"location":"core-abilities/auto_best_practices/","title":"Auto best practices","text":""},{"location":"core-abilities/auto_best_practices/#auto-best-practices","title":"Auto Best Practices \ud83d\udc8e","text":"<p><code>Supported Git Platforms: GitHub</code></p>"},{"location":"core-abilities/auto_best_practices/#overview","title":"Overview","text":"<p>Note - enabling a Wiki is required for this feature.</p>"},{"location":"core-abilities/auto_best_practices/#finding-code-problems-exploration-phase","title":"Finding Code Problems - Exploration Phase","text":"<p>The <code>improve</code> tool identifies potential issues, problems and bugs in Pull Request (PR) code changes. Rather than focusing on minor issues like code style or formatting, the tool intelligently analyzes code to detect meaningful problems.</p> <p>The analysis intentionally takes a flexible, exploratory approach to identify meaningful potential issues, allowing the tool to surface relevant code suggestions without being constrained by predefined categories.</p>"},{"location":"core-abilities/auto_best_practices/#tracking-implemented-suggestions","title":"Tracking Implemented Suggestions","text":"<p>Qodo Merge features a novel tracking system that automatically detects when PR authors implement AI-generated code suggestions. All accepted suggestions are aggregated in a repository-specific wiki page called <code>.pr_agent_accepted_suggestions</code></p>"},{"location":"core-abilities/auto_best_practices/#learning-and-applying-auto-best-practices","title":"Learning and Applying Auto Best Practices","text":"<p>Monthly, Qodo Merge analyzes the collection of accepted suggestions to generate repository-specific best practices, stored in <code>.pr_agent_auto_best_practices</code> wiki file. These best practices reflect recurring patterns in accepted code improvements.</p> <p>The <code>improve</code> tool will incorporate these best practices as an additional analysis layer, checking PR code changes against known patterns of previously accepted improvements. This creates a two-phase analysis:</p> <ol> <li>Open exploration for general code issues</li> <li>Targeted checking against established best practices - exploiting the knowledge gained from past suggestions</li> </ol> <p>By keeping these phases decoupled, the tool remains free to discover new or unseen issues and problems, while also learning from past experiences.</p> <p>When presenting the suggestions generated by the <code>improve</code> tool, Qodo Merge will add a dedicated label for each suggestion generated from the auto best practices - 'Learned best practice':</p> <p></p>"},{"location":"core-abilities/auto_best_practices/#auto-best-practices-vs-custom-best-practices","title":"Auto Best Practices vs Custom Best Practices","text":"<p>Teams and companies can also manually define their own custom best practices in Qodo Merge.</p> <p>When custom best practices exist, Qodo Merge will use both the auto-generated best practices and your custom best practices together. The auto best practices file provides additional insights derived from suggestions your team found valuable enough to implement, while also demonstrating effective patterns for writing AI-friendly best practices.</p> <p>We recommend utilizing both auto and custom best practices to get the most comprehensive code improvement suggestions for your team.</p>"},{"location":"core-abilities/auto_best_practices/#relevant-configurations","title":"Relevant configurations","text":"<pre><code>[auto_best_practices]\n# Disable all auto best practices usage or generation\nenable_auto_best_practices = true  \n\n# Disable usage of auto best practices file in the 'improve' tool\nutilize_auto_best_practices = true \n\n# Extra instructions to the auto best practices generation prompt\nextra_instructions = \"\"            \n\n# Max number of patterns to be detected\nmax_patterns = 5                   \n</code></pre>"},{"location":"core-abilities/chat_on_code_suggestions/","title":"Chat on code suggestions","text":""},{"location":"core-abilities/chat_on_code_suggestions/#chat-on-code-suggestions","title":"Chat on code suggestions \ud83d\udc8e","text":"<p><code>Supported Git Platforms: GitHub, GitLab</code></p>"},{"location":"core-abilities/chat_on_code_suggestions/#overview","title":"Overview","text":"<p>Qodo Merge implements an orchestrator agent that enables interactive code discussions, listening and responding to comments without requiring explicit tool calls. The orchestrator intelligently analyzes your responses to determine if you want to implement a suggestion, ask a question, or request help, then delegates to the appropriate specialized tool.</p> <p>To minimize unnecessary notifications and maintain focused discussions, the orchestrator agent will only respond to comments made directly within the inline code suggestion discussions it has created (<code>/improve</code>) or within discussions initiated by the <code>/implement</code> command.</p>"},{"location":"core-abilities/chat_on_code_suggestions/#getting-started","title":"Getting Started","text":""},{"location":"core-abilities/chat_on_code_suggestions/#setup","title":"Setup","text":"<p>Enable interactive code discussions by adding the following to your configuration file (default is <code>True</code>):</p> <pre><code>[pr_code_suggestions]\nenable_chat_in_code_suggestions = true\n</code></pre>"},{"location":"core-abilities/chat_on_code_suggestions/#activation","title":"Activation","text":""},{"location":"core-abilities/chat_on_code_suggestions/#improve","title":"<code>/improve</code>","text":"<p>To obtain dynamic responses, the following steps are required:</p> <ol> <li>Run the <code>/improve</code> command (mostly automatic)</li> <li>Check the <code>/improve</code> recommendation checkboxes (Apply this suggestion) to have Qodo Merge generate a new inline code suggestion discussion</li> <li>The orchestrator agent will then automatically listen to and reply to comments within the discussion without requiring additional commands</li> </ol>"},{"location":"core-abilities/chat_on_code_suggestions/#implement","title":"<code>/implement</code>","text":"<p>To obtain dynamic responses, the following steps are required:</p> <ol> <li>Select code lines in the PR diff and run the <code>/implement</code> command</li> <li>Wait for Qodo Merge to generate a new inline code suggestion</li> <li>The orchestrator agent will then automatically listen to and reply to comments within the discussion without requiring additional commands</li> </ol>"},{"location":"core-abilities/chat_on_code_suggestions/#explore-the-available-interaction-patterns","title":"Explore the available interaction patterns","text":"<p>Tip: Direct the agent with keywords</p> <p>Use \"implement\" or \"apply\" for code generation. Use \"explain\", \"why\", or \"how\" for information and help.</p> Asking for DetailsImplementing SuggestionsProviding Additional Help <p></p> <p></p> <p></p>"},{"location":"core-abilities/code_validation/","title":"Code validation","text":""},{"location":"core-abilities/code_validation/#code-validation","title":"Code Validation \ud83d\udc8e","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p>"},{"location":"core-abilities/code_validation/#introduction","title":"Introduction","text":"<p>The Git environment usually represents the final stage before code enters production. Hence, Detecting bugs and issues during the review process is critical.</p> <p>The <code>improve</code> tool provides actionable code suggestions for your pull requests, aiming to help detect and fix bugs and problems. By default, suggestions appear as a comment in a table format:</p> <p></p> <p></p>"},{"location":"core-abilities/code_validation/#validation-of-code-suggestions","title":"Validation of Code Suggestions","text":"<p>Each suggestion in the table can be \"applied\" by clicking on the <code>Apply this suggestion</code> checkbox, converting it to a committable Git code change that can be committed directly to the PR. This approach allows to fix issues without returning to your IDE for manual edits \u2014 significantly faster and more convenient.</p> <p>However, committing a suggestion in a Git environment carries more risk than in a local IDE, as you don't have the opportunity to fully run and test the code before committing.</p> <p>To balance convenience with safety, Qodo Merge implements a dual validation system for each generated code suggestion:</p> <p>1) Localization - Qodo Merge confirms that the suggestion's line numbers and surrounding code, as predicted by the model, actually match the repo code. This means that the model correctly identified the context and location of the code to be changed.</p> <p>2) \"Compilation\" - Using static code analysis, Qodo Merge verifies that after applying the suggestion, the modified file will still be valid, meaning tree-sitter syntax processing will not throw an error. This process is relevant for multiple programming languages, see here for the full list of supported languages.</p> <p>When a suggestion fails to meet these validation criteria, it may still provide valuable feedback, but isn't suitable for direct application to the PR. In such cases, Qodo Merge will omit the 'apply' checkbox and instead display:</p> <p><code>[To ensure code accuracy, apply this suggestion manually]</code></p> <p>All suggestions that pass these validations undergo a final stage of self-reflection, where the AI model evaluates, scores, and re-ranks its own suggestions, eliminating any that are irrelevant or incorrect. Read more about this process in the self-reflection page.</p>"},{"location":"core-abilities/code_validation/#conclusion","title":"Conclusion","text":"<p>The validation methods described above enhance the reliability of code suggestions and help PR authors determine which suggestions are safer to apply in the Git environment. Of course, additional factors should be considered, such as suggestion complexity and potential code impact.</p> <p>Human judgment remains essential. After clicking 'apply', Qodo Merge still presents the 'before' and 'after' code snippets for review, allowing you to assess the changes before finalizing the commit.</p> <p></p>"},{"location":"core-abilities/compression_strategy/","title":"Compression strategy","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p>"},{"location":"core-abilities/compression_strategy/#overview","title":"Overview","text":"<p>There are two scenarios:</p> <ol> <li>The PR is small enough to fit in a single prompt (including system and user prompt)</li> <li>The PR is too large to fit in a single prompt (including system and user prompt)</li> </ol> <p>For both scenarios, we first use the following strategy</p>"},{"location":"core-abilities/compression_strategy/#repo-language-prioritization-strategy","title":"Repo language prioritization strategy","text":"<p>We prioritize the languages of the repo based on the following criteria:</p> <ol> <li>Exclude binary files and non code files (e.g. images, pdfs, etc)</li> <li>Given the main languages used in the repo</li> <li>We sort the PR files by the most common languages in the repo (in descending order):</li> <li><code>[[file.py, file2.py],[file3.js, file4.jsx],[readme.md]]</code></li> </ol>"},{"location":"core-abilities/compression_strategy/#small-pr","title":"Small PR","text":"<p>In this case, we can fit the entire PR in a single prompt:</p> <ol> <li>Exclude binary files and non code files (e.g. images, pdfs, etc)</li> <li>We Expand the surrounding context of each patch to 3 lines above and below the patch</li> </ol>"},{"location":"core-abilities/compression_strategy/#large-pr","title":"Large PR","text":""},{"location":"core-abilities/compression_strategy/#motivation","title":"Motivation","text":"<p>Pull Requests can be very long and contain a lot of information with varying degree of relevance to the pr-agent. We want to be able to pack as much information as possible in a single LMM prompt, while keeping the information relevant to the pr-agent.</p>"},{"location":"core-abilities/compression_strategy/#compression-strategy","title":"Compression strategy","text":"<p>We prioritize additions over deletions:</p> <ul> <li>Combine all deleted files into a single list (<code>deleted files</code>)</li> <li>File patches are a list of hunks, remove all hunks of type deletion-only from the hunks in the file patch</li> </ul>"},{"location":"core-abilities/compression_strategy/#adaptive-and-token-aware-file-patch-fitting","title":"Adaptive and token-aware file patch fitting","text":"<p>We use tiktoken to tokenize the patches after the modifications described above, and we use the following strategy to fit the patches into the prompt:</p> <ol> <li>Within each language we sort the files by the number of tokens in the file (in descending order):<ul> <li><code>[[file2.py, file.py],[file4.jsx, file3.js],[readme.md]]</code></li> </ul> </li> <li>Iterate through the patches in the order described above</li> <li>Add the patches to the prompt until the prompt reaches a certain buffer from the max token length</li> <li>If there are still patches left, add the remaining patches as a list called <code>other modified files</code> to the prompt until the prompt reaches the max token length (hard stop), skip the rest of the patches.</li> <li>If we haven't reached the max token length, add the <code>deleted files</code> to the prompt until the prompt reaches the max token length (hard stop), skip the rest of the patches.</li> </ol>"},{"location":"core-abilities/compression_strategy/#example","title":"Example","text":""},{"location":"core-abilities/dynamic_context/","title":"Dynamic context","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p> <p>Qodo Merge uses an asymmetric and dynamic context strategy to improve AI analysis of code changes in pull requests. It provides more context before changes than after, and dynamically adjusts the context based on code structure (e.g., enclosing functions or classes). This approach balances providing sufficient context for accurate analysis, while avoiding needle-in-the-haystack information overload that could degrade AI performance or exceed token limits.</p>"},{"location":"core-abilities/dynamic_context/#introduction","title":"Introduction","text":"<p>Pull request code changes are retrieved in a unified diff format, showing three lines of context before and after each modified section, with additions marked by '+' and deletions by '-'.</p> <pre><code>@@ -12,5 +12,5 @@ def func1():\n code line that already existed in the file...\n code line that already existed in the file...\n code line that already existed in the file....\n-code line that was removed in the PR\n+new code line added in the PR\n code line that already existed in the file...\n code line that already existed in the file...\n code line that already existed in the file...\n\n@@ -26,2 +26,4 @@ def func2():\n...\n</code></pre> <p>This unified diff format can be challenging for AI models to interpret accurately, as it provides limited context for understanding the full scope of code changes. The presentation of code using '+', '-', and ' ' symbols to indicate additions, deletions, and unchanged lines respectively also differs from the standard code formatting typically used to train AI models.</p>"},{"location":"core-abilities/dynamic_context/#challenges-of-expanding-the-context-window","title":"Challenges of expanding the context window","text":"<p>While expanding the context window is technically feasible, it presents a more fundamental trade-off:</p> <p>Pros:</p> <ul> <li>Enhanced context allows the model to better comprehend and localize the code changes, results (potentially) in more precise analysis and suggestions. Without enough context, the model may struggle to understand the code changes and provide relevant feedback.</li> </ul> <p>Cons:</p> <ul> <li> <p>Excessive context may overwhelm the model with extraneous information, creating a \"needle in a haystack\" scenario where focusing on the relevant details (the code that actually changed) becomes challenging. LLM quality is known to degrade when the context gets larger. Pull requests often encompass multiple changes across many files, potentially spanning hundreds of lines of modified code. This complexity presents a genuine risk of overwhelming the model with excessive context.</p> </li> <li> <p>Increased context expands the token count, increasing processing time and cost, and may prevent the model from processing the entire pull request in a single pass.</p> </li> </ul>"},{"location":"core-abilities/dynamic_context/#asymmetric-and-dynamic-context","title":"Asymmetric and dynamic context","text":"<p>To address these challenges, Qodo Merge employs an asymmetric and dynamic context strategy, providing the model with more focused and relevant context information for each code change.</p> <p>Asymmetric:</p> <p>We start by recognizing that the context preceding a code change is typically more crucial for understanding the modification than the context following it. Consequently, Qodo Merge implements an asymmetric context policy, decoupling the context window into two distinct segments: one for the code before the change and another for the code after.</p> <p>By independently adjusting each context window, Qodo Merge can supply the model with a more tailored and pertinent context for individual code changes.</p> <p>Dynamic:</p> <p>We also employ a \"dynamic\" context strategy. We start by recognizing that the optimal context for a code change often corresponds to its enclosing code component (e.g., function, class), rather than a fixed number of lines. Consequently, we dynamically adjust the context window based on the code's structure, ensuring the model receives the most pertinent information for each modification.</p> <p>To prevent overwhelming the model with excessive context, we impose a limit on the number of lines searched when identifying the enclosing component. This balance allows for comprehensive understanding while maintaining efficiency and limiting context token usage.</p>"},{"location":"core-abilities/dynamic_context/#appendix-relevant-configuration-options","title":"Appendix - relevant configuration options","text":"<pre><code>[config]\npatch_extension_skip_types =[\".md\",\".txt\"]  # Skip files with these extensions when trying to extend the context\nallow_dynamic_context=true                  # Allow dynamic context extension\nmax_extra_lines_before_dynamic_context = 8  # will try to include up to X extra lines before the hunk in the patch, until we reach an enclosing function or class\npatch_extra_lines_before = 3                # Number of extra lines (+3 default ones) to include before each hunk in the patch\npatch_extra_lines_after = 1                 # Number of extra lines (+3 default ones) to include after each hunk in the patch\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/","title":"Fetching ticket context","text":""},{"location":"core-abilities/fetching_ticket_context/#fetching-ticket-context-for-prs","title":"Fetching Ticket Context for PRs","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p>"},{"location":"core-abilities/fetching_ticket_context/#overview","title":"Overview","text":"<p>Qodo Merge streamlines code review workflows by seamlessly connecting with multiple ticket management systems. This integration enriches the review process by automatically surfacing relevant ticket information and context alongside code changes.</p> <p>Ticket systems supported:</p> <ul> <li>GitHub/Gitlab Issues</li> <li>Jira (\ud83d\udc8e)</li> <li>Linear (\ud83d\udc8e)</li> <li>Monday (\ud83d\udc8e)</li> </ul> <p>Ticket data fetched:</p> <ol> <li>Ticket Title</li> <li>Ticket Description</li> <li>Custom Fields (Acceptance criteria)</li> <li>Subtasks (linked tasks)</li> <li>Labels</li> <li>Attached Images/Screenshots</li> </ol>"},{"location":"core-abilities/fetching_ticket_context/#affected-tools","title":"Affected Tools","text":"<p>Ticket Recognition Requirements:</p> <ul> <li>The PR description should contain a link to the ticket or if the branch name starts with the ticket id / number.</li> <li>For Jira tickets, you should follow the instructions in Jira Integration in order to authenticate with Jira.</li> </ul>"},{"location":"core-abilities/fetching_ticket_context/#describe-tool","title":"Describe tool","text":"<p>Qodo Merge will recognize the ticket and use the ticket content (title, description, labels) to provide additional context for the code changes. By understanding the reasoning and intent behind modifications, the LLM can offer more insightful and relevant code analysis.</p>"},{"location":"core-abilities/fetching_ticket_context/#review-tool","title":"Review tool","text":"<p>Similarly to the <code>describe</code> tool, the <code>review</code> tool will use the ticket content to provide additional context for the code changes.</p> <p>In addition, this feature will evaluate how well a Pull Request (PR) adheres to its original purpose/intent as defined by the associated ticket or issue mentioned in the PR description. Each ticket will be assigned a label (Compliance/Alignment level), Indicates the degree to which the PR fulfills its original purpose:</p> <ul> <li>Fully Compliant</li> <li>Partially Compliant</li> <li>Not Compliant</li> <li>PR Code Verified</li> </ul> <p></p> <p>A <code>PR Code Verified</code> label indicates the PR code meets ticket requirements, but requires additional manual testing beyond the code scope. For example - validating UI display across different environments (Mac, Windows, mobile, etc.).</p>"},{"location":"core-abilities/fetching_ticket_context/#configuration-options","title":"Configuration options","text":"<ul> <li> <p>By default, the tool will automatically validate if the PR complies with the referenced ticket. If you want to disable this feedback, add the following line to your configuration file:</p> <pre><code>[pr_reviewer]\nrequire_ticket_analysis_review=false\n</code></pre> </li> <li> <p>If you set: </p><pre><code>[pr_reviewer]\ncheck_pr_additional_content=true\n</code></pre> (default: <code>false</code>)<p></p> <p>the <code>review</code> tool will also validate that the PR code doesn't contain any additional content that is not related to the ticket. If it does, the PR will be labeled at best as <code>PR Code Verified</code>, and the <code>review</code> tool will provide a comment with the additional unrelated content found in the PR code.</p> </li> </ul>"},{"location":"core-abilities/fetching_ticket_context/#githubgitlab-issues-integration","title":"GitHub/Gitlab Issues Integration","text":"<p>Qodo Merge will automatically recognize GitHub/Gitlab issues mentioned in the PR description and fetch the issue content. Examples of valid GitHub/Gitlab issue references:</p> <ul> <li><code>https://github.com/&lt;ORG_NAME&gt;/&lt;REPO_NAME&gt;/issues/&lt;ISSUE_NUMBER&gt;</code> or <code>https://gitlab.com/&lt;ORG_NAME&gt;/&lt;REPO_NAME&gt;/-/issues/&lt;ISSUE_NUMBER&gt;</code></li> <li><code>#&lt;ISSUE_NUMBER&gt;</code></li> <li><code>&lt;ORG_NAME&gt;/&lt;REPO_NAME&gt;#&lt;ISSUE_NUMBER&gt;</code></li> </ul> <p>Branch names can also be used to link issues, for example: - <code>123-fix-bug</code> (where <code>123</code> is the issue number)</p> <p>Since Qodo Merge is integrated with GitHub, it doesn't require any additional configuration to fetch GitHub issues.</p>"},{"location":"core-abilities/fetching_ticket_context/#jira-integration","title":"Jira Integration \ud83d\udc8e","text":"<p>We support both Jira Cloud and Jira Server/Data Center.</p>"},{"location":"core-abilities/fetching_ticket_context/#jira-cloud","title":"Jira Cloud","text":"<p>There are two ways to authenticate with Jira Cloud:</p> <p>1) Jira App Authentication</p> <p>The recommended way to authenticate with Jira Cloud is to install the Qodo Merge app in your Jira Cloud instance. This will allow Qodo Merge to access Jira data on your behalf.</p> <p>Installation steps:</p> <ol> <li> <p>Go to the Qodo Merge integrations page</p> </li> <li> <p>Click on the Connect Jira Cloud button to connect the Jira Cloud app</p> </li> <li> <p>Click the <code>accept</code> button. </p> </li> <li> <p>After installing the app, you will be redirected to the Qodo Merge registration page. and you will see a success message. </p> </li> <li> <p>Now Qodo Merge will be able to fetch Jira ticket context for your PRs.</p> </li> </ol> <p>2) Email/Token Authentication</p> <p>You can create an API token from your Atlassian account:</p> <ol> <li> <p>Log in to https://id.atlassian.com/manage-profile/security/api-tokens.</p> </li> <li> <p>Click Create API token.</p> </li> <li> <p>From the dialog that appears, enter a name for your new token and click Create.</p> </li> <li> <p>Click Copy to clipboard.</p> </li> </ol> <p></p> <ol> <li>In your configuration file add the following lines:</li> </ol> <pre><code>[jira]\njira_api_token = \"YOUR_API_TOKEN\"\njira_api_email = \"YOUR_EMAIL\"\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/#jira-data-centerserver","title":"Jira Data Center/Server","text":""},{"location":"core-abilities/fetching_ticket_context/#using-basic-authentication-for-jira-data-centerserver","title":"Using Basic Authentication for Jira Data Center/Server","text":"<p>You can use your Jira username and password to authenticate with Jira Data Center/Server.</p> <p>In your Configuration file/Environment variables/Secrets file, add the following lines:</p> <pre><code>jira_api_email = \"your_username\"\njira_api_token = \"your_password\"\n</code></pre> <p>(Note that indeed the 'jira_api_email' field is used for the username, and the 'jira_api_token' field is used for the user password.)</p>"},{"location":"core-abilities/fetching_ticket_context/#validating-basic-authentication-via-python-script","title":"Validating Basic authentication via Python script","text":"<p>If you are facing issues retrieving tickets in Qodo Merge with Basic auth, you can validate the flow using a Python script. This following steps will help you check if the basic auth is working correctly, and if you can access the Jira ticket details:</p> <ol> <li> <p>run <code>pip install jira==3.8.0</code></p> </li> <li> <p>run the following Python script (after replacing the placeholders with your actual values):</p> </li> </ol> Script to validate basic auth <pre><code>from jira import JIRA\n\n\nif __name__ == \"__main__\":\n    try:\n        # Jira server URL\n        server = \"https://...\"\n        # Basic auth\n        username = \"...\"\n        password = \"...\"\n        # Jira ticket code (e.g. \"PROJ-123\")\n        ticket_id = \"...\"\n\n        print(\"Initializing JiraServerTicketProvider with JIRA server\")\n        # Initialize JIRA client\n        jira = JIRA(\n            server=server,\n            basic_auth=(username, password),\n            timeout=30\n        )\n        if jira:\n            print(f\"JIRA client initialized successfully\")\n        else:\n            print(\"Error initializing JIRA client\")\n\n        # Fetch ticket details\n        ticket = jira.issue(ticket_id)\n        print(f\"Ticket title: {ticket.fields.summary}\")\n\n    except Exception as e:\n        print(f\"Error fetching JIRA ticket details: {e}\")\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/#using-a-personal-access-token-pat-for-jira-data-centerserver","title":"Using a Personal Access Token (PAT) for Jira Data Center/Server","text":"<ol> <li>Create a Personal Access Token (PAT) in your Jira account</li> <li>In your Configuration file/Environment variables/Secrets file, add the following lines:</li> </ol> <pre><code>[jira]\njira_base_url = \"YOUR_JIRA_BASE_URL\" # e.g. https://jira.example.com\njira_api_token = \"YOUR_API_TOKEN\"\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/#validating-pat-token-via-python-script","title":"Validating PAT token via Python script","text":"<p>If you are facing issues retrieving tickets in Qodo Merge with PAT token, you can validate the flow using a Python script. This following steps will help you check if the token is working correctly, and if you can access the Jira ticket details:</p> <ol> <li> <p>run <code>pip install jira==3.8.0</code></p> </li> <li> <p>run the following Python script (after replacing the placeholders with your actual values):</p> </li> </ol> Script to validate PAT token <pre><code>from jira import JIRA\n\n\nif __name__ == \"__main__\":\n    try:\n        # Jira server URL\n        server = \"https://...\"\n        # Jira PAT token\n        token_auth = \"...\"\n        # Jira ticket code (e.g. \"PROJ-123\")\n        ticket_id = \"...\"\n\n        print(\"Initializing JiraServerTicketProvider with JIRA server\")\n        # Initialize JIRA client\n        jira = JIRA(\n            server=server,\n            token_auth=token_auth,\n            timeout=30\n        )\n        if jira:\n            print(f\"JIRA client initialized successfully\")\n        else:\n            print(\"Error initializing JIRA client\")\n\n        # Fetch ticket details\n        ticket = jira.issue(ticket_id)\n        print(f\"Ticket title: {ticket.fields.summary}\")\n\n    except Exception as e:\n        print(f\"Error fetching JIRA ticket details: {e}\")\n</code></pre>"},{"location":"core-abilities/fetching_ticket_context/#multi-jira-server-configuration","title":"Multi-JIRA Server Configuration \ud83d\udc8e","text":"<p>Qodo Merge supports connecting to multiple JIRA servers using different authentication methods.</p> Email/Token (Basic Auth)PAT AuthJira Cloud App <p>Configure multiple servers using Email/Token authentication:</p> <ul> <li><code>jira_servers</code>: List of JIRA server URLs</li> <li><code>jira_api_token</code>: List of API tokens (for Cloud) or passwords (for Data Center)</li> <li><code>jira_api_email</code>: List of emails (for Cloud) or usernames (for Data Center)</li> <li><code>jira_base_url</code>: Default server for ticket IDs like <code>PROJ-123</code>, Each repository can configure (local config file) its own <code>jira_base_url</code> to choose which server to use by default.</li> </ul> <p>Example Configuration: </p><pre><code>[jira]\n# Server URLs\njira_servers = [\"https://company.atlassian.net\", \"https://datacenter.jira.com\"]\n\n# API tokens/passwords\njira_api_token = [\"cloud_api_token_here\", \"datacenter_password\"]\n\n# Emails/usernames (both required)\njira_api_email = [\"user@company.com\", \"datacenter_username\"]\n\n# Default server for ticket IDs\njira_base_url = \"https://company.atlassian.net\"\n</code></pre><p></p> <p>Configure multiple servers using Personal Access Token authentication:</p> <ul> <li><code>jira_servers</code>: List of JIRA server URLs</li> <li><code>jira_api_token</code>: List of PAT tokens</li> <li><code>jira_api_email</code>: Not needed (can be omitted or left empty)</li> <li><code>jira_base_url</code>: Default server for ticket IDs like <code>PROJ-123</code>, Each repository can configure (local config file) its own <code>jira_base_url</code> to choose which server to use by default.</li> </ul> <p>Example Configuration: </p><pre><code>[jira]\n# Server URLs\njira_servers = [\"https://server1.jira.com\", \"https://server2.jira.com\"]\n\n# PAT tokens only\njira_api_token = [\"pat_token_1\", \"pat_token_2\"]\n\n# Default server for ticket IDs\njira_base_url = \"https://server1.jira.com\"\n</code></pre><p></p> <p>Mixed Authentication (Email/Token + PAT): </p><pre><code>[jira]\njira_servers = [\"https://company.atlassian.net\", \"https://server.jira.com\"]\njira_api_token = [\"cloud_api_token\", \"server_pat_token\"]\njira_api_email = [\"user@company.com\", \"\"]  # Empty for PAT\n</code></pre><p></p> <p>For Jira Cloud instances using App Authentication:</p> <ol> <li>Install the Qodo Merge app on each JIRA Cloud instance you want to connect to</li> <li>Set the default server for ticket ID resolution:</li> </ol> <pre><code>[jira]\njira_base_url = \"https://primary-team.atlassian.net\"\n</code></pre> <p>Full URLs (e.g., <code>https://other-team.atlassian.net/browse/TASK-456</code>) will automatically use the correct connected instance.</p>"},{"location":"core-abilities/fetching_ticket_context/#how-to-link-a-pr-to-a-jira-ticket","title":"How to link a PR to a Jira ticket","text":"<p>To integrate with Jira, you can link your PR to a ticket using either of these methods:</p> <p>Method 1: Description Reference:</p> <p>Include a ticket reference in your PR description, using either the complete URL format <code>https://&lt;JIRA_ORG&gt;.atlassian.net/browse/ISSUE-123</code> or the shortened ticket ID <code>ISSUE-123</code> (without prefix or suffix for the shortened ID).</p> <p>Method 2: Branch Name Detection:</p> <p>Name your branch with the ticket ID as a prefix (e.g., <code>ISSUE-123-feature-description</code> or <code>ISSUE-123/feature-description</code>).</p> <p>Jira Base URL</p> <p>For shortened ticket IDs or branch detection (method 2 for JIRA cloud), you must configure the Jira base URL in your configuration file under the [jira] section:</p> <p></p><pre><code>[jira]\njira_base_url = \"https://&lt;JIRA_ORG&gt;.atlassian.net\"\n</code></pre> Where <code>&lt;JIRA_ORG&gt;</code> is your Jira organization identifier (e.g., <code>mycompany</code> for <code>https://mycompany.atlassian.net</code>).<p></p>"},{"location":"core-abilities/fetching_ticket_context/#linear-integration","title":"Linear Integration \ud83d\udc8e","text":""},{"location":"core-abilities/fetching_ticket_context/#linear-app-authentication","title":"Linear App Authentication","text":"<p>The recommended way to authenticate with Linear is to connect the Linear app through the Qodo Merge portal.</p> <p>Installation steps:</p> <ol> <li> <p>Go to the Qodo Merge integrations page</p> </li> <li> <p>Navigate to the Integrations tab</p> </li> <li> <p>Click on the Linear button to connect the Linear app</p> </li> <li> <p>Follow the authentication flow to authorize Qodo Merge to access your Linear workspace</p> </li> <li> <p>Once connected, Qodo Merge will be able to fetch Linear ticket context for your PRs</p> </li> </ol>"},{"location":"core-abilities/fetching_ticket_context/#how-to-link-a-pr-to-a-linear-ticket","title":"How to link a PR to a Linear ticket","text":"<p>Qodo Merge will automatically detect Linear tickets using either of these methods:</p> <p>Method 1: Description Reference:</p> <p>Include a ticket reference in your PR description using either: - The complete Linear ticket URL: <code>https://linear.app/[ORG_ID]/issue/[TICKET_ID]</code> - The shortened ticket ID: <code>[TICKET_ID]</code> (e.g., <code>ABC-123</code>) - requires linear_base_url configuration (see below).</p> <p>Method 2: Branch Name Detection:</p> <p>Name your branch with the ticket ID as a prefix (e.g., <code>ABC-123-feature-description</code> or <code>feature/ABC-123/feature-description</code>).</p> <p>Linear Base URL</p> <p>For shortened ticket IDs or branch detection (method 2), you must configure the Linear base URL in your configuration file under the [linear] section:</p> <pre><code>[linear]\nlinear_base_url = \"https://linear.app/[ORG_ID]\"\n</code></pre> <p>Replace <code>[ORG_ID]</code> with your Linear organization identifier.</p>"},{"location":"core-abilities/fetching_ticket_context/#monday-integration","title":"Monday Integration \ud83d\udc8e","text":""},{"location":"core-abilities/fetching_ticket_context/#monday-app-authentication","title":"Monday App Authentication","text":"<p>The recommended way to authenticate with Monday is to connect the Monday app through the Qodo Merge portal.</p> <p>Installation steps:</p> <ol> <li>Go to the Qodo Merge integrations page</li> <li>Navigate to the Integrations tab</li> <li>Click on the Monday button to connect the Monday app</li> <li>Follow the authentication flow to authorize Qodo Merge to access your Monday workspace</li> <li>Once connected, Qodo Merge will be able to fetch Monday ticket context for your PRs</li> </ol>"},{"location":"core-abilities/fetching_ticket_context/#monday-ticket-context","title":"Monday Ticket Context","text":"<p><code>Ticket Context and Ticket Compliance are supported for Monday items, but not yet available in the \"PR to Ticket\" feature.</code></p> <p>When Qodo Merge processes your PRs, it extracts the following information from Monday items:</p> <ul> <li>Item ID and Name: The unique identifier and title of the Monday item</li> <li>Item URL: Direct link to the Monday item in your workspace</li> <li>Ticket Description: All long text type columns and their values from the item</li> <li>Status and Labels: Current status values and color-coded labels for quick context</li> <li>Sub-items: Names, IDs, and descriptions of all related sub-items with hierarchical structure</li> </ul>"},{"location":"core-abilities/fetching_ticket_context/#how-monday-items-are-detected","title":"How Monday Items are Detected","text":"<p>Qodo Merge automatically detects Monday items from:</p> <ul> <li>PR Descriptions: Full Monday URLs like https://workspace.monday.com/boards/123/pulses/456</li> <li>Branch Names: Item IDs in branch names (6-12 digit patterns) - requires <code>monday_base_url</code> configuration</li> </ul>"},{"location":"core-abilities/fetching_ticket_context/#configuration-setup-optional","title":"Configuration Setup (Optional)","text":"<p>If you want to extract Monday item references from branch names or use standalone item IDs, you need to set the <code>monday_base_url</code> in your configuration file:</p> <p>To support Monday ticket referencing from branch names, item IDs (6-12 digits) should be part of the branch names and you need to configure <code>monday_base_url</code>: </p><pre><code>[monday]\nmonday_base_url = \"https://your_monday_workspace.monday.com\"\n</code></pre><p></p> <p>Examples of supported branch name patterns:</p> <ul> <li><code>feature/123456789</code> \u2192 extracts item ID 123456789</li> <li><code>bugfix/456789012-login-fix</code> \u2192 extracts item ID 456789012</li> <li><code>123456789</code> \u2192 extracts item ID 123456789</li> <li><code>456789012-login-fix</code> \u2192 extracts item ID 456789012</li> </ul>"},{"location":"core-abilities/high_level_suggestions/","title":"High-level Suggestions","text":""},{"location":"core-abilities/high_level_suggestions/#high-level-code-suggestions","title":"High-level Code Suggestions \ud83d\udc8e","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket Cloud, Bitbucket Server</code></p>"},{"location":"core-abilities/high_level_suggestions/#overview","title":"Overview","text":"<p>High-level code suggestions, generated by the <code>improve</code> tool, offer big-picture code suggestions for your pull request. They focus on broader improvements rather than local fixes, and provide before-and-after code snippets to illustrate the recommended changes and guide implementation.</p>"},{"location":"core-abilities/high_level_suggestions/#how-it-works","title":"How it works","text":"Example of a high-level suggestion"},{"location":"core-abilities/high_level_suggestions/#benefits-for-developers","title":"Benefits for Developers","text":"<ul> <li>Help spot systematic issues in the pull request</li> <li>Give the author another review angle, while giving them the freedom on how to address the suggestion.</li> </ul>"},{"location":"core-abilities/impact_evaluation/","title":"Impact evaluation","text":""},{"location":"core-abilities/impact_evaluation/#impact-evaluation","title":"Impact Evaluation \ud83d\udc8e","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p> <p>Demonstrating the return on investment (ROI) of AI-powered initiatives is crucial for modern organizations. To address this need, Qodo Merge has developed an AI impact measurement tools and metrics, providing advanced analytics to help businesses quantify the tangible benefits of AI adoption in their PR review process.</p>"},{"location":"core-abilities/impact_evaluation/#auto-impact-validator-real-time-tracking-of-implemented-qodo-merge-suggestions","title":"Auto Impact Validator - Real-Time Tracking of Implemented Qodo Merge Suggestions","text":""},{"location":"core-abilities/impact_evaluation/#how-it-works","title":"How It Works","text":"<p>When a user pushes a new commit to the pull request, Qodo Merge automatically compares the updated code against the previous suggestions, marking them as implemented if the changes address these recommendations, whether directly or indirectly:</p> <ol> <li>Direct Implementation: The user directly addresses the suggestion as-is in the PR, either by clicking on the \"apply code suggestion\" checkbox or by making the changes manually.</li> <li>Indirect Implementation: Qodo Merge recognizes when a suggestion's intent is fulfilled, even if the exact code changes differ from the original recommendation. It marks these suggestions as implemented, acknowledging that users may achieve the same goal through alternative solutions.</li> </ol>"},{"location":"core-abilities/impact_evaluation/#real-time-visual-feedback","title":"Real-Time Visual Feedback","text":"<p>Upon confirming that a suggestion was implemented, Qodo Merge automatically adds a \u2705 (check mark) to the relevant suggestion, enabling transparent tracking of Qodo Merge's impact analysis. Qodo Merge will also add, inside the relevant suggestions, an explanation of how the new code was impacted by each suggestion.</p> <p></p>"},{"location":"core-abilities/impact_evaluation/#dashboard-metrics","title":"Dashboard Metrics","text":"<p>The dashboard provides macro-level insights into the overall impact of Qodo Merge on the pull-request process with key productivity metrics.</p> <p>By offering clear, data-driven evidence of Qodo Merge's impact, it empowers leadership teams to make informed decisions about the tool's effectiveness and ROI.</p> <p>Here are key metrics that the dashboard tracks:</p>"},{"location":"core-abilities/impact_evaluation/#qodo-merge-impacts-per-1k-lines","title":"Qodo Merge Impacts per 1K Lines","text":"<p>Explanation: for every 1K lines of code (additions/edits), Qodo Merge had on average ~X suggestions implemented.</p> <p>Why This Metric Matters:</p> <ol> <li>Standardized and Comparable Measurement: By measuring impacts per 1K lines of code additions, you create a standardized metric that can be compared across different projects, teams, customers, and time periods. This standardization is crucial for meaningful analysis, benchmarking, and identifying where Qodo Merge is most effective.</li> <li>Accounts for PR Variability and Incentivizes Quality: This metric addresses the fact that \"Not all PRs are created equal.\" By normalizing against lines of code rather than PR count, you account for the variability in PR sizes and focus on the quality and impact of suggestions rather than just the number of PRs affected.</li> <li>Quantifies Value and ROI: The metric directly correlates with the value Qodo Merge is providing, showing how frequently it offers improvements relative to the amount of new code being written. This provides a clear, quantifiable way to demonstrate Qodo Merge's return on investment to stakeholders.</li> </ol>"},{"location":"core-abilities/impact_evaluation/#suggestion-effectiveness-across-categories","title":"Suggestion Effectiveness Across Categories","text":"<p>Explanation: This chart illustrates the distribution of implemented suggestions across different categories, enabling teams to better understand Qodo Merge's impact on various aspects of code quality and development practices.</p>"},{"location":"core-abilities/impact_evaluation/#suggestion-score-distribution","title":"Suggestion Score Distribution","text":"<p>Explanation: The distribution of the suggestion score for the implemented suggestions, ensuring that higher-scored suggestions truly represent more significant improvements.</p>"},{"location":"core-abilities/incremental_update/","title":"Incremental Update","text":""},{"location":"core-abilities/incremental_update/#incremental-update","title":"Incremental Update \ud83d\udc8e","text":"<p><code>Supported Git Platforms: GitHub, GitLab (Both cloud &amp; server. For server: Version 17 and above)</code></p>"},{"location":"core-abilities/incremental_update/#overview","title":"Overview","text":"<p>The Incremental Update feature helps users focus on feedback for their newest changes, making large PRs more manageable.</p>"},{"location":"core-abilities/incremental_update/#how-it-works","title":"How it works","text":"Update Option on Subsequent CommitsGeneration of Incremental Update <p>Whenever new commits are pushed following a recent code suggestions report for this PR, an Update button appears (as seen above).</p> <p>Once the user clicks on the button:</p> <ul> <li>The <code>improve</code> tool identifies the new changes (the \"delta\")</li> <li>Provides suggestions on these recent changes</li> <li>Combines these suggestions with the overall PR feedback, prioritizing delta-related comments</li> <li>Marks delta-related comments with a textual indication followed by an asterisk (*) with a link to this page, so they can easily be identified</li> </ul>"},{"location":"core-abilities/incremental_update/#benefits-for-developers","title":"Benefits for Developers","text":"<ul> <li>Focus on what matters: See feedback on newest code first</li> <li>Clearer organization: Comments on recent changes are clearly marked</li> <li>Better workflow: Address feedback more systematically, starting with recent changes</li> </ul>"},{"location":"core-abilities/interactivity/","title":"Interactivity","text":""},{"location":"core-abilities/interactivity/#interactivity","title":"Interactivity \ud83d\udc8e","text":"<p><code>Supported Git Platforms: GitHub, GitLab</code></p>"},{"location":"core-abilities/interactivity/#overview","title":"Overview","text":"<p>Qodo Merge transforms static code reviews into interactive experiences by enabling direct actions from pull request (PR) comments. Developers can immediately trigger actions and apply changes with simple checkbox clicks.</p> <p>This focused workflow maintains context while dramatically reducing the time between PR creation and final merge. The approach eliminates manual steps, provides clear visual indicators, and creates immediate feedback loops all within the same interface.</p>"},{"location":"core-abilities/interactivity/#key-interactive-features","title":"Key Interactive Features","text":""},{"location":"core-abilities/interactivity/#1-interactive-improve-tool","title":"1. Interactive <code>/improve</code> Tool","text":"<p>The <code>/improve</code> command delivers a comprehensive interactive experience:</p> <ul> <li> <p>Apply this suggestion: Clicking this checkbox instantly converts a suggestion into a committable code change. When committed to the PR, changes made to code that was flagged for improvement will be marked with a check mark, allowing developers to easily track and review implemented recommendations.</p> </li> <li> <p>More: Triggers additional suggestions generation while keeping each suggestion focused and relevant as the original set</p> </li> <li> <p>Update: Triggers a re-analysis of the code, providing updated suggestions based on the latest changes</p> </li> <li> <p>Author self-review: Interactive acknowledgment that developers have opened and reviewed collapsed suggestions</p> </li> </ul>"},{"location":"core-abilities/interactivity/#2-interactive-analyze-tool","title":"2. Interactive <code>/analyze</code> Tool","text":"<p>The <code>/analyze</code> command provides component-level analysis with interactive options for each identified code component:</p> <ul> <li> <p>Interactive checkboxes to generate tests, documentation, and code suggestions for specific components</p> </li> <li> <p>On-demand similar code search that activates when a checkbox is clicked</p> </li> <li> <p>Component-specific actions that trigger only for the selected elements, providing focused assistance</p> </li> </ul>"},{"location":"core-abilities/interactivity/#3-interactive-help-tool","title":"3. Interactive <code>/help</code> Tool","text":"<p>The <code>/help</code> command not only lists available tools and their descriptions but also enables immediate tool invocation through interactive checkboxes. When a user checks a tool's checkbox, Qodo Merge instantly triggers that tool without requiring additional commands. This transforms the standard help menu into an interactive launch pad for all Qodo Merge capabilities, eliminating context switching by keeping developers within their PR workflow.</p>"},{"location":"core-abilities/metadata/","title":"Local and global metadata","text":""},{"location":"core-abilities/metadata/#local-and-global-metadata-injection-with-multi-stage-analysis","title":"Local and global metadata injection with multi-stage analysis","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p> <p>1. Qodo Merge initially retrieves for each PR the following data:</p> <ul> <li>PR title and branch name</li> <li>PR original description</li> <li>Commit messages history</li> <li>PR diff patches, in hunk diff format</li> <li>The entire content of the files that were modified in the PR</li> </ul> <p>Tip: Organization-level metadata</p> <p>In addition to the inputs above, Qodo Merge can incorporate supplementary preferences provided by the user, like <code>extra_instructions</code> and <code>organization best practices</code>. This information can be used to enhance the PR analysis.</p> <p>2. By default, the first command that Qodo Merge executes is <code>describe</code>, which generates three types of outputs:</p> <ul> <li>PR Type (e.g. bug fix, feature, refactor, etc)</li> <li>PR Description - a bullet point summary of the PR</li> <li>Changes walkthrough - for each modified file, provide a one-line summary followed by a detailed bullet point list of the changes.</li> </ul> <p>These AI-generated outputs are now considered as part of the PR metadata, and can be used in subsequent commands like <code>review</code> and <code>improve</code>. This effectively enables multi-stage chain-of-thought analysis, without doing any additional API calls which will cost time and money.</p> <p>For example, when generating code suggestions for different files, Qodo Merge can inject the AI-generated \"Changes walkthrough\" file summary in the prompt:</p> <pre><code>## File: 'src/file1.py'\n### AI-generated file summary:\n- edited function `func1` that does X\n- Removed function `func2` that was not used\n- ....\n\n@@ ... @@ def func1():\n__new hunk__\n11  unchanged code line0\n12  unchanged code line1\n13 +new code line2 added\n14  unchanged code line3\n__old hunk__\n unchanged code line0\n unchanged code line1\n-old code line2 removed\n unchanged code line3\n\n@@ ... @@ def func2():\n__new hunk__\n...\n__old hunk__\n...\n</code></pre> <p>3. The entire PR files that were retrieved are also used to expand and enhance the PR context (see Dynamic Context).</p> <p>4. All the metadata described above represents several level of cumulative analysis - ranging from hunk level, to file level, to PR level, to organization level. This comprehensive approach enables Qodo Merge AI models to generate more precise and contextually relevant suggestions and feedback.</p>"},{"location":"core-abilities/rag_context_enrichment/","title":"RAG context enrichment","text":""},{"location":"core-abilities/rag_context_enrichment/#rag-context-enrichment","title":"RAG Context Enrichment \ud83d\udc8e","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket, Bitbucket Data Center</code></p> <p>Prerequisites</p> <ul> <li>RAG is available only for Qodo enterprise plan users, with single tenant or on-premises setup.</li> <li>Database setup and codebase indexing must be completed before proceeding. Contact support for more information.</li> </ul>"},{"location":"core-abilities/rag_context_enrichment/#overview","title":"Overview","text":""},{"location":"core-abilities/rag_context_enrichment/#what-is-rag-context-enrichment","title":"What is RAG Context Enrichment?","text":"<p>A feature that enhances AI analysis by retrieving and referencing relevant code patterns from your project, enabling context-aware insights during code reviews.</p>"},{"location":"core-abilities/rag_context_enrichment/#how-does-rag-context-enrichment-work","title":"How does RAG Context Enrichment work?","text":"<p>Using Retrieval-Augmented Generation (RAG), it searches your configured repositories for contextually relevant code segments, enriching pull request (PR) insights and accelerating review accuracy.</p>"},{"location":"core-abilities/rag_context_enrichment/#getting-started","title":"Getting started","text":""},{"location":"core-abilities/rag_context_enrichment/#configuration-options","title":"Configuration options","text":"<p>In order to enable the RAG feature, add the following lines to your configuration file:</p> <pre><code>[rag_arguments]\nenable_rag=true\n</code></pre> RAG Arguments Options <p> enable_rag If set to true, repository enrichment using RAG will be enabled. Default is false. rag_repo_list A list of repositories that will be used by the semantic search for RAG. Use <code>['all']</code> to consider the entire codebase or a select list of repositories, for example: ['my-org/my-repo', ...]. Default: the repository from which the PR was opened. </p>"},{"location":"core-abilities/rag_context_enrichment/#applications","title":"Applications","text":"<p>RAG capability is exclusively available in the following tools:</p> <code>/ask</code><code>/compliance</code><code>/implement</code><code>/review</code> <p>The <code>/ask</code> tool can access broader repository context through the RAG feature when answering questions that go beyond the PR scope alone. The References section displays the additional repository content consulted to formulate the answer.</p> <p></p> <p>The <code>/compliance</code> tool offers the Codebase Code Duplication Compliance section which contains feedback based on the RAG references. This section highlights possible code duplication issues in the PR, providing developers with insights into potential code quality concerns.</p> <p></p> <p>The <code>/implement</code> tool utilizes the RAG feature to provide comprehensive context of the repository codebase, allowing it to generate more refined code output. The References section contains links to the content used to support the code generation.</p> <p></p> <p>The <code>/review</code> tool offers the Focus area from RAG data which contains feedback based on the RAG references analysis. The complete list of references found relevant to the PR will be shown in the References section, helping developers understand the broader context by exploring the provided references.</p> <p></p>"},{"location":"core-abilities/rag_context_enrichment/#limitations","title":"Limitations","text":""},{"location":"core-abilities/rag_context_enrichment/#querying-the-codebase-presents-significant-challenges","title":"Querying the codebase presents significant challenges","text":"<ul> <li>Search Method: RAG uses natural language queries to find semantically relevant code sections</li> <li>Result Quality: No guarantee that RAG results will be useful for all queries</li> <li>Scope Recommendation: To reduce noise, focus on the PR repository rather than searching across multiple repositories</li> </ul>"},{"location":"core-abilities/rag_context_enrichment/#this-feature-has-several-requirements-and-restrictions","title":"This feature has several requirements and restrictions","text":"<ul> <li>Codebase: Must be properly indexed for search functionality</li> <li>Security: Requires secure and private indexed codebase implementation</li> <li>Deployment: Only available for Qodo Merge Enterprise plan using single tenant or on-premises setup</li> </ul>"},{"location":"core-abilities/self_reflection/","title":"Self-reflection","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p> <p>Qodo Merge implements a self-reflection process where the AI model reflects, scores, and re-ranks its own suggestions, eliminating irrelevant or incorrect ones. This approach improves the quality and relevance of suggestions, saving users time and enhancing their experience. Configuration options allow users to set a score threshold for further filtering out suggestions.</p>"},{"location":"core-abilities/self_reflection/#introduction-efficient-review-with-hierarchical-presentation","title":"Introduction - Efficient Review with Hierarchical Presentation","text":"<p>Given that not all generated code suggestions will be relevant, it is crucial to enable users to review them in a fast and efficient way, allowing quick identification and filtering of non-applicable ones.</p> <p>To achieve this goal, Qodo Merge offers a dedicated hierarchical structure when presenting suggestions to users:</p> <ul> <li>A \"category\" section groups suggestions by their category, allowing users to quickly dismiss irrelevant suggestions.</li> <li>Each suggestion is first described by a one-line summary, which can be expanded to a full description by clicking on a collapsible.</li> <li>Upon expanding a suggestion, the user receives a more comprehensive description, and a code snippet demonstrating the recommendation.</li> </ul> <p>Fast Review</p> <p>This hierarchical structure is designed to facilitate rapid review of each suggestion, with users spending an average of ~5-10 seconds per item.</p>"},{"location":"core-abilities/self_reflection/#self-reflection-and-re-ranking","title":"Self-reflection and Re-ranking","text":"<p>The AI model is initially tasked with generating suggestions, and outputting them in order of importance. However, in practice we observe that models often struggle to simultaneously generate high-quality code suggestions and rank them well in a single pass. Furthermore, the initial set of generated suggestions sometimes contains easily identifiable errors.</p> <p>To address these issues, we implemented a \"self-reflection\" process that refines suggestion ranking and eliminates irrelevant or incorrect proposals. This process consists of the following steps:</p> <ol> <li>Presenting the generated suggestions to the model in a follow-up call.</li> <li>Instructing the model to score each suggestion on a scale of 0-10 and provide a rationale for the assigned score.</li> <li>Utilizing these scores to re-rank the suggestions and filter out incorrect ones (with a score of 0).</li> <li>Optionally, filtering out all suggestions below a user-defined score threshold.</li> </ol> <p>Note that presenting all generated suggestions simultaneously provides the model with a comprehensive context, enabling it to make more informed decisions compared to evaluating each suggestion individually.</p> <p>To conclude, the self-reflection process enables Qodo Merge to prioritize suggestions based on their importance, eliminate inaccurate or irrelevant proposals, and optionally exclude suggestions that fall below a specified threshold of significance. This results in a more refined and valuable set of suggestions for the user, saving time and improving the overall experience.</p>"},{"location":"core-abilities/self_reflection/#example-results","title":"Example Results","text":""},{"location":"core-abilities/self_reflection/#appendix-relevant-configuration-options","title":"Appendix - Relevant Configuration Options","text":"<pre><code>[pr_code_suggestions]\nsuggestions_score_threshold = 0 # Filter out suggestions with a score below this threshold (0-10)\n</code></pre>"},{"location":"core-abilities/static_code_analysis/","title":"Static code analysis","text":""},{"location":"core-abilities/static_code_analysis/#static-code-analysis","title":"Static Code Analysis \ud83d\udc8e","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p> <p>By combining static code analysis with LLM capabilities, Qodo Merge can provide a comprehensive analysis of the PR code changes on a component level.</p> <p>It scans the PR code changes, finds all the code components (methods, functions, classes) that changed, and enables to interactively generate tests, docs, code suggestions and similar code search for each component.</p> <p>Language that are currently supported:</p> <p>Python, Java, C++, JavaScript, TypeScript, C#, Go, Ruby, PHP, Rust, Kotlin, Scala</p>"},{"location":"core-abilities/static_code_analysis/#capabilities","title":"Capabilities","text":""},{"location":"core-abilities/static_code_analysis/#analyze-pr","title":"Analyze PR","text":"<p>The <code>analyze</code> tool enables to interactively generate tests, docs, code suggestions and similar code search for each component that changed in the PR. It can be invoked manually by commenting on any PR:</p> <pre><code>/analyze\n</code></pre> <p>An example result:</p> <p></p> <p>Clicking on each checkbox will trigger the relevant tool for the selected component.</p>"},{"location":"core-abilities/static_code_analysis/#generate-tests","title":"Generate Tests","text":"<p>The <code>test</code> tool  generate tests for a selected component, based on the PR code changes. It can be invoked manually by commenting on any PR:</p> <pre><code>/test component_name\n</code></pre> <p>where 'component_name' is the name of a specific component in the PR,  Or be triggered interactively by using the <code>analyze</code> tool.</p> <p></p>"},{"location":"core-abilities/static_code_analysis/#generate-docs-for-a-component","title":"Generate Docs for a Component","text":"<p>The <code>add_docs</code> tool scans the PR code changes, and automatically generate docstrings for any code components that changed in the PR. It can be invoked manually by commenting on any PR:</p> <pre><code>/add_docs component_name\n</code></pre> <p>Or be triggered interactively by using the <code>analyze</code> tool.</p> <p></p>"},{"location":"core-abilities/static_code_analysis/#generate-code-suggestions-for-a-component","title":"Generate Code Suggestions for a Component","text":"<p>The <code>improve_component</code> tool generates code suggestions for a specific code component that changed in the PR. It can be invoked manually by commenting on any PR:</p> <pre><code>/improve_component component_name\n</code></pre> <p>Or be triggered interactively by using the <code>analyze</code> tool.</p> <p></p>"},{"location":"core-abilities/static_code_analysis/#find-similar-code","title":"Find Similar Code","text":"<p>The <code>similar code</code> tool retrieves the most similar code components from inside the organization's codebase or from open-source code, including details about the license associated with each repository.</p> <p>For example:</p> <p><code>Global Search</code> for a method called <code>chat_completion</code>:</p> <p></p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#faq","title":"FAQ","text":"Q: Can Qodo Merge serve as a substitute for a human reviewer? Q: I received an incorrect or irrelevant suggestion. Why? Q: How can I get more tailored suggestions? Q: Will you store my code? Are you using my code to train models? Q: Can I use my own LLM keys with Qodo Merge? Q: Can Qodo Merge review draft/offline PRs? Q: Can the 'Review effort' feedback be calibrated or customized? Q: How to reduce the noise generated by Qodo Merge?"},{"location":"faq/#answer1","title":"Answer:1","text":"<p>Qodo Merge is designed to assist, not replace, human reviewers.</p> <p>Reviewing PRs is a tedious and time-consuming task often seen as a \"chore\". In addition, the longer the PR \u2013 the shorter the relative feedback, since long PRs can overwhelm reviewers, both in terms of technical difficulty, and the actual review time. Qodo Merge aims to address these pain points, and to assist and empower both the PR author and reviewer.</p> <p>However, Qodo Merge has built-in safeguards to ensure the developer remains in the driver's seat. For example:</p> <ol> <li>Preserves user's original PR header</li> <li>Places user's description above the AI-generated PR description</li> <li>Won't approve PRs; approval remains reviewer's responsibility</li> <li>The code suggestions are optional, and aim to:<ul> <li>Encourage self-review and self-reflection</li> <li>Highlight potential bugs or oversights</li> <li>Enhance code quality and promote best practices</li> </ul> </li> </ol> <p>Read more about this issue in our blog</p>"},{"location":"faq/#answer2","title":"Answer:2","text":"<ul> <li>Modern AI models, like Claude Sonnet and GPT-5, are improving rapidly but remain imperfect. Users should critically evaluate all suggestions rather than accepting them automatically.</li> <li> <p>AI errors are rare, but possible. A main value from reviewing the code suggestions lies in their high probability of catching mistakes or bugs made by the PR author. We believe it's worth spending 30-60 seconds reviewing suggestions, even if some aren't relevant, as this practice can enhance code quality and prevent bugs in production.</p> </li> <li> <p>The hierarchical structure of the suggestions is designed to help the user quickly understand them, and to decide which ones are relevant and which are not:</p> <ul> <li>Only if the <code>Category</code> header is relevant, the user should move to the summarized suggestion description.</li> <li>Only if the summarized suggestion description is relevant, the user should click on the collapsible, to read the full suggestion description with a code preview example.</li> </ul> </li> <li> <p>In addition, we recommend to use the <code>extra_instructions</code> field to guide the model to suggestions that are more relevant to the specific needs of the project.</p> </li> <li>The interactive PR chat also provides an easy way to get more tailored suggestions and feedback from the AI model.</li> </ul>"},{"location":"faq/#answer3","title":"Answer:3","text":"<p>See here for more information on how to use the <code>extra_instructions</code> and <code>best_practices</code> configuration options, to guide the model to more tailored suggestions.</p>"},{"location":"faq/#answer4","title":"Answer:4","text":"<p>No. Qodo Merge strict privacy policy ensures that your code is not stored or used for training purposes.</p> <p>For a detailed overview of our data privacy policy, please refer to this link</p>"},{"location":"faq/#answer5","title":"Answer:5","text":"<p>When you self-host the open-source version, you use your own keys.</p> <p>Qodo Merge with SaaS deployment is a hosted version of Qodo Merge, where Qodo manages the infrastructure and the keys. For enterprise customers, on-prem deployment is also available. Contact us for more information.</p>"},{"location":"faq/#answer6","title":"Answer:6","text":"<p>Yes. While Qodo Merge won't automatically review draft PRs, you can still get feedback by manually requesting it through online commenting.</p> <p>For active PRs, you can customize the automatic feedback settings here to match your team's workflow.</p>"},{"location":"faq/#answer7","title":"Answer:7","text":"<p>Yes, you can customize review effort estimates using the <code>extra_instructions</code> configuration option (see documentation).</p> <p>Example mapping:</p> <ul> <li>Effort 1: &lt; 30 minutes review time</li> <li>Effort 2: 30-60 minutes review time</li> <li>Effort 3: 60-90 minutes review time</li> <li>...</li> </ul> <p>Note: The effort levels (1-5) are primarily meant for comparative purposes, helping teams prioritize reviewing smaller PRs first. The actual review duration may vary, as the focus is on providing consistent relative effort estimates.</p>"},{"location":"faq/#answer3_1","title":"Answer:3","text":"<p>The default configuration of Qodo Merge is designed to balance helpful feedback with noise reduction. It reduces noise through several approaches:</p> <ul> <li>Auto-feedback uses three highly structured tools (<code>/describe</code>, <code>/review</code>, and <code>/improve</code>), designed to be accessible at a glance without creating large visual overload</li> <li>Suggestions are presented in a table format rather than as committable comments, which are far noisier</li> <li>The 'File Walkthrough' section is folded by default, as it tends to be verbose</li> <li>Intermediate comments are avoided when creating new PRs (like \"Qodo Merge is now reviewing your PR...\"), which would generate email noise</li> </ul> <p>From our experience, especially in large teams or organizations, complaints about \"noise\" sometimes stem from the following issues:</p> <ul> <li>Feedback from multiple bots: When multiple bots provide feedback on the same PR, it creates confusion and noise. We recommend using Qodo Merge as the primary feedback tool to streamline the process and reduce redundancy.</li> <li>Getting familiar with the tool: Unlike many tools that provide feedback only on demand, Qodo Merge automatically analyzes and suggests improvements for every code change. While this proactive approach can feel intimidating at first, it's designed to continuously enhance code quality and catch bugs and problems when they occur. We recommend reviewing this guide to help align expectations and maximize the value of Qodo Merge's auto-feedback.</li> </ul> <p>Therefore, at a global configuration level, we recommend using the default configuration, which is designed to reduce noise while providing valuable feedback.</p> <p>However, if you still find the feedback too noisy, you can adjust the configuration. Since each user and team has different needs, it's definitely possible - and even recommended - to adjust configurations for specific repos as needed. Ways to adjust the configuration for noise reduction include for example:</p> <ul> <li>Score thresholds for code suggestions</li> <li>Utilizing the <code>extra_instructions</code> field for more tailored feedback</li> <li>Controlling which tools run automatically</li> </ul> <p>Note that some users may prefer the opposite - more thorough and detailed feedback. Qodo Merge is designed to be flexible and customizable, allowing you to tailor the feedback to your team's specific needs and preferences. Examples of ways to increase feedback include:</p> <ul> <li><code>Exhaustive</code> code suggestions</li> <li>Dual-publishing mode</li> <li>Interactive usage</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#self-hosted-pr-agent","title":"Self-hosted PR-Agent","text":"<p>There are several ways to use self-hosted PR-Agent:</p> <ul> <li>Locally</li> <li>GitHub integration</li> <li>GitLab integration</li> <li>BitBucket integration</li> <li>Azure DevOps integration</li> <li>Gitea integration</li> </ul>"},{"location":"installation/#qodo-merge","title":"Qodo Merge \ud83d\udc8e","text":"<p>Qodo Merge, an app hosted by QodoAI for GitHub\\GitLab\\BitBucket, is also available.  With Qodo Merge, installation is as simple as adding the Qodo Merge app to your relevant repositories. See here for more details.</p>"},{"location":"installation/azure/","title":"Azure","text":""},{"location":"installation/azure/#azure-devops-pipeline","title":"Azure DevOps Pipeline","text":"<p>You can use a pre-built Action Docker image to run PR-Agent as an Azure DevOps pipeline. Add the following file to your repository under <code>azure-pipelines.yml</code>:</p> <pre><code># Opt out of CI triggers\ntrigger: none\n\n# Configure PR trigger\n# pr:\n#   branches:\n#     include:\n#     - '*'\n#   autoCancel: true\n#   drafts: false\n\n# NOTE for Azure Repos Git:\n# Azure Repos does not honor YAML pr: triggers. Configure Build Validation\n# via Branch Policies instead (see note below). You can safely omit pr:.\n\nstages:\n- stage: pr_agent\n  displayName: 'PR Agent Stage'\n  jobs:\n  - job: pr_agent_job\n    displayName: 'PR Agent Job'\n    pool:\n      vmImage: 'ubuntu-latest'\n    container:\n      image: codiumai/pr-agent:latest\n      options: --entrypoint \"\"\n    variables:\n      - group: pr_agent\n    steps:\n    - script: |\n        echo \"Running PR Agent action step\"\n\n        # Construct PR_URL\n        PR_URL=\"${SYSTEM_COLLECTIONURI}${SYSTEM_TEAMPROJECT}/_git/${BUILD_REPOSITORY_NAME}/pullrequest/${SYSTEM_PULLREQUEST_PULLREQUESTID}\"\n        echo \"PR_URL=$PR_URL\"\n\n        # Extract organization URL from System.CollectionUri\n        ORG_URL=$(echo \"$(System.CollectionUri)\" | sed 's/\\/$//') # Remove trailing slash if present\n        echo \"Organization URL: $ORG_URL\"\n\n        export azure_devops__org=\"$ORG_URL\"\n        export config__git_provider=\"azure\"\n\n        pr-agent --pr_url=\"$PR_URL\" describe\n        pr-agent --pr_url=\"$PR_URL\" review\n        pr-agent --pr_url=\"$PR_URL\" improve\n      env:\n        azure_devops__pat: $(azure_devops_pat)\n        openai__key: $(OPENAI_KEY)\n      displayName: 'Run Qodo Merge'\n</code></pre> <p>This script will run Qodo Merge on every new merge request, with the <code>improve</code>, <code>review</code>, and <code>describe</code> commands. Note that you need to export the <code>azure_devops__pat</code> and <code>OPENAI_KEY</code> variables in the Azure DevOps pipeline settings (Pipelines -&gt; Library -&gt; + Variable group):</p> <p></p> <p>Make sure to give pipeline permissions to the <code>pr_agent</code> variable group.</p> <p>Note that Azure Pipelines lacks support for triggering workflows from PR comments. If you find a viable solution, please contribute it to our issue tracker</p>"},{"location":"installation/azure/#azure-repos-git-pr-triggers-and-build-validation","title":"Azure Repos Git PR triggers and Build Validation","text":"<p>Azure Repos Git does not use YAML <code>pr:</code> triggers for pipelines. Instead, configure Build Validation on the target branch to run the PR Agent pipeline for pull requests:</p> <ol> <li>Go to Project Settings \u2192 Repositories \u2192 Branches.</li> <li>Select the target branch and open Branch Policies.</li> <li>Under Build Validation, add a policy:</li> <li>Select the PR Agent pipeline (the <code>azure-pipelines.yml</code> above).</li> <li>Set it as Required.</li> <li>Remove the <code>pr:</code> section from your YAML (not needed for Azure Repos Git).</li> </ol> <p>This distinction applies specifically to Azure Repos Git. Other providers like GitHub and Bitbucket Cloud can use YAML-based PR triggers.</p>"},{"location":"installation/azure/#azure-devops-from-cli","title":"Azure DevOps from CLI","text":"<p>To use Azure DevOps provider use the following settings in configuration.toml:</p> <pre><code>[config]\ngit_provider=\"azure\"\n</code></pre> <p>Azure DevOps provider supports PAT token or DefaultAzureCredential authentication. PAT is faster to create, but has built-in expiration date, and will use the user identity for API calls. Using DefaultAzureCredential you can use managed identity or Service principle, which are more secure and will create separate ADO user identity (via AAD) to the agent.</p> <p>If PAT was chosen, you can assign the value in .secrets.toml. If DefaultAzureCredential was chosen, you can assigned the additional env vars like AZURE_CLIENT_SECRET directly, or use managed identity/az cli (for local development) without any additional configuration. in any case, 'org' value must be assigned in .secrets.toml:</p> <pre><code>[azure_devops]\norg = \"https://dev.azure.com/YOUR_ORGANIZATION/\"\n# pat = \"YOUR_PAT_TOKEN\" needed only if using PAT for authentication\n</code></pre>"},{"location":"installation/azure/#azure-devops-webhook","title":"Azure DevOps Webhook","text":"<p>To trigger from an Azure webhook, you need to manually add a webhook. Use the \"Pull request created\" type to trigger a review, or \"Pull request commented on\" to trigger any supported comment with /  comment on the relevant PR. Note that for the \"Pull request commented on\" trigger, only API v2.0 is supported.</p> <p>For webhook security, create a sporadic username/password pair and configure the webhook username and password on both the server and Azure DevOps webhook. These will be sent as basic Auth data by the webhook with each request:</p> <pre><code>[azure_devops_server]\nwebhook_username = \"&lt;basic auth user&gt;\"\nwebhook_password = \"&lt;basic auth password&gt;\"\n</code></pre> <p> Ensure that the webhook endpoint is only accessible over HTTPS to mitigate the risk of credential interception when using basic authentication.</p>"},{"location":"installation/bitbucket/","title":"Bitbucket","text":""},{"location":"installation/bitbucket/#run-as-a-bitbucket-pipeline","title":"Run as a Bitbucket Pipeline","text":"<p>You can use the Bitbucket Pipeline system to run PR-Agent on every pull request open or update.</p> <ol> <li>Add the following file in your repository bitbucket-pipelines.yml</li> </ol> <pre><code>pipelines:\n    pull-requests:\n      '**':\n        - step:\n            name: PR Agent Review\n            image: codiumai/pr-agent:latest\n            script:\n              - pr-agent --pr_url=https://bitbucket.org/$BITBUCKET_WORKSPACE/$BITBUCKET_REPO_SLUG/pull-requests/$BITBUCKET_PR_ID review\n</code></pre> <ol> <li> <p>Add the following secure variables to your repository under Repository settings &gt; Pipelines &gt; Repository variables.</p> </li> <li> <p>CONFIG__GIT_PROVIDER: <code>bitbucket</code></p> </li> <li>OPENAI__KEY: <code>&lt;your key&gt;</code></li> <li>BITBUCKET__AUTH_TYPE: <code>basic</code> or <code>bearer</code> (default is <code>bearer</code>)</li> <li>BITBUCKET__BEARER_TOKEN: <code>&lt;your token&gt;</code> (required when auth_type is bearer)</li> <li>BITBUCKET__BASIC_TOKEN: <code>&lt;your token&gt;</code> (required when auth_type is basic)</li> </ol> <p>You can get a Bitbucket token for your repository by following Repository Settings -&gt; Security -&gt; Access Tokens. For basic auth, you can generate a base64 encoded token from your username:password combination.</p> <p>Note that comments on a PR are not supported in Bitbucket Pipeline.</p>"},{"location":"installation/bitbucket/#bitbucket-server-and-data-center","title":"Bitbucket Server and Data Center","text":"<p>Login into your on-prem instance of Bitbucket with your service account username and password. Navigate to <code>Manage account</code>, <code>HTTP Access tokens</code>, <code>Create Token</code>. Generate the token and add it to .secret.toml under <code>bitbucket_server</code> section</p> <pre><code>[bitbucket_server]\nbearer_token = \"&lt;your key&gt;\"\n</code></pre> <p>Don't forget to also set the URL of your Bitbucket Server instance (either in <code>.secret.toml</code> or in <code>configuration.toml</code>):</p> <pre><code>[bitbucket_server]\nurl = \"&lt;full URL to your Bitbucket instance, e.g.: https://git.bitbucket.com&gt;\"\n</code></pre>"},{"location":"installation/bitbucket/#run-it-as-cli","title":"Run it as CLI","text":"<p>Modify <code>configuration.toml</code>:</p> <pre><code>git_provider=\"bitbucket_server\"\n</code></pre> <p>and pass the Pull request URL:</p> <pre><code>python cli.py --pr_url https://git.on-prem-instance-of-bitbucket.com/projects/PROJECT/repos/REPO/pull-requests/1 review\n</code></pre>"},{"location":"installation/bitbucket/#run-it-as-service","title":"Run it as service","text":"<p>To run PR-Agent as webhook, build the docker image:</p> <pre><code>docker build . -t codiumai/pr-agent:bitbucket_server_webhook --target bitbucket_server_webhook -f docker/Dockerfile\ndocker push codiumai/pr-agent:bitbucket_server_webhook  # Push to your Docker repository\n</code></pre> <p>Navigate to <code>Projects</code> or <code>Repositories</code>, <code>Settings</code>, <code>Webhooks</code>, <code>Create Webhook</code>. Fill in the name and URL. For Authentication, select 'None'. Select the 'Pull Request Opened' checkbox to receive that event as a webhook.</p> <p>The URL should end with <code>/webhook</code>, for example: https://domain.com/webhook</p>"},{"location":"installation/gitea/","title":"Gitea","text":""},{"location":"installation/gitea/#run-a-gitea-webhook-server","title":"Run a Gitea webhook server","text":"<ol> <li> <p>In Gitea create a new user and give it \"Reporter\" role (\"Developer\" if using Pro version of the agent) for the intended group or project.</p> </li> <li> <p>For the user from step 1. generate a <code>personal_access_token</code> with <code>api</code> access.</p> </li> <li> <p>Generate a random secret for your app, and save it for later (<code>webhook_secret</code>). For example, you can use:</p> </li> </ol> <pre><code>WEBHOOK_SECRET=$(python -c \"import secrets; print(secrets.token_hex(10))\")\n</code></pre> <ol> <li>Clone this repository:</li> </ol> <pre><code>git clone https://github.com/qodo-ai/pr-agent.git\n</code></pre> <ol> <li> <p>Prepare variables and secrets. Skip this step if you plan on setting these as environment variables when running the agent:</p> <ul> <li>In the configuration file/variables:<ul> <li>Set <code>config.git_provider</code> to \"gitea\"</li> </ul> </li> <li>In the secrets file/variables:<ul> <li>Set your AI model key in the respective section</li> <li>In the [Gitea] section, set <code>personal_access_token</code> (with token from step 2) and <code>webhook_secret</code> (with secret from step 3)</li> </ul> </li> </ul> </li> <li> <p>Build a Docker image for the app and optionally push it to a Docker repository. We'll use Dockerhub as an example:</p> </li> </ol> <pre><code>docker build -f /docker/Dockerfile -t pr-agent:gitea_app --target gitea_app .\ndocker push codiumai/pr-agent:gitea_webhook  # Push to your Docker repository\n</code></pre> <ol> <li>Set the environmental variables, the method depends on your docker runtime. Skip this step if you included your secrets/configuration directly in the Docker image.</li> </ol> <pre><code>CONFIG__GIT_PROVIDER=gitea\nGITEA__PERSONAL_ACCESS_TOKEN=&lt;personal_access_token&gt;\nGITEA__WEBHOOK_SECRET=&lt;webhook_secret&gt;\nGITEA__URL=https://gitea.com # Or self host\nOPENAI__KEY=&lt;your_openai_api_key&gt;\nGITEA__SKIP_SSL_VERIFICATION=false # or true\nGITEA__SSL_CA_CERT=/path/to/cacert.pem\n</code></pre> <ol> <li> <p>Create a webhook in your Gitea project. Set the URL to <code>http[s]://&lt;PR_AGENT_HOSTNAME&gt;/api/v1/gitea_webhooks</code>, the secret token to the generated secret from step 3, and enable the triggers <code>push</code>, <code>comments</code> and <code>merge request events</code>.</p> </li> <li> <p>Test your installation by opening a merge request or commenting on a merge request using one of PR Agent's commands.</p> </li> </ol>"},{"location":"installation/github/","title":"Github","text":"<p>In this page we will cover how to install and run PR-Agent as a GitHub Action or GitHub App, and how to configure it for your needs.</p>"},{"location":"installation/github/#run-as-a-github-action","title":"Run as a GitHub Action","text":"<p>You can use our pre-built Github Action Docker image to run PR-Agent as a Github Action.</p> <p>1) Add the following file to your repository under <code>.github/workflows/pr_agent.yml</code>:</p> <pre><code>on:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    name: Run pr agent on every pull request, respond to user comments\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: qodo-ai/pr-agent@main\n        env:\n          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>2) Add the following secret to your repository under <code>Settings &gt; Secrets and variables &gt; Actions &gt; New repository secret &gt; Add secret</code>:</p> <pre><code>Name = OPENAI_KEY\nSecret = &lt;your key&gt;\n</code></pre> <p>The GITHUB_TOKEN secret is automatically created by GitHub.</p> <p>3) Merge this change to your main branch. When you open your next PR, you should see a comment from <code>github-actions</code> bot with a review of your PR, and instructions on how to use the rest of the tools.</p> <p>4) You may configure Qodo Merge by adding environment variables under the env section corresponding to any configurable property in the configuration file. Some examples:</p> <pre><code>      env:\n        # ... previous environment values\n        OPENAI.ORG: \"&lt;Your organization name under your OpenAI account&gt;\"\n        PR_REVIEWER.REQUIRE_TESTS_REVIEW: \"false\" # Disable tests review\n        PR_CODE_SUGGESTIONS.NUM_CODE_SUGGESTIONS: 6 # Increase number of code suggestions\n</code></pre> <p>See detailed usage instructions in the USAGE GUIDE</p>"},{"location":"installation/github/#configuration-examples","title":"Configuration Examples","text":"<p>This section provides detailed, step-by-step examples for configuring PR-Agent with different models and advanced options in GitHub Actions.</p>"},{"location":"installation/github/#quick-start-examples","title":"Quick Start Examples","text":""},{"location":"installation/github/#basic-setup-openai-default","title":"Basic Setup (OpenAI Default)","text":"<p>Copy this minimal workflow to get started with the default OpenAI models:</p> <pre><code>name: PR Agent\non:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    steps:\n      - name: PR Agent action step\n        uses: qodo-ai/pr-agent@main\n        env:\n          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre>"},{"location":"installation/github/#gemini-setup","title":"Gemini Setup","text":"<p>Ready-to-use workflow for Gemini models:</p> <pre><code>name: PR Agent (Gemini)\non:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    steps:\n      - name: PR Agent action step\n        uses: qodo-ai/pr-agent@main\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          config.model: \"gemini/gemini-1.5-flash\"\n          config.fallback_models: '[\"gemini/gemini-1.5-flash\"]'\n          GOOGLE_AI_STUDIO.GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}\n          github_action_config.auto_review: \"true\"\n          github_action_config.auto_describe: \"true\"\n          github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#claude-setup","title":"Claude Setup","text":"<p>Ready-to-use workflow for Claude models:</p> <pre><code>name: PR Agent (Claude)\non:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    steps:\n      - name: PR Agent action step\n        uses: qodo-ai/pr-agent@main\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          config.model: \"anthropic/claude-3-opus-20240229\"\n          config.fallback_models: '[\"anthropic/claude-3-haiku-20240307\"]'\n          ANTHROPIC.KEY: ${{ secrets.ANTHROPIC_KEY }}\n          github_action_config.auto_review: \"true\"\n          github_action_config.auto_describe: \"true\"\n          github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#basic-configuration-with-tool-controls","title":"Basic Configuration with Tool Controls","text":"<p>Start with this enhanced workflow that includes tool configuration:</p> <pre><code>on:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    name: Run pr agent on every pull request, respond to user comments\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: qodo-ai/pr-agent@main\n        env:\n          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          # Enable/disable automatic tools\n          github_action_config.auto_review: \"true\"\n          github_action_config.auto_describe: \"true\"\n          github_action_config.auto_improve: \"true\"\n          # Configure which PR events trigger the action\n          github_action_config.pr_actions: '[\"opened\", \"reopened\", \"ready_for_review\", \"review_requested\"]'\n</code></pre>"},{"location":"installation/github/#switching-models","title":"Switching Models","text":""},{"location":"installation/github/#using-gemini-google-ai-studio","title":"Using Gemini (Google AI Studio)","text":"<p>To use Gemini models instead of the default OpenAI models:</p> <pre><code>      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Set the model to Gemini\n        config.model: \"gemini/gemini-1.5-flash\"\n        config.fallback_models: '[\"gemini/gemini-1.5-flash\"]'\n        # Add your Gemini API key\n        GOOGLE_AI_STUDIO.GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}\n        # Tool configuration\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre> <p>Required Secrets:</p> <ul> <li>Add <code>GEMINI_API_KEY</code> to your repository secrets (get it from Google AI Studio)</li> </ul> <p>Note: When using non-OpenAI models like Gemini, you don't need to set <code>OPENAI_KEY</code> - only the model-specific API key is required.</p>"},{"location":"installation/github/#using-claude-anthropic","title":"Using Claude (Anthropic)","text":"<p>To use Claude models:</p> <pre><code>      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Set the model to Claude\n        config.model: \"anthropic/claude-3-opus-20240229\"\n        config.fallback_models: '[\"anthropic/claude-3-haiku-20240307\"]'\n        # Add your Anthropic API key\n        ANTHROPIC.KEY: ${{ secrets.ANTHROPIC_KEY }}\n        # Tool configuration\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre> <p>Required Secrets:</p> <ul> <li>Add <code>ANTHROPIC_KEY</code> to your repository secrets (get it from Anthropic Console)</li> </ul> <p>Note: When using non-OpenAI models like Claude, you don't need to set <code>OPENAI_KEY</code> - only the model-specific API key is required.</p>"},{"location":"installation/github/#using-azure-openai","title":"Using Azure OpenAI","text":"<p>To use Azure OpenAI services:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.AZURE_OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Azure OpenAI configuration\n        OPENAI.API_TYPE: \"azure\"\n        OPENAI.API_VERSION: \"2023-05-15\"\n        OPENAI.API_BASE: ${{ secrets.AZURE_OPENAI_ENDPOINT }}\n        OPENAI.DEPLOYMENT_ID: ${{ secrets.AZURE_OPENAI_DEPLOYMENT }}\n        # Set the model to match your Azure deployment\n        config.model: \"gpt-4o\"\n        config.fallback_models: '[\"gpt-4o\"]'\n        # Tool configuration\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre> <p>Required Secrets:</p> <ul> <li><code>AZURE_OPENAI_KEY</code>: Your Azure OpenAI API key</li> <li><code>AZURE_OPENAI_ENDPOINT</code>: Your Azure OpenAI endpoint URL</li> <li><code>AZURE_OPENAI_DEPLOYMENT</code>: Your deployment name</li> </ul>"},{"location":"installation/github/#using-local-models-ollama","title":"Using Local Models (Ollama)","text":"<p>To use local models via Ollama:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Set the model to a local Ollama model\n        config.model: \"ollama/qwen2.5-coder:32b\"\n        config.fallback_models: '[\"ollama/qwen2.5-coder:32b\"]'\n        config.custom_model_max_tokens: \"128000\"\n        # Ollama configuration\n        OLLAMA.API_BASE: \"http://localhost:11434\"\n        # Tool configuration\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre> <p>Note: For local models, you'll need to use a self-hosted runner with Ollama installed, as GitHub Actions hosted runners cannot access localhost services.</p>"},{"location":"installation/github/#advanced-configuration-options","title":"Advanced Configuration Options","text":""},{"location":"installation/github/#custom-review-instructions","title":"Custom Review Instructions","text":"<p>Add specific instructions for the review process:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Custom review instructions\n        pr_reviewer.extra_instructions: \"Focus on security vulnerabilities and performance issues. Check for proper error handling.\"\n        # Tool configuration\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#language-specific-configuration","title":"Language-Specific Configuration","text":"<p>Configure for specific programming languages:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Language-specific settings\n        pr_reviewer.extra_instructions: \"Focus on Python best practices, type hints, and docstrings.\"\n        pr_code_suggestions.num_code_suggestions: \"8\"\n        pr_code_suggestions.suggestions_score_threshold: \"7\"\n        # Tool configuration\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#selective-tool-execution","title":"Selective Tool Execution","text":"<p>Run only specific tools automatically:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Only run review and describe, skip improve\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"false\"\n        # Only trigger on PR open and reopen\n        github_action_config.pr_actions: '[\"opened\", \"reopened\"]'\n</code></pre>"},{"location":"installation/github/#using-configuration-files","title":"Using Configuration Files","text":"<p>Instead of setting all options via environment variables, you can use a <code>.pr_agent.toml</code> file in your repository root:</p> <ol> <li>Create a <code>.pr_agent.toml</code> file in your repository root:</li> </ol> <pre><code>[config]\nmodel = \"gemini/gemini-1.5-flash\"\nfallback_models = [\"anthropic/claude-3-opus-20240229\"]\n\n[pr_reviewer]\nextra_instructions = \"Focus on security issues and code quality.\"\n\n[pr_code_suggestions]\nnum_code_suggestions = 6\nsuggestions_score_threshold = 7\n</code></pre> <ol> <li>Use a simpler workflow file:</li> </ol> <pre><code>on:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    name: Run pr agent on every pull request, respond to user comments\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: qodo-ai/pr-agent@main\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GOOGLE_AI_STUDIO.GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}\n          ANTHROPIC.KEY: ${{ secrets.ANTHROPIC_KEY }}\n          github_action_config.auto_review: \"true\"\n          github_action_config.auto_describe: \"true\"\n          github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"installation/github/#model-not-found-errors","title":"Model Not Found Errors","text":"<p>If you get model not found errors:</p> <ol> <li> <p>Check model name format: Ensure you're using the correct model identifier format (e.g., <code>gemini/gemini-1.5-flash</code>, not just <code>gemini-1.5-flash</code>)</p> </li> <li> <p>Verify API keys: Make sure your API keys are correctly set as repository secrets</p> </li> <li> <p>Check model availability: Some models may not be available in all regions or may require specific access</p> </li> </ol>"},{"location":"installation/github/#environment-variable-format","title":"Environment Variable Format","text":"<p>Remember these key points about environment variables:</p> <ul> <li>Use dots (<code>.</code>) or double underscores (<code>__</code>) to separate sections and keys</li> <li>Boolean values should be strings: <code>\"true\"</code> or <code>\"false\"</code></li> <li>Arrays should be JSON strings: <code>'[\"item1\", \"item2\"]'</code></li> <li>Model names are case-sensitive</li> </ul>"},{"location":"installation/github/#rate-limiting","title":"Rate Limiting","text":"<p>If you encounter rate limiting:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Add fallback models for better reliability\n        config.fallback_models: '[\"gpt-4o\", \"gpt-3.5-turbo\"]'\n        # Increase timeout for slower models\n        config.ai_timeout: \"300\"\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#common-error-messages-and-solutions","title":"Common Error Messages and Solutions","text":"<p>Error: \"Model not found\" - Solution: Check the model name format and ensure it matches the exact identifier. See the Changing a model in PR-Agent guide for supported models and their correct identifiers.</p> <p>Error: \"API key not found\" - Solution: Verify that your API key is correctly set as a repository secret and the environment variable name matches exactly - Note: For non-OpenAI models (Gemini, Claude, etc.), you only need the model-specific API key, not <code>OPENAI_KEY</code></p> <p>Error: \"Rate limit exceeded\" - Solution: Add fallback models or increase the <code>config.ai_timeout</code> value</p> <p>Error: \"Permission denied\" - Solution: Ensure your workflow has the correct permissions set:   </p><pre><code>permissions:\n  issues: write\n  pull-requests: write\n  contents: write\n</code></pre><p></p> <p>Error: \"Invalid JSON format\"</p> <ul> <li>Solution: Check that arrays are properly formatted as JSON strings:</li> </ul> <pre><code>Correct:\nconfig.fallback_models: '[\"model1\", \"model2\"]'\nIncorrect (interpreted as a YAML list, not a string):\nconfig.fallback_models: [\"model1\", \"model2\"]\n</code></pre>"},{"location":"installation/github/#debugging-tips","title":"Debugging Tips","text":"<ol> <li>Enable verbose logging: Add <code>config.verbosity_level: \"2\"</code> to see detailed logs</li> <li>Check GitHub Actions logs: Look at the step output for specific error messages</li> <li>Test with minimal configuration: Start with just the basic setup and add options one by one</li> <li>Verify secrets: Double-check that all required secrets are set in your repository settings</li> </ol>"},{"location":"installation/github/#performance-optimization","title":"Performance Optimization","text":"<p>For better performance with large repositories:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        # Optimize for large PRs\n        config.large_patch_policy: \"clip\"\n        config.max_model_tokens: \"32000\"\n        config.patch_extra_lines_before: \"3\"\n        config.patch_extra_lines_after: \"1\"\n        github_action_config.auto_review: \"true\"\n        github_action_config.auto_describe: \"true\"\n        github_action_config.auto_improve: \"true\"\n</code></pre>"},{"location":"installation/github/#reference","title":"Reference","text":"<p>For more detailed configuration options, see:</p> <ul> <li>Changing a model in PR-Agent</li> <li>Configuration options</li> <li>Automations and usage</li> </ul>"},{"location":"installation/github/#using-a-specific-release","title":"Using a specific release","text":"<p>if you want to pin your action to a specific release (v0.23 for example) for stability reasons, use: </p><pre><code>...\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: docker://codiumai/pr-agent:0.23-github_action\n...\n</code></pre><p></p> <p>For enhanced security, you can also specify the Docker image by its digest: </p><pre><code>...\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: docker://codiumai/pr-agent@sha256:14165e525678ace7d9b51cda8652c2d74abb4e1d76b57c4a6ccaeba84663cc64\n...\n</code></pre><p></p>"},{"location":"installation/github/#action-for-github-enterprise-server","title":"Action for GitHub enterprise server","text":"<p>To use the action with a GitHub enterprise server, add an environment variable <code>GITHUB.BASE_URL</code> with the API URL of your GitHub server.</p> <p>For example, if your GitHub server is at <code>https://github.mycompany.com</code>, add the following to your workflow file: </p><pre><code>      env:\n        # ... previous environment values\n        GITHUB.BASE_URL: \"https://github.mycompany.com/api/v3\"\n</code></pre><p></p>"},{"location":"installation/github/#run-as-a-github-app","title":"Run as a GitHub App","text":"<p>Allowing you to automate the review process on your private or public repositories.</p> <p>1) Create a GitHub App from the Github Developer Portal.</p> <ul> <li>Set the following permissions:<ul> <li>Pull requests: Read &amp; write</li> <li>Issue comment: Read &amp; write</li> <li>Metadata: Read-only</li> <li>Contents: Read-only</li> </ul> </li> <li>Set the following events:<ul> <li>Issue comment</li> <li>Pull request</li> <li>Push (if you need to enable triggering on PR update)</li> </ul> </li> </ul> <p>2) Generate a random secret for your app, and save it for later. For example, you can use:</p> <pre><code>WEBHOOK_SECRET=$(python -c \"import secrets; print(secrets.token_hex(10))\")\n</code></pre> <p>3) Acquire the following pieces of information from your app's settings page:</p> <ul> <li>App private key (click \"Generate a private key\" and save the file)</li> <li>App ID</li> </ul> <p>4) Clone this repository:</p> <pre><code>git clone https://github.com/Codium-ai/pr-agent.git\n</code></pre> <p>5) Copy the secrets template file and fill in the following:</p> <pre><code>cp pr_agent/settings/.secrets_template.toml pr_agent/settings/.secrets.toml\n# Edit .secrets.toml file\n</code></pre> <ul> <li>Your OpenAI key.</li> <li>Copy your app's private key to the private_key field.</li> <li>Copy your app's ID to the app_id field.</li> <li>Copy your app's webhook secret to the webhook_secret field.</li> <li> <p>Set deployment_type to 'app' in configuration.toml</p> <p>The .secrets.toml file is not copied to the Docker image by default, and is only used for local development. If you want to use the .secrets.toml file in your Docker image, you can add remove it from the .dockerignore file. In most production environments, you would inject the secrets file as environment variables or as mounted volumes. For example, in order to inject a secrets file as a volume in a Kubernetes environment you can update your pod spec to include the following, assuming you have a secret named <code>pr-agent-settings</code> with a key named <code>.secrets.toml</code>:</p> <pre><code>       volumes:\n        - name: settings-volume\n          secret:\n            secretName: pr-agent-settings\n// ...\n       containers:\n// ...\n          volumeMounts:\n            - mountPath: /app/pr_agent/settings_prod\n              name: settings-volume\n</code></pre> <p>Another option is to set the secrets as environment variables in your deployment environment, for example <code>OPENAI.KEY</code> and <code>GITHUB.USER_TOKEN</code>.</p> </li> </ul> <p>6) Build a Docker image for the app and optionally push it to a Docker repository. We'll use Dockerhub as an example:</p> <pre><code>```bash\ndocker build . -t codiumai/pr-agent:github_app --target github_app -f docker/Dockerfile\ndocker push codiumai/pr-agent:github_app  # Push to your Docker repository\n```\n</code></pre> <ol> <li> <p>Host the app using a server, serverless function, or container environment. Alternatively, for development and    debugging, you may use tools like smee.io to forward webhooks to your local machine.     You can check Deploy as a Lambda Function</p> </li> <li> <p>Go back to your app's settings, and set the following:</p> </li> <li> <p>Webhook URL: The URL of your app's server or the URL of the smee.io channel.</p> </li> <li> <p>Webhook secret: The secret you generated earlier.</p> </li> <li> <p>Install the app by navigating to the \"Install App\" tab and selecting your desired repositories.</p> </li> </ol> <p>Note: When running Qodo Merge from GitHub app, the default configuration file (configuration.toml) will be loaded. However, you can override the default tool parameters by uploading a local configuration file <code>.pr_agent.toml</code> For more information please check out the USAGE GUIDE</p>"},{"location":"installation/github/#additional-deployment-methods","title":"Additional deployment methods","text":""},{"location":"installation/github/#deploy-as-a-lambda-function","title":"Deploy as a Lambda Function","text":"<p>Note that since AWS Lambda env vars cannot have \".\" in the name, you can replace each \".\" in an env variable with \"__\". For example: <code>GITHUB.WEBHOOK_SECRET</code> --&gt; <code>GITHUB__WEBHOOK_SECRET</code></p> <ol> <li>Follow steps 1-5 from here.</li> <li> <p>Build a docker image that can be used as a lambda function</p> <p><code>shell docker buildx build --platform=linux/amd64 . -t codiumai/pr-agent:github_lambda --target github_lambda -f docker/Dockerfile.lambda</code>    (Note: --target github_lambda is optional as it's the default target)</p> </li> <li> <p>Push image to ECR</p> <pre><code>docker tag codiumai/pr-agent:github_lambda &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:github_lambda\ndocker push &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:github_lambda\n</code></pre> </li> <li> <p>Create a lambda function that uses the uploaded image. Set the lambda timeout to be at least 3m.</p> </li> <li>Configure the lambda function to have a Function URL.</li> <li>In the environment variables of the Lambda function, specify <code>AZURE_DEVOPS_CACHE_DIR</code> to a writable location such as /tmp. (see link)</li> <li>Go back to steps 8-9 of Method 5 with the function url as your Webhook URL.     The Webhook URL would look like <code>https://&lt;LAMBDA_FUNCTION_URL&gt;/api/v1/github_webhooks</code></li> </ol>"},{"location":"installation/github/#using-aws-secrets-manager","title":"Using AWS Secrets Manager","text":"<p>For production Lambda deployments, use AWS Secrets Manager instead of environment variables:</p> <ol> <li>Create a secret in AWS Secrets Manager with JSON format like this:</li> </ol> <pre><code>{\n  \"openai.key\": \"sk-proj-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",\n  \"github.webhook_secret\": \"your-webhook-secret-from-step-2\",\n  \"github.private_key\": \"-----BEGIN RSA PRIVATE KEY-----\\nMIIEpAIBAAKCAQEA...\\n-----END RSA PRIVATE KEY-----\"\n}\n</code></pre> <ol> <li>Add IAM permission <code>secretsmanager:GetSecretValue</code> to your Lambda execution role</li> <li>Set these environment variables in your Lambda:</li> </ol> <pre><code>AWS_SECRETS_MANAGER__SECRET_ARN=arn:aws:secretsmanager:us-east-1:123456789012:secret:pr-agent-secrets-AbCdEf\nCONFIG__SECRET_PROVIDER=aws_secrets_manager\n</code></pre>"},{"location":"installation/github/#aws-codecommit-setup","title":"AWS CodeCommit Setup","text":"<p>Not all features have been added to CodeCommit yet.  As of right now, CodeCommit has been implemented to run the Qodo Merge CLI on the command line, using AWS credentials stored in environment variables.  (More features will be added in the future.)  The following is a set of instructions to have Qodo Merge do a review of your CodeCommit pull request from the command line:</p> <ol> <li>Create an IAM user that you will use to read CodeCommit pull requests and post comments<ul> <li>Note: That user should have CLI access only, not Console access</li> </ul> </li> <li>Add IAM permissions to that user, to allow access to CodeCommit (see IAM Role example below)</li> <li>Generate an Access Key for your IAM user</li> <li>Set the Access Key and Secret using environment variables (see Access Key example below)</li> <li>Set the <code>git_provider</code> value to <code>codecommit</code> in the <code>pr_agent/settings/configuration.toml</code> settings file</li> <li>Set the <code>PYTHONPATH</code> to include your <code>pr-agent</code> project directory<ul> <li>Option A: Add <code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent</code> to your <code>.env</code> file</li> <li>Option B: Set <code>PYTHONPATH</code> and run the CLI in one command, for example:<ul> <li><code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent python pr_agent/cli.py [--ARGS]</code></li> </ul> </li> </ul> </li> </ol>"},{"location":"installation/github/#aws-codecommit-iam-role-example","title":"AWS CodeCommit IAM Role Example","text":"<p>Example IAM permissions to that user to allow access to CodeCommit:</p> <ul> <li>Note: The following is a working example of IAM permissions that has read access to the repositories and write access to allow posting comments</li> <li>Note: If you only want pr-agent to review your pull requests, you can tighten the IAM permissions further, however this IAM example will work, and allow the pr-agent to post comments to the PR</li> <li>Note: You may want to replace the <code>\"Resource\": \"*\"</code> with your list of repos, to limit access to only those repos</li> </ul> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"codecommit:BatchDescribe*\",\n                \"codecommit:BatchGet*\",\n                \"codecommit:Describe*\",\n                \"codecommit:EvaluatePullRequestApprovalRules\",\n                \"codecommit:Get*\",\n                \"codecommit:List*\",\n                \"codecommit:PostComment*\",\n                \"codecommit:PutCommentReaction\",\n                \"codecommit:UpdatePullRequestDescription\",\n                \"codecommit:UpdatePullRequestTitle\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre>"},{"location":"installation/github/#aws-codecommit-access-key-and-secret","title":"AWS CodeCommit Access Key and Secret","text":"<p>Example setting the Access Key and Secret using environment variables</p> <pre><code>export AWS_ACCESS_KEY_ID=\"XXXXXXXXXXXXXXXX\"\nexport AWS_SECRET_ACCESS_KEY=\"XXXXXXXXXXXXXXXX\"\nexport AWS_DEFAULT_REGION=\"us-east-1\"\n</code></pre>"},{"location":"installation/github/#aws-codecommit-cli-example","title":"AWS CodeCommit CLI Example","text":"<p>After you set up AWS CodeCommit using the instructions above, here is an example CLI run that tells pr-agent to review a given pull request. (Replace your specific PYTHONPATH and PR URL in the example)</p> <pre><code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent\" python pr_agent/cli.py \\\n  --pr_url https://us-east-1.console.aws.amazon.com/codesuite/codecommit/repositories/MY_REPO_NAME/pull-requests/321 \\\n  review\n</code></pre>"},{"location":"installation/gitlab/","title":"Gitlab","text":""},{"location":"installation/gitlab/#run-as-a-gitlab-pipeline","title":"Run as a GitLab Pipeline","text":"<p>You can use a pre-built Action Docker image to run PR-Agent as a GitLab pipeline. This is a simple way to get started with Qodo Merge without setting up your own server.</p> <p>(1) Add the following file to your repository under <code>.gitlab-ci.yml</code>:</p> <pre><code>stages:\n  - pr_agent\n\npr_agent_job:\n  stage: pr_agent\n  image:\n    name: codiumai/pr-agent:latest\n    entrypoint: [\"\"]\n  script:\n    - cd /app\n    - echo \"Running PR Agent action step\"\n    - export MR_URL=\"$CI_MERGE_REQUEST_PROJECT_URL/merge_requests/$CI_MERGE_REQUEST_IID\"\n    - echo \"MR_URL=$MR_URL\"\n    - export gitlab__url=$CI_SERVER_PROTOCOL://$CI_SERVER_FQDN\n    - export gitlab__PERSONAL_ACCESS_TOKEN=$GITLAB_PERSONAL_ACCESS_TOKEN\n    - export config__git_provider=\"gitlab\"\n    - export openai__key=$OPENAI_KEY\n    - python -m pr_agent.cli --pr_url=\"$MR_URL\" describe\n    - python -m pr_agent.cli --pr_url=\"$MR_URL\" review\n    - python -m pr_agent.cli --pr_url=\"$MR_URL\" improve\n  rules:\n    - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\n</code></pre> <p>This script will run Qodo Merge on every new merge request. You can modify the <code>rules</code> section to run Qodo Merge on different events. You can also modify the <code>script</code> section to run different Qodo Merge commands, or with different parameters by exporting different environment variables.</p> <p>(2) Add the following masked variables to your GitLab repository (CI/CD -&gt; Variables):</p> <ul> <li> <p><code>GITLAB_PERSONAL_ACCESS_TOKEN</code>: Your GitLab personal access token.</p> </li> <li> <p><code>OPENAI_KEY</code>: Your OpenAI key.</p> </li> </ul> <p>Note that if your base branches are not protected, don't set the variables as <code>protected</code>, since the pipeline will not have access to them.</p> <p>Note: The <code>$CI_SERVER_FQDN</code> variable is available starting from GitLab version 16.10. If you're using an earlier version, this variable will not be available. However, you can combine <code>$CI_SERVER_HOST</code> and <code>$CI_SERVER_PORT</code> to achieve the same result. Please ensure you're using a compatible version or adjust your configuration.</p> <p>Note: The <code>gitlab__SSL_VERIFY</code> environment variable can be used to specify the path to a custom CA certificate bundle for SSL verification. GitLab exposes the <code>$CI_SERVER_TLS_CA_FILE</code> variable, which points to the custom CA certificate file configured in your GitLab instance. Alternatively, SSL verification can be disabled entirely by setting <code>gitlab__SSL_VERIFY=false</code>, although this is not recommended.</p>"},{"location":"installation/gitlab/#run-a-gitlab-webhook-server","title":"Run a GitLab webhook server","text":"<ol> <li> <p>In GitLab create a new user and give it \"Reporter\" role (\"Developer\" if using Pro version of the agent) for the intended group or project.</p> </li> <li> <p>For the user from step 1, generate a <code>personal_access_token</code> with <code>api</code> access.</p> </li> <li> <p>Generate a random secret for your app, and save it for later (<code>shared_secret</code>). For example, you can use:</p> </li> </ol> <pre><code>SHARED_SECRET=$(python -c \"import secrets; print(secrets.token_hex(10))\")\n</code></pre> <ol> <li>Clone this repository:</li> </ol> <pre><code>git clone https://github.com/qodo-ai/pr-agent.git\n</code></pre> <ol> <li> <p>Prepare variables and secrets. Skip this step if you plan on setting these as environment variables when running the agent:</p> <ol> <li> <p>In the configuration file/variables:</p> <ul> <li>Set <code>config.git_provider</code> to \"gitlab\"</li> </ul> </li> <li> <p>In the secrets file/variables:</p> <ul> <li>Set your AI model key in the respective section</li> <li>In the [gitlab] section, set <code>personal_access_token</code> (with token from step 2) and <code>shared_secret</code> (with secret from step 3)</li> <li>Authentication type: Set <code>auth_type</code> to <code>\"private_token\"</code> for older GitLab versions (e.g., 11.x) or private deployments. Default is <code>\"oauth_token\"</code> for gitlab.com and newer versions.</li> </ul> </li> </ol> </li> <li> <p>Build a Docker image for the app and optionally push it to a Docker repository. We'll use Dockerhub as an example:</p> </li> </ol> <pre><code>docker build . -t gitlab_pr_agent --target gitlab_webhook -f docker/Dockerfile\ndocker push codiumai/pr-agent:gitlab_webhook  # Push to your Docker repository\n</code></pre> <ol> <li>Set the environmental variables, the method depends on your docker runtime. Skip this step if you included your secrets/configuration directly in the Docker image.</li> </ol> <pre><code>CONFIG__GIT_PROVIDER=gitlab\nGITLAB__PERSONAL_ACCESS_TOKEN=&lt;personal_access_token&gt;\nGITLAB__SHARED_SECRET=&lt;shared_secret&gt;\nGITLAB__URL=https://gitlab.com\nGITLAB__AUTH_TYPE=oauth_token  # Use \"private_token\" for older GitLab versions\nOPENAI__KEY=&lt;your_openai_api_key&gt;\n</code></pre> <ol> <li> <p>Create a webhook in your GitLab project. Set the URL to <code>http[s]://&lt;PR_AGENT_HOSTNAME&gt;/webhook</code>, the secret token to the generated secret from step 3, and enable the triggers <code>push</code>, <code>comments</code> and <code>merge request events</code>.</p> </li> <li> <p>Test your installation by opening a merge request or commenting on a merge request using one of PR Agent's commands.</p> </li> </ol>"},{"location":"installation/gitlab/#deploy-as-a-lambda-function","title":"Deploy as a Lambda Function","text":"<p>Note that since AWS Lambda env vars cannot have \".\" in the name, you can replace each \".\" in an env variable with \"__\". For example: <code>GITLAB.PERSONAL_ACCESS_TOKEN</code> --&gt; <code>GITLAB__PERSONAL_ACCESS_TOKEN</code></p> <ol> <li>Follow steps 1-5 from Run a GitLab webhook server.</li> <li> <p>Build a docker image that can be used as a lambda function</p> <p><code>shell docker buildx build --platform=linux/amd64 . -t codiumai/pr-agent:gitlab_lambda --target gitlab_lambda -f docker/Dockerfile.lambda</code></p> </li> <li> <p>Push image to ECR</p> <pre><code>docker tag codiumai/pr-agent:gitlab_lambda &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:gitlab_lambda\ndocker push &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:gitlab_lambda\n</code></pre> </li> <li> <p>Create a lambda function that uses the uploaded image. Set the lambda timeout to be at least 3m.</p> </li> <li>Configure the lambda function to have a Function URL.</li> <li>In the environment variables of the Lambda function, specify <code>AZURE_DEVOPS_CACHE_DIR</code> to a writable location such as /tmp. (see link)</li> <li>Go back to steps 8-9 of Run a GitLab webhook server with the function URL as your Webhook URL.     The Webhook URL would look like <code>https://&lt;LAMBDA_FUNCTION_URL&gt;/webhook</code></li> </ol>"},{"location":"installation/gitlab/#using-aws-secrets-manager","title":"Using AWS Secrets Manager","text":"<p>For production Lambda deployments, use AWS Secrets Manager instead of environment variables:</p> <ol> <li>Create individual secrets for each GitLab webhook with this JSON format (e.g., secret name: <code>project-webhook-secret-001</code>)</li> </ol> <pre><code>{\n  \"gitlab_token\": \"glpat-xxxxxxxxxxxxxxxxxxxxxxxx\",\n  \"token_name\": \"project-webhook-001\"\n}\n</code></pre> <ol> <li>Create a main configuration secret for common settings (e.g., secret name: <code>pr-agent-main-config</code>)</li> </ol> <pre><code>{\n  \"openai.key\": \"sk-proj-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n}\n</code></pre> <ol> <li>Set these environment variables in your Lambda:</li> </ol> <pre><code>CONFIG__SECRET_PROVIDER=aws_secrets_manager\nAWS_SECRETS_MANAGER__SECRET_ARN=arn:aws:secretsmanager:us-east-1:123456789012:secret:pr-agent-main-config-AbCdEf\n</code></pre> <ol> <li>In your GitLab webhook configuration, set the Secret Token to the Secret name created in step 1:</li> <li>Example: <code>project-webhook-secret-001</code></li> </ol> <p>Important: When using Secrets Manager, GitLab's webhook secret must be the Secrets Manager secret name.</p> <ol> <li>Add IAM permission <code>secretsmanager:GetSecretValue</code> to your Lambda execution role</li> </ol>"},{"location":"installation/locally/","title":"Locally","text":"<p>To run PR-Agent locally, you first need to acquire two keys:</p> <ol> <li>An OpenAI key from here, with access to GPT-4 and o4-mini (or a key for other language models, if you prefer).</li> <li>A personal access token from your Git platform (GitHub, GitLab, BitBucket,Gitea) with repo scope. GitHub token, for example, can be issued from here</li> </ol>"},{"location":"installation/locally/#using-docker-image","title":"Using Docker image","text":"<p>A list of the relevant tools can be found in the tools guide.</p> <p>To invoke a tool (for example <code>review</code>), you can run PR-Agent directly from the Docker image. Here's how:</p> <ul> <li> <p>For GitHub:</p> <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your_openai_key&gt; -e GITHUB.USER_TOKEN=&lt;your_github_token&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre> <p>If you are using GitHub enterprise server, you need to specify the custom url as variable. For example, if your GitHub server is at <code>https://github.mycompany.com</code>, add the following to the command:</p> <pre><code>-e GITHUB.BASE_URL=https://github.mycompany.com/api/v3\n</code></pre> </li> <li> <p>For GitLab:</p> <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e CONFIG.GIT_PROVIDER=gitlab -e GITLAB.PERSONAL_ACCESS_TOKEN=&lt;your token&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre> <p>If you have a dedicated GitLab instance, you need to specify the custom url as variable:</p> <pre><code>-e GITLAB.URL=&lt;your gitlab instance url&gt;\n</code></pre> </li> <li> <p>For BitBucket:</p> <pre><code>docker run --rm -it -e CONFIG.GIT_PROVIDER=bitbucket -e OPENAI.KEY=$OPENAI_API_KEY -e BITBUCKET.BEARER_TOKEN=$BITBUCKET_BEARER_TOKEN codiumai/pr-agent:latest --pr_url=&lt;pr_url&gt; review\n</code></pre> </li> <li> <p>For Gitea:</p> <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e CONFIG.GIT_PROVIDER=gitea -e GITEA.PERSONAL_ACCESS_TOKEN=&lt;your token&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre> <p>If you have a dedicated Gitea instance, you need to specify the custom url as variable:</p> <pre><code>-e GITEA.URL=&lt;your gitea instance url&gt;\n</code></pre> </li> </ul> <p>For other git providers, update <code>CONFIG.GIT_PROVIDER</code> accordingly and check the <code>pr_agent/settings/.secrets_template.toml</code> file for environment variables expected names and values.</p>"},{"location":"installation/locally/#utilizing-environment-variables","title":"Utilizing environment variables","text":"<p>It is also possible to provide or override the configuration by setting the corresponding environment variables. You can define the corresponding environment variables by following this convention: <code>&lt;TABLE&gt;__&lt;KEY&gt;=&lt;VALUE&gt;</code> or <code>&lt;TABLE&gt;.&lt;KEY&gt;=&lt;VALUE&gt;</code>. The <code>&lt;TABLE&gt;</code> refers to a table/section in a configuration file and <code>&lt;KEY&gt;=&lt;VALUE&gt;</code> refers to the key/value pair of a setting in the configuration file.</p> <p>For example, suppose you want to run <code>pr_agent</code> that connects to a self-hosted GitLab instance similar to an example above. You can define the environment variables in a plain text file named <code>.env</code> with the following content:</p> <pre><code>CONFIG__GIT_PROVIDER=\"gitlab\"\nGITLAB__URL=\"&lt;your url&gt;\"\nGITLAB__PERSONAL_ACCESS_TOKEN=\"&lt;your token&gt;\"\nOPENAI__KEY=\"&lt;your key&gt;\"\n</code></pre> <p>Then, you can run <code>pr_agent</code> using Docker with the following command:</p> <pre><code>docker run --rm -it --env-file .env codiumai/pr-agent:latest &lt;tool&gt; &lt;tool parameter&gt;\n</code></pre>"},{"location":"installation/locally/#i-get-an-error-when-running-the-docker-image-what-should-i-do","title":"I get an error when running the Docker image. What should I do?","text":"<p>If you encounter an error when running the Docker image, it is almost always due to a misconfiguration of api keys or tokens.</p> <p>Note that litellm, which is used by pr-agent, sometimes returns non-informative error messages such as <code>APIError: OpenAIException - Connection error.</code> Carefully check the api keys and tokens you provided and make sure they are correct. Adjustments may be needed depending on your llm provider.</p> <p>For example, for Azure OpenAI, additional keys are needed. Same goes for other providers, make sure to check the documentation</p>"},{"location":"installation/locally/#using-pip-package","title":"Using pip package","text":"<p>Install the package:</p> <pre><code>pip install pr-agent\n</code></pre> <p>Then run the relevant tool with the script below.  Make sure to fill in the required parameters (<code>user_token</code>, <code>openai_key</code>, <code>pr_url</code>, <code>command</code>):</p> <pre><code>from pr_agent import cli\nfrom pr_agent.config_loader import get_settings\n\ndef main():\n    # Fill in the following values\n    provider = \"github\" # github/gitlab/bitbucket/azure_devops\n    user_token = \"...\"  #  user token\n    openai_key = \"...\"  # OpenAI key\n    pr_url = \"...\"      # PR URL, for example 'https://github.com/Codium-ai/pr-agent/pull/809'\n    command = \"/review\" # Command to run (e.g. '/review', '/describe', '/ask=\"What is the purpose of this PR?\"', ...)\n\n    # Setting the configurations\n    get_settings().set(\"CONFIG.git_provider\", provider)\n    get_settings().set(\"openai.key\", openai_key)\n    get_settings().set(\"github.user_token\", user_token)\n\n    # Run the command. Feedback will appear in GitHub PR comments\n    cli.run_command(pr_url, command)\n\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"installation/locally/#run-from-source","title":"Run from source","text":"<ol> <li>Clone this repository:</li> </ol> <pre><code>git clone https://github.com/Codium-ai/pr-agent.git\n</code></pre> <ol> <li>Navigate to the <code>/pr-agent</code> folder and install the requirements in your favorite virtual environment:</li> </ol> <pre><code>pip install -e .\n</code></pre> <p>Note: If you get an error related to Rust in the dependency installation then make sure Rust is installed and in your <code>PATH</code>, instructions: https://rustup.rs</p> <ol> <li>Copy the secrets template file and fill in your OpenAI key and your GitHub user token:</li> </ol> <pre><code>cp pr_agent/settings/.secrets_template.toml pr_agent/settings/.secrets.toml\nchmod 600 pr_agent/settings/.secrets.toml\n# Edit .secrets.toml file\n</code></pre> <ol> <li>Run the cli.py script:</li> </ol> <pre><code>python3 -m pr_agent.cli --pr_url &lt;pr_url&gt; review\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; ask &lt;your question&gt;\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; describe\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; improve\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; add_docs\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; generate_labels\npython3 -m pr_agent.cli --issue_url &lt;issue_url&gt; similar_issue\n...\n</code></pre> <p>[Optional] Add the pr_agent folder to your PYTHONPATH</p> <pre><code>export PYTHONPATH=$PYTHONPATH:&lt;PATH to pr_agent folder&gt;\n</code></pre>"},{"location":"installation/pr_agent/","title":"PR-Agent","text":""},{"location":"installation/pr_agent/#pr-agent-installation-guide","title":"PR-Agent Installation Guide","text":"<p>PR-Agent can be deployed in various environments and platforms. Choose the installation method that best suits your needs:</p>"},{"location":"installation/pr_agent/#local-installation","title":"\ud83d\udda5\ufe0f Local Installation","text":"<p>Learn how to run PR-Agent locally using:</p> <ul> <li>Docker image</li> <li>pip package</li> <li>CLI from source code</li> </ul> <p>View Local Installation Guide \u2192</p>"},{"location":"installation/pr_agent/#github-integration","title":"\ud83d\udc19 GitHub Integration","text":"<p>Set up PR-Agent with GitHub as:</p> <ul> <li>GitHub Action</li> <li>Local GitHub App</li> </ul> <p>View GitHub Integration Guide \u2192</p>"},{"location":"installation/pr_agent/#gitlab-integration","title":"\ud83e\udd8a GitLab Integration","text":"<p>Deploy PR-Agent on GitLab as:</p> <ul> <li>GitLab pipeline job</li> <li>Local GitLab webhook server</li> </ul> <p>View GitLab Integration Guide \u2192</p>"},{"location":"installation/pr_agent/#bitbucket-integration","title":"\ud83d\udfe6 BitBucket Integration","text":"<p>Implement PR-Agent in BitBucket as:</p> <ul> <li>BitBucket pipeline job</li> <li>Local BitBucket server</li> </ul> <p>View BitBucket Integration Guide \u2192</p>"},{"location":"installation/pr_agent/#azure-devops-integration","title":"\ud83d\udd37  Azure DevOps Integration","text":"<p>Configure PR-Agent with Azure DevOps as:</p> <ul> <li>Azure DevOps pipeline job</li> <li>Local Azure DevOps webhook</li> </ul> <p>View Azure DevOps Integration Guide \u2192</p>"},{"location":"installation/qodo_merge/","title":"\ud83d\udc8e Qodo Merge","text":"<p>Qodo Merge is a versatile application compatible with GitHub, GitLab, and BitBucket, hosted by QodoAI. See here for more details about the benefits of using Qodo Merge.</p>"},{"location":"installation/qodo_merge/#usage-and-licensing","title":"Usage and Licensing","text":""},{"location":"installation/qodo_merge/#cloud-users","title":"Cloud Users","text":"<p>Non-paying users will enjoy feedback on up to 75 PRs per git organization per month. Above this limit, PRs will not receive feedback until a new month begins. </p> <p>For unlimited access, user licenses (seats) are required. Each user requires an individual seat license. After purchasing seats, the team owner can assign them to specific users through the management portal.</p> <p>With an assigned seat, users can seamlessly deploy the application across any of their code repositories in a git organization, and receive feedback on all their PRs.</p>"},{"location":"installation/qodo_merge/#enterprise-account","title":"Enterprise Account","text":"<p>For companies who require an Enterprise account, please contact us to initiate a trial period, and to discuss pricing and licensing options.</p>"},{"location":"installation/qodo_merge/#install-qodo-merge-for-github","title":"Install Qodo Merge for GitHub","text":""},{"location":"installation/qodo_merge/#github-cloud","title":"GitHub Cloud","text":"<p>Qodo Merge for GitHub cloud is available for installation through the GitHub Marketplace.</p> <p></p>"},{"location":"installation/qodo_merge/#github-enterprise-server","title":"GitHub Enterprise Server","text":"<p>To use Qodo Merge on your private GitHub Enterprise Server, you will need to contact Qodo for starting an Enterprise trial.</p> <p>(Note: The marketplace app is not compatible with GitHub Enterprise Server. Installation requires creating a private GitHub App instead.)</p>"},{"location":"installation/qodo_merge/#github-open-source-projects","title":"GitHub Open Source Projects","text":"<p>For open-source projects, Qodo Merge is available for free usage. To install Qodo Merge for your open-source repositories, use the following marketplace link.</p>"},{"location":"installation/qodo_merge/#install-qodo-merge-for-bitbucket","title":"Install Qodo Merge for Bitbucket","text":""},{"location":"installation/qodo_merge/#bitbucket-cloud","title":"Bitbucket Cloud","text":"<p>Qodo Merge for Bitbucket Cloud is available for installation through the following link</p> <p></p>"},{"location":"installation/qodo_merge/#bitbucket-server","title":"Bitbucket Server","text":"<p>To use Qodo Merge application on your private Bitbucket Server, you will need to contact us for starting an Enterprise trial.</p>"},{"location":"installation/qodo_merge/#install-qodo-merge-for-gitlab","title":"Install Qodo Merge for GitLab","text":""},{"location":"installation/qodo_merge/#gitlab-cloud","title":"GitLab Cloud","text":"<p>Installing Qodo Merge for GitLab uses GitLab's OAuth 2.0 application system and requires the following steps:</p>"},{"location":"installation/qodo_merge/#step-1-create-a-gitlab-oauth-20-application","title":"Step 1: Create a GitLab OAuth 2.0 Application","text":"<p>Create a new OAuth 2.0 application in your GitLab instance:</p> <ol> <li>Navigate to your GitLab group or subgroup settings</li> <li>Go to \"Applications\" in the left sidebar</li> <li>Click on \"Add new application\"</li> <li>Fill in the application details:</li> <li>Name: You can give any name you wish (e.g., \"Qodo Merge\")</li> <li>Redirect URI: <code>https://register.oauth.app.gitlab.merge.qodo.ai/oauth/callback</code></li> <li>Confidential: Check this checkbox</li> <li> <p>Scopes: Check the \"api\" scope</p> <p></p> <p></p> </li> <li> <p>Click \"Save application\"</p> </li> <li>Copy both the Application ID and Secret - store them safely as you'll need them for the next step</li> </ol>"},{"location":"installation/qodo_merge/#step-2-register-your-oauth-application","title":"Step 2: Register Your OAuth Application","text":"<ol> <li>Browse to: https://register.oauth.app.gitlab.merge.qodo.ai</li> <li>Fill in the registration form:</li> <li>Host Address: Leave empty if using gitlab.com (for self-hosted GitLab servers, enter your GitLab base URL including scheme (e.g., https://gitlab.mycorp-inc.com) without trailing slash. Do not include paths or query strings.</li> <li>OAuth Application ID: Enter the Application ID from Step 1</li> <li> <p>OAuth Application Secret: Enter the Secret from Step 1 </p> <p></p> <p></p> </li> <li> <p>Click \"Submit\"</p> </li> </ol>"},{"location":"installation/qodo_merge/#step-3-authorize-the-oauth-application","title":"Step 3: Authorize the OAuth Application","text":"<p>If all fields show green checkmarks, a redirect popup from GitLab will appear requesting authorization for the OAuth app to access the \"api\" scope. Click \"Authorize\" to approve the application.</p>"},{"location":"installation/qodo_merge/#step-4-copy-the-webhook-secret-token","title":"Step 4: Copy the Webhook Secret Token","text":"<p>If the authorization is successful, a message will appear displaying a generated webhook secret token. Copy this token and store it safely - you'll need it for the next step.</p>"},{"location":"installation/qodo_merge/#step-5-install-webhooks","title":"Step 5: Install Webhooks","text":"<p>Install a webhook for your repository or groups by following these steps:</p> <ol> <li>Navigate to your repository or group settings</li> <li>Click \"Webhooks\" in the settings menu</li> <li> <p>Click the \"Add new webhook\" button</p> <p></p> <p></p> </li> <li> <p>In the webhook definition form, fill in the following fields:</p> </li> <li>URL: <code>https://pro.gitlab.pr-agent.codium.ai/webhook</code></li> <li>Secret token: The webhook secret token generated in Step 4</li> <li>Trigger: Check the 'Comments' and 'Merge request events' boxes</li> <li> <p>Enable SSL verification: Check this box</p> <p></p> <p></p> </li> <li> <p>Click \"Add webhook\"</p> </li> </ol> <p>Note: Repeat this webhook installation for each group or repository that is under the group or subgroup where the OAuth 2.0 application was created in Step 1.</p>"},{"location":"installation/qodo_merge/#step-6-youre-all-set","title":"Step 6: You\u2019re all set!","text":"<p>Open a new merge request or add a MR comment with one of Qodo Merge\u2019s commands such as /review, /describe or /improve.</p>"},{"location":"installation/qodo_merge/#gitlab-server","title":"GitLab Server","text":"<p>For limited free usage on private GitLab Server, the same installation steps as for GitLab Cloud apply, aside from the Host Address field mentioned in Step 2 (where you fill in the hostname for your GitLab server, such as: https://gitlab.mycorp-inc.com). For unlimited usage, you will need to contact Qodo for moving to an Enterprise account.</p>"},{"location":"overview/data_privacy/","title":"Data Privacy","text":""},{"location":"overview/data_privacy/#self-hosted-pr-agent","title":"Self-hosted PR-Agent","text":"<ul> <li>If you self-host PR-Agent with your OpenAI (or other LLM provider) API key, it is between you and the provider. We don't send your code data to Qodo servers.</li> </ul>"},{"location":"overview/data_privacy/#qodo-merge","title":"Qodo Merge \ud83d\udc8e","text":"<ul> <li> <p>When using Qodo Merge\ud83d\udc8e, hosted by Qodo, we will not store any of your data, nor will we use it for training. You will also benefit from an OpenAI account with zero data retention.</p> </li> <li> <p>For certain clients, Qodo Merge will use Qodo\u2019s proprietary models. If this is the case, you will be notified.</p> </li> <li> <p>No passive collection of Code and Pull Requests\u2019 data \u2014 Qodo Merge will be active only when you invoke it, and it will then extract and analyze only data relevant to the executed command and queried pull request.</p> </li> </ul>"},{"location":"overview/data_privacy/#qodo-merge-chrome-extension","title":"Qodo Merge Chrome extension","text":"<ul> <li>The Qodo Merge Chrome extension will not send your code to any external servers.</li> </ul>"},{"location":"overview/pr_agent_pro/","title":"\ud83d\udc8e Qodo Merge","text":""},{"location":"overview/pr_agent_pro/#overview","title":"Overview","text":"<p>Qodo Merge is a hosted version of the open-source PR-Agent.  It is designed for companies and teams that require additional features and capabilities.</p> <p>Free users receive a quota of 75 monthly PR feedbacks per git organization. Unlimited usage requires a paid subscription. See details.</p> <p>Qodo Merge provides the following benefits:</p> <ol> <li> <p>Fully managed - We take care of everything for you - hosting, models, regular updates, and more. Installation is as simple as signing up and adding the Qodo Merge app to your GitHub\\GitLab\\BitBucket repo.</p> </li> <li> <p>Improved privacy - No data will be stored or used to train models. Qodo Merge will employ zero data retention, and will use an OpenAI and Claude accounts with zero data retention.</p> </li> <li> <p>Improved support - Qodo Merge users will receive priority support, and will be able to request new features and capabilities.</p> </li> <li> <p>Supporting self-hosted git servers - Qodo Merge can be installed on GitHub Enterprise Server, GitLab, and BitBucket. For more information, see the installation guide.</p> </li> <li> <p>PR Chat - Qodo Merge allows you to engage in private chat about your pull requests on private repositories.</p> </li> </ol>"},{"location":"overview/pr_agent_pro/#additional-features","title":"Additional features","text":"<p>Here are some of the additional features and capabilities that Qodo Merge offers, and are not available in the open-source version of PR-Agent:</p> Feature Description Model selection Choose the model that best fits your needs Global and wiki configuration Control configurations for many repositories from a single location; Edit configuration of a single repo without committing code Apply suggestions Generate committable code from the relevant suggestions interactively by clicking on a checkbox Suggestions impact Automatically mark suggestions that were implemented by the user (either directly in GitHub, or indirectly in the IDE) to enable tracking of the impact of the suggestions CI feedback Automatically analyze failed CI checks on GitHub and provide actionable feedback in the PR conversation, helping to resolve issues quickly Advanced usage statistics Qodo Merge offers detailed statistics at user, repository, and company levels, including metrics about Qodo Merge usage, and also general statistics and insights Incorporating companies' best practices Use the companies' best practices as reference to increase the effectiveness and the relevance of the code suggestions Interactive triggering Interactively apply different tools via the <code>analyze</code> command Custom labels Define custom labels for Qodo Merge to assign to the PR"},{"location":"overview/pr_agent_pro/#additional-tools","title":"Additional tools","text":"<p>Here are additional tools that are available only for Qodo Merge users:</p> Feature Description Custom Prompt Suggestions Generate code suggestions based on custom prompts from the user Analyze PR components Identify the components that changed in the PR, and enable to interactively apply different tools to them Tests Generate tests for code components that changed in the PR PR documentation Generate docstring for code components that changed in the PR Improve Component Generate code suggestions for code components that changed in the PR Similar code search Search for similar code in the repository, organization, or entire GitHub Code implementation Generates implementation code from review suggestions"},{"location":"overview/pr_agent_pro/#supported-languages","title":"Supported languages","text":"<p>Qodo Merge leverages the world's leading code models, such as Claude 4 Sonnet, o4-mini and Gemini-2.5-Pro. As a result, its primary tools such as <code>describe</code>, <code>review</code>, and <code>improve</code>, as well as the PR-chat feature, support virtually all programming languages.</p> <p>For specialized commands that require static code analysis, Qodo Merge offers support for specific languages. For more details about features that require static code analysis, please refer to the documentation.</p>"},{"location":"pr_benchmark/","title":"PR Benchmark","text":""},{"location":"pr_benchmark/#qodo-merge-pull-request-benchmark","title":"Qodo Merge Pull Request Benchmark","text":""},{"location":"pr_benchmark/#methodology","title":"Methodology","text":"<p>Qodo Merge PR Benchmark evaluates and compares the performance of Large Language Models (LLMs) in analyzing pull request code and providing meaningful code suggestions. Our diverse dataset contains 400 pull requests from over 100 repositories, spanning multiple programming languages to reflect real-world scenarios.</p> <ul> <li> <p>For each pull request, we have pre-generated suggestions from eleven different top-performing models using the Qodo Merge <code>improve</code> tool. The prompt for response generation can be found here. </p> </li> <li> <p>To benchmark a model, we generate its suggestions for the same pull requests and ask a high-performing judge model to rank the new model's output against the pre-generated baseline suggestions. We utilize OpenAI's <code>o3</code> model as the judge, though other models have yielded consistent results. The prompt for this ranking judgment is available here.</p> </li> <li> <p>We aggregate ranking outcomes across all pull requests, calculating performance metrics for the evaluated model. </p> </li> <li> <p>We also analyze the qualitative feedback from the judge to identify the model's comparative strengths and weaknesses against the established baselines. This approach provides not just a quantitative score but also a detailed analysis of each model's strengths and weaknesses.</p> </li> </ul> <p>A list of the models used for generating the baseline suggestions, and example results, can be found in the Appendix.</p>"},{"location":"pr_benchmark/#pr-benchmark-results","title":"PR Benchmark Results","text":"Model Name Version (Date) Thinking budget tokens Score GPT-5-pro 2025-10-06 73.4 GPT-5 2025-08-07 medium 72.2 GPT-5 2025-08-07 low 67.8 GPT-5 2025-08-07 minimal 62.7 o3 2025-04-16 'medium' (8000) 62.5 o4-mini 2025-04-16 'medium' (8000) 57.7 Gemini-2.5-pro 2025-06-05 4096 56.3 Claude-haiku-4.5 2025-10-01 4096 48.8 Gemini-2.5-pro 2025-06-05 1024 44.3 Claude-sonnet-4.5 2025-09-29 4096 44.2 Claude-haiku-4.5 2025-10-01 40.7 Claude-sonnet-4.5 2025-09-29 40.7 Claude-4-sonnet 2025-05-14 4096 39.7 Claude-4-sonnet 2025-05-14 39.0 Codex-mini 2025-06-20 unknown 37.2 Gemini-2.5-flash 2025-04-17 33.5 Grok-4 2025-07-09 unknown 32.8 Claude-4-opus-20250514 2025-05-14 32.8 Claude-3.7-sonnet 2025-02-19 32.4 GPT-4.1 2025-04-14 26.5"},{"location":"pr_benchmark/#results-analysis","title":"Results Analysis","text":""},{"location":"pr_benchmark/#gpt-5-pro","title":"GPT-5-pro","text":"<p>Final score: 73.4</p> <p>Strengths:</p> <ul> <li>High bug\u2010finding accuracy and depth: In many cases the model uncovers the core compile-time or run-time regression that other answers miss and frequently combines several distinct critical issues into one reply.</li> <li>Actionable, minimal patches: Suggestions almost always include clear before/after code blocks that touch only the added lines and respect the \u22643-suggestion limit, making them easy to apply.</li> <li>Good guideline compliance: The model generally honours the task rules\u2014no edits to unchanged code, no version bumps, no more than three items\u2014and shows solid judgment about when an empty list is appropriate.</li> <li>Concise, impact-oriented reasoning: Explanations focus on severity, crash potential and build breakage rather than style, helping reviewers prioritise fixes.</li> </ul> <p>Weaknesses:</p> <ul> <li>Coverage gaps: In a noticeable minority of examples the model misses a higher-impact defect that several other answers catch, or returns an empty list despite clear bugs.</li> <li>Occasional incorrect or harmful fixes: A few replies introduce new errors or rest on wrong assumptions about functionality or language-specific behavior.</li> <li>Formatting / guideline slips: Sporadic duplication of suggestions, missing or empty <code>improved_code</code> blocks, or YAML mishaps undermine otherwise good answers.</li> <li>Uneven criticality judgement: Some suggestions drift into low-impact territory while overlooking more severe problems, indicating inconsistent prioritisation.</li> </ul>"},{"location":"pr_benchmark/#o3","title":"O3","text":"<p>Final score: 62.5</p> <p>Strengths:</p> <ul> <li>High precision &amp; compliance: Generally respects task rules (limits, \u201cadded lines\u201d scope, YAML schema) and avoids false-positive advice, often returning an empty list when appropriate.  </li> <li>Clear, actionable output: Suggestions are concise, well-explained and include correct before/after patches, so reviewers can apply them directly.  </li> <li>Good critical-bug detection rate: Frequently spots compile-breakers or obvious runtime faults (nil / NPE, overflow, race, wrong selector, etc.), putting it at least on par with many peers.  </li> <li>Consistent formatting: Produces syntactically valid YAML with correct labels, making automated consumption easy.</li> </ul> <p>Weaknesses:</p> <ul> <li>Narrow coverage: Tends to stop after 1-2 issues; regularly misses additional critical defects that better answers catch, so it is seldom the top-ranked review.  </li> <li>Occasional inaccuracies: A few replies introduce new bugs, give partial/duplicate fixes, or (rarely) violate rules (e.g., import suggestions), hurting trust.  </li> <li>Conservative bias: Prefers silence over risk; while this keeps precision high, it lowers recall and overall usefulness on larger diffs.  </li> <li>Little added insight: Rarely offers broader context, optimisations or holistic improvements, causing it to rank only mid-tier in many comparisons.</li> </ul>"},{"location":"pr_benchmark/#o4-mini-medium-thinking-tokens","title":"O4 Mini ('medium' thinking tokens)","text":"<p>Final score: 57.7</p> <p>Strengths:</p> <ul> <li>Good rule adherence: Most answers respect the \u201cnew-lines only\u201d, 3-suggestion, and YAML-schema limits, and frequently choose the safe empty list when the diff truly adds no critical bug.</li> <li>Clear, minimal patches: When the model does spot a defect it usually supplies terse, valid before/after snippets and short, targeted explanations, making fixes easy to read and apply.</li> <li>Language &amp; domain breadth: Demonstrates competence across many ecosystems (C/C++, Java, TS/JS, Go, Rust, Python, Bash, Markdown, YAML, SQL, CSS, translation files, etc.) and can detect both compile-time and runtime mistakes.</li> <li>Often competitive: In a sizeable minority of cases the model ties for best or near-best answer, occasionally being the only response to catch a subtle crash or build blocker.</li> </ul> <p>Weaknesses:</p> <ul> <li>High miss rate: A large share of examples show the model returning an empty list or only minor advice while other reviewers catch clear, high-impact bugs\u2014indicative of weak defect-detection recall.</li> <li>False or harmful fixes: Several answers introduce new compilation errors, propose out-of-scope changes, or violate explicit rules (e.g., adding imports, version bumps, touching untouched lines), reducing trustworthiness.</li> <li>Shallow coverage: Even when it identifies one real issue it often stops there, missing additional critical problems found by stronger peers; breadth and depth are inconsistent.</li> </ul>"},{"location":"pr_benchmark/#gemini-25-pro-4096-thinking-tokens","title":"Gemini-2.5 Pro (4096 thinking tokens)","text":"<p>Final score: 56.3</p> <p>Strengths:</p> <ul> <li>High formatting compliance: The model almost always produces valid YAML, respects the three-suggestion limit, and supplies clear before/after code snippets and short rationales.</li> <li>Good \u201cfirst-bug\u201d detection: It frequently notices the single most obvious regression (crash, compile error, nil/NPE risk, wrong path, etc.) and gives a minimal, correct patch\u2014often judged \u201con-par\u201d with other solid answers.</li> <li>Clear, concise writing: Explanations are brief yet understandable for reviewers; fixes are scoped to the changed lines and rarely include extraneous context.</li> <li>Low rate of harmful fixes: Truly dangerous or build-breaking advice is rare; most mistakes are omissions rather than wrong code.</li> </ul> <p>Weaknesses:</p> <ul> <li>Limited breadth of review: The model regularly stops after the first or second issue, missing additional critical problems that stronger answers surface, so it is often out-ranked by more comprehensive peers.</li> <li>Occasional guideline violations: A noticeable minority of answers touch unchanged lines, exceed the 3-item cap, suggest adding imports, or drop the required YAML wrapper, leading to automatic downgrades.</li> <li>False positives / speculative fixes: In several cases it flags non-issues (style, performance, redundant code) or supplies debatable \u201cimprovements\u201d, lowering precision and sometimes breaching the \u201ccritical bugs only\u201d rule.</li> <li>Inconsistent error coverage: For certain domains (build scripts, schema files, test code) it either returns an empty list when real regressions exist or proposes cosmetic edits, indicating gaps in specialised knowledge.</li> </ul>"},{"location":"pr_benchmark/#claude-haiku-45-4096-thinking-tokens","title":"Claude-haiku-4.5 (4096 thinking tokens)","text":"<p>Final score: 48.8</p> <p>Strengths:</p> <ul> <li>High precision on detected issues: When the model does flag a problem it is usually a real, high-impact bug; many answers are judged equal or better than strong baselines because the proposed fix is correct, minimal and easy to apply.</li> <li>Language- and domain-agnostic competence: It successfully diagnoses defects across a wide range of languages (Python, Go, C/C++, Rust, JS/TS, CSS, SQL, Markdown, etc.) and domains (backend logic, build files, tests, docs).</li> <li>Clear, actionable patches: Suggested code is typically concise, well-explained and scoped exactly to the added lines, making it practical for reviewers to adopt.</li> </ul> <p>Weaknesses:</p> <ul> <li>Low recall / narrow coverage: The model often stops after one or two findings, leaving other obvious critical bugs unmentioned; in many examples stronger answers simply covered more ground.</li> <li>Occasional faulty or speculative fixes: A non-trivial number of responses either mis-diagnose the issue or introduce new errors (e.g., wrong logic, undeclared imports), dropping them below baseline quality.</li> <li>Inconsistent output robustness: Several cases show truncated or malformed responses, reducing value despite correct analysis elsewhere.</li> <li>Frequent false negatives: The model sometimes returns an empty list even when clear regressions exist, indicating conservative behaviour that misses mandatory fixes.</li> </ul>"},{"location":"pr_benchmark/#claude-sonnet-45-4096-thinking-tokens","title":"Claude-sonnet-4.5 (4096 thinking tokens)","text":"<p>Final score: 44.2</p> <p>Strengths:</p> <ul> <li>High precision / low noise: When the model does offer fixes they are usually correct, concise and confined to the new '+' lines, rarely introducing spurious or off-scope changes.</li> <li>Clear, actionable patches: Suggestions come with well-explained reasoning and minimal but valid code snippets, making them easy for a reviewer to apply.</li> <li>Good rule compliance: It almost always respects the 1-3 suggestion limit, avoids touching unchanged code and seldom violates formatting or other task guidelines.</li> </ul> <p>Weaknesses:</p> <ul> <li>Low recall / frequent omissions: In a large share of cases the model returns an empty list or only one minor tip while overlooking obvious, higher-impact regressions found by peers.</li> <li>Narrow coverage when it does respond: Even in non-empty outputs it typically fixes a single issue and ignores related defects in the same diff, indicating shallow analysis.</li> <li>Occasional harmful or incomplete fixes: A few suggestions introduce new errors (e.g., wrong logic, missing imports, malformed snippets) or mark non-critical style nits as \"critical\", reducing trust.</li> </ul>"},{"location":"pr_benchmark/#claude-sonnet-45","title":"Claude-sonnet-4.5","text":"<p>Final score: 40.7</p> <p>Strengths:</p> <ul> <li>Concise &amp; well-formatted output: Most replies strictly follow the schema, stay within the 3-suggestion limit, and include clear, copy-paste-ready patches, making them easy to apply.</li> <li>Can spot headline bugs: When a single, obvious regression is present (e.g. duplicated regex block, missing null-check, wrong macro name) the model often detects it and proposes an accurate, minimal fix.</li> <li>Scope discipline (usually): It frequently restricts changes to newly-added lines and avoids broad refactors, so many answers comply with the \u201cnew code only / critical bugs only\u201d rule.</li> <li>Reasonable explanations: The accompanying rationales are typically short but precise, helping reviewers understand why the change is needed.</li> </ul> <p>Weaknesses:</p> <ul> <li>Low recall of critical issues: In a large fraction of examples the model misses the primary bug or flags nothing at all while other reviewers find clear problems. Coverage is therefore unreliable.</li> <li>False or harmful fixes: A notable number of suggestions mis-diagnose the code, touch unchanged lines, violate task rules, or would break compilation/runtime (wrong paths, bad types, guideline-forbidden advice).</li> <li>Priority mistakes: The model often downgrades severe defects to \u201cgeneral\u201d or upgrades cosmetic nits to \u201ccritical\u201d, showing weak bug-severity judgment.</li> <li>Inconsistent quality: Performance swings widely between excellent and poor; reviewers cannot predict whether a given answer will be thorough, partial, or incorrect.</li> </ul>"},{"location":"pr_benchmark/#claude-haiku-45","title":"Claude-haiku-4.5","text":"<p>Final score: 40.7</p> <p>Strengths:</p> <ul> <li>**Good format &amp; clarity: Consistently produces valid YAML and readable, minimally-intrusive patches with clear before/after snippets, so its outputs are easy to apply.</li> <li>**Basic bug-spotting ability: Often detects the most obvious new-line defect (e.g., syntax error, missing guard, wrong constant) and supplies a correct, concise fix; rarely ranks last in the set.</li> <li>**Rule compliance in many cases: Usually stays within the 3-suggestion limit, touches only '+' lines, and avoids speculative refactors\u2014returning an empty list when no code was added.</li> </ul> <p>Weaknesses:</p> <ul> <li>**Shallow coverage: Frequently fixes just one surface-level issue and misses additional, higher-impact bugs that stronger reviewers catch, leaving regressions in place.</li> <li>**Occasional incorrect or no-op patches: A noticeable share of suggestions either leave code unchanged, contain invalid code, or introduce new errors, lowering trust.</li> <li>**Guideline slips: In several examples it edits unchanged lines, adds forbidden imports/version bumps, mis-labels severities, or supplies non-critical stylistic advice.</li> <li>**Inconsistent diligence: Roughly a quarter of the cases return an empty list despite real problems, while others duplicate existing PR changes, indicating weak diff comprehension.</li> </ul>"},{"location":"pr_benchmark/#claude-4-sonnet-4096-thinking-tokens","title":"Claude-4 Sonnet (4096 thinking tokens)","text":"<p>Final score: 39.7</p> <p>Strengths:</p> <ul> <li>High guideline &amp; format compliance: Almost always returns valid YAML, keeps \u2264 3 suggestions, avoids forbidden import/boiler-plate changes and provides clear before/after snippets.</li> <li>Good pinpoint accuracy on single issues: Frequently spots at least one real critical bug and proposes a concise, technically correct fix that compiles/runs.</li> <li>Clarity &amp; brevity of patches: Explanations are short, actionable, and focused on changed lines, making the advice easy for reviewers to apply.</li> </ul> <p>Weaknesses:</p> <ul> <li>Low coverage / recall: Regularly surfaces only one minor issue (or none) while missing other, often more severe, problems caught by peer models.</li> <li>High \"empty-list\" rate: In many diffs the model returns no suggestions even when clear critical bugs exist, offering zero reviewer value.</li> <li>Occasional incorrect or harmful fixes: A non-trivial number of suggestions are speculative, contradict code intent, or would break compilation/runtime; sometimes duplicates or contradicts itself.</li> <li>Inconsistent severity labelling &amp; duplication: Repeats the same point in multiple slots, marks cosmetic edits as \"critical\", or leaves <code>improved_code</code> identical to original.</li> </ul>"},{"location":"pr_benchmark/#claude-4-sonnet","title":"Claude-4 Sonnet","text":"<p>Final score: 39.0</p> <p>Strengths:</p> <ul> <li> <p>Consistently well-formatted &amp; rule-compliant output: Almost every answer follows the required YAML schema, keeps within the 3-suggestion limit, and returns an empty list when no issues are found, showing good instruction following.</p> </li> <li> <p>Actionable, code-level patches: When it does spot a defect the model usually supplies clear, minimal diffs or replacement snippets that compile / run, making the fix easy to apply.</p> </li> <li> <p>Decent hit-rate on \u201cobvious\u201d bugs: The model reliably catches the most blatant syntax errors, null-checks, enum / cast problems, and other first-order issues, so it often ties or slightly beats weaker baseline replies.</p> </li> </ul> <p>Weaknesses:</p> <ul> <li> <p>Shallow coverage: It frequently stops after one easy bug and overlooks additional, equally-critical problems that stronger reviewers find, leaving significant risks unaddressed.</p> </li> <li> <p>False positives &amp; harmful fixes: In a noticeable minority of cases it misdiagnoses code, suggests changes that break compilation or behaviour, or flags non-issues, sometimes making its output worse than doing nothing.</p> </li> <li> <p>Drifts into non-critical or out-of-scope advice: The model regularly proposes style tweaks, documentation edits, or changes to unchanged lines, violating the \"critical new-code only\" requirement.</p> </li> </ul>"},{"location":"pr_benchmark/#openai-codex-mini","title":"OpenAI codex-mini","text":"<p>Final score: 37.2</p> <p>Strengths:</p> <ul> <li>Can spot high-impact defects: When it \"locks on\", codex-mini often identifies the main runtime or security regression (e.g., race-conditions, logic inversions, blocking I/O, resource leaks) and proposes a minimal, direct patch that compiles and respects neighbouring style.</li> <li>Produces concise, scoped fixes: Valid answers usually stay within the allowed 3-suggestion limit, reference only the added lines, and contain clear before/after snippets that reviewers can apply verbatim.</li> <li>Occasional broad coverage: In a minority of cases the model catches multiple independent issues (logic + tests + docs) and outperforms every baseline answer, showing good contextual understanding of heterogeneous diffs.</li> </ul> <p>Weaknesses:</p> <ul> <li>Output instability / format errors: A very large share of responses are unusable\u2014plain refusals, shell commands, or malformed/empty YAML\u2014indicating brittle adherence to the required schema and tanking overall usefulness.</li> <li>Critical-miss rate: Even when the format is correct the model frequently overlooks the single most serious bug the diff introduces, instead focusing on stylistic nits or speculative refactors.</li> <li>Introduces new problems: Several suggestions add unsupported APIs, undeclared variables, wrong types, or break compilation, hurting trust in the recommendations.</li> <li>Rule violations: It often edits lines outside the diff, exceeds the 3-suggestion cap, or labels cosmetic tweaks as \"critical\", showing inconsistent guideline compliance.</li> </ul>"},{"location":"pr_benchmark/#gemini-25-flash","title":"Gemini-2.5 Flash","text":"<p>Final score: 33.5</p> <p>Strengths:</p> <ul> <li>High precision / low false-positive rate: The model often stays silent or gives a single, well-justified fix, so when it does speak the suggestion is usually correct and seldom touches unchanged lines, keeping guideline compliance high.  </li> <li>Good guideline awareness: YAML structure is consistently valid; suggestions rarely exceed the 3-item limit and generally restrict themselves to newly-added lines.  </li> <li>Clear, concise patches: When a defect is found, the model produces short rationales and tidy \u201cimproved_code\u201d blocks that reviewers can apply directly.  </li> <li>Risk-averse behaviour pays off in \u201cno-bug\u201d PRs: In examples where the diff truly contained no critical issue, the model\u2019s empty output ranked above peers that offered speculative or stylistic advice.</li> </ul> <p>Weaknesses:</p> <ul> <li>Very low recall / shallow coverage: In a large majority of cases it gives 0-1 suggestions and misses other evident, critical bugs highlighted by peer models, leading to inferior rankings.  </li> <li>Occasional incorrect or harmful fixes: A noticeable subset of answers propose changes that break functionality or misunderstand the code (e.g. bad constant, wrong header logic, speculative rollbacks).  </li> <li>Non-actionable placeholders: Some \u201cimproved_code\u201d sections contain comments or \u201c\u2026\u201d rather than real patches, reducing practical value.  </li> </ul>"},{"location":"pr_benchmark/#claude-4-opus","title":"Claude-4 Opus","text":"<p>Final score: 32.8</p> <p>Strengths:</p> <ul> <li>Format &amp; rule adherence: Almost always returns valid YAML, stays within the \u22643-suggestion limit, and usually restricts edits to newly-added lines, so its output is easy to apply automatically.</li> <li>Concise, focused patches: When it does find a real bug it gives short, well-scoped explanations plus minimal diff snippets, often outperforming verbose baselines in clarity.</li> <li>Able to catch subtle edge-cases: In several examples it detected overflow, race-condition or enum-mismatch issues that many other models missed, showing solid code\u2010analysis capability.</li> </ul> <p>Weaknesses:</p> <ul> <li>Low recall / narrow coverage: In a large share of the 399 examples the model produced an empty list or only one minor tip while more serious defects were present, causing it to be rated inferior to most baselines.</li> <li>Frequent incorrect or no-op fixes: It sometimes supplies identical \u201cbefore/after\u201d code, flags non-issues, or suggests changes that would break compilation or logic, reducing reviewer trust.</li> <li>Shaky guideline consistency: Although generally compliant, it still occasionally violates rules (touches unchanged lines, offers stylistic advice, adds imports) and duplicates suggestions, indicating unstable internal checks.</li> </ul>"},{"location":"pr_benchmark/#grok-4","title":"Grok-4","text":"<p>Final score: 32.8</p> <p>Strengths:</p> <ul> <li>Focused and concise fixes: When the model does detect a problem it usually proposes a minimal, well-scoped patch that compiles and directly addresses the defect without unnecessary noise.  </li> <li>Good critical-bug instinct: It often prioritises show-stoppers (compile failures, crashes, security issues) over cosmetic matters and occasionally spots subtle issues that all other reviewers miss.  </li> <li>Clear explanations &amp; snippets: Explanations are short, readable and paired with ready-to-paste code, making the advice easy to apply.  </li> </ul> <p>Weaknesses:</p> <ul> <li>High miss rate: In a large fraction of examples the model returned an empty list or covered only one minor issue while overlooking more serious newly-introduced bugs.  </li> <li>Inconsistent accuracy: A noticeable subset of answers contain wrong or even harmful fixes (e.g., removing valid flags, creating compile errors, re-introducing bugs).  </li> <li>Limited breadth: Even when it finds a real defect it rarely reports additional related problems that peers catch, leading to partial reviews.  </li> <li>Occasional guideline slips: A few replies modify unchanged lines, suggest new imports, or duplicate suggestions, showing imperfect compliance with instructions.</li> </ul>"},{"location":"pr_benchmark/#gpt-41","title":"GPT-4.1","text":"<p>Final score: 26.5</p> <p>Strengths:</p> <ul> <li>Consistent format &amp; guideline obedience: Output is almost always valid YAML, within the 3-suggestion limit, and rarely touches lines not prefixed with \"+\".</li> <li>Low false-positive rate: When no real defect exists, the model correctly returns an empty list instead of inventing speculative fixes, avoiding the \"noise\" many baseline answers add.</li> <li>Clear, concise patches when it does act: In the minority of cases where it detects a bug, the fix is usually correct, minimal, and easy to apply.</li> </ul> <p>Weaknesses:</p> <ul> <li>Very low recall / coverage: In a large majority of examples it outputs an empty list or only 1 trivial suggestion while obvious critical issues remain unfixed; it systematically misses circular bugs, null-checks, schema errors, etc.</li> <li>Shallow analysis: Even when it finds one problem it seldom looks deeper, so more severe or additional bugs in the same diff are left unaddressed.</li> <li>Occasional technical inaccuracies: A noticeable subset of suggestions are wrong (mis-ordered assertions, harmful Bash <code>set</code> change, false dangling-reference claims) or carry metadata errors (mis-labeling files as \"python\").</li> <li>Repetitive / derivative fixes: Many outputs duplicate earlier simplistic ideas (e.g., single null-check) without new insight, showing limited reasoning breadth.</li> </ul>"},{"location":"pr_benchmark/#appendix-example-results","title":"Appendix - Example Results","text":"<p>Some examples of benchmarked PRs and their results:</p> <ul> <li>Example 1</li> <li>Example 2</li> <li>Example 3</li> <li>Example 4</li> </ul>"},{"location":"pr_benchmark/#models-used-for-benchmarking","title":"Models Used for Benchmarking","text":"<p>The following models were used for generating the benchmark baseline:</p> <pre><code>(1) anthropic_sonnet_3.7_v1:0\n\n(2) claude-4-opus-20250514\n\n(3) claude-4-sonnet-20250514\n\n(4) claude-4-sonnet-20250514_thinking_2048\n\n(5) gemini-2.5-flash-preview-04-17\n\n(6) gemini-2.5-pro-preview-05-06\n\n(7) gemini-2.5-pro-preview-06-05_1024\n\n(8) gemini-2.5-pro-preview-06-05_4096\n\n(9) gpt-4.1\n\n(10) o3\n\n(11) o4-mini_medium\n</code></pre>"},{"location":"pr_benchmark/#programming-languages","title":"Programming Languages","text":"<p>The PR benchmark dataset includes pull requests containing code in the following programming languages:</p> <pre><code>[\"Python\", \"JavaScript\", \"TypeScript\", \"Java\", \"CSharp\", \"PHP\", \"C++\", \"Go\", \"Rust\", \"Swift\", \"Kotlin\", \"Ruby\", \"Dart\", \"Scala\"\n</code></pre> <p>Pull requests may also include non-code files such as <code>YAML</code>, <code>JSON</code>, <code>Markdown</code>, <code>Dockerfile</code> ,<code>Shell</code>, etc.  The benchmarked models should also analyze these files, as they commonly appear in real-world pull requests.</p>"},{"location":"qodo-merge-cli/","title":"Overview","text":""},{"location":"qodo-merge-cli/#review-and-implement-ai-suggestions-from-your-terminal","title":"Review and Implement AI Suggestions from Your Terminal","text":"<p>Qodo Merge CLI utilizes Qodo Command to bring AI-powered code suggestions directly to your terminal. Review, implement, and manage Qodo Merge suggestions without leaving your development environment.</p> <p></p>"},{"location":"qodo-merge-cli/#mission","title":"Mission","text":"<p>The CLI can bridge the gap between Qodo Merge feedback and code implementation in your local enviroment:</p> <ul> <li>Seamlessly generate and manage PR suggestions without context switching<ul> <li>Remote Suggestions: Fetches Qodo Merge suggestions from your Git Environment</li> <li>Local Suggestions: Get real-time suggestions against your local changes</li> </ul> </li> <li>Interactive review and implementation of AI feedback directly in your terminal</li> <li>Track implementation status of each suggestion (pending/implemented/declined)</li> </ul>"},{"location":"qodo-merge-cli/#remote-suggestions-flow","title":"Remote Suggestions Flow","text":"<ol> <li>Open a Pull Request on your Git environment and receive Qodo Merge feedback</li> <li>Pull the remote suggestions into your terminal with Qodo Merge CLI</li> <li>Explore, Review, and implement suggestions interactively</li> <li>Commit changes back to your branch seamlessly</li> </ol>"},{"location":"qodo-merge-cli/#local-suggestions-flow","title":"Local Suggestions Flow","text":"<p>Work in progress - coming soon!</p>"},{"location":"qodo-merge-cli/#quick-start","title":"Quick Start","text":"<ol> <li>Install Qodo Merge CLI</li> <li>Usage - Navigate, explore, and implement suggestions</li> </ol> <p>Part of the Qodo Merge ecosystem - closing the loop between AI feedback and code implementation.</p>"},{"location":"qodo-merge-cli/installation/","title":"Installation","text":""},{"location":"qodo-merge-cli/installation/#installation","title":"Installation","text":"<p>For remote suggestions, Qodo Merge needs to be installed and active on your Git repository (GitHub / GitLab), and provide code suggestions in a table format for your Pull Requests (PRs).</p>"},{"location":"qodo-merge-cli/installation/#install-qodo-command","title":"Install Qodo Command","text":"<p>Qodo Merge CLI is a review tool within Qodo Command, a command-line interface for running and managing AI agents.</p> <p>To use Qodo Command, you'll need first Node.js and npm installed. Then, to install Qodo Command, run:</p> <pre><code>npm install -g @qodo/command\n</code></pre> <p>Login and Setup</p> <p>To start using Qodo Command, you need to log in first:</p> <pre><code>qodo login\n</code></pre> <p>Once login is completed, you'll receive an API key in the terminal. The API key is also saved locally in the .qodo folder in your home directory, and can be reused (e.g., in CI). The key is tied to your user account and subject to the same usage limits.</p>"},{"location":"qodo-merge-cli/installation/#using-qodo-merge-cli","title":"Using Qodo Merge CLI","text":"<p>After you set up Qodo Command, you can start using Qodo Merge CLI by running:</p> <pre><code>qodo merge\n</code></pre>"},{"location":"qodo-merge-cli/installation/#set-up-git-client","title":"Set Up Git Client","text":"<p>On first run, the CLI will check for your Git client (GitHub CLI or GitLab CLI). If not found, it will guide you through the installation process.</p> <p></p>"},{"location":"qodo-merge-cli/installation/#quick-usage","title":"Quick Usage","text":"<p>There are two ways to specify which PR to review:</p> <p>(1) Auto Detect PR from current branch run this command in your CLI:</p> <pre><code>qodo merge\n</code></pre> <p>(2) Specify PR number or URL</p> <pre><code>qodo merge 303\n\nqodo merge https://github.com/owner/repo/pull/303\n</code></pre> <p>Then the tool will automatically fetch the suggestions from the PR and display them in an interactive table.</p> <p></p>"},{"location":"qodo-merge-cli/installation/#next-steps","title":"Next Steps","text":"<p>Usage - Navigate, explore, and implement suggestions</p>"},{"location":"qodo-merge-cli/usage/","title":"Usage","text":""},{"location":"qodo-merge-cli/usage/#usage-guide-for-qodo-merge-cli","title":"Usage Guide for Qodo Merge CLI","text":""},{"location":"qodo-merge-cli/usage/#understanding-the-interface","title":"Understanding the Interface","text":""},{"location":"qodo-merge-cli/usage/#why-a-structured-table","title":"Why a Structured Table?","text":"<p>The suggestions table serves as the core interface for reviewing and managing AI feedback.</p> <p>The table provides a structured overview of all suggestions with key metadata. Users can efficiently prioritize, explore, and implement suggestions through an intuitive workflow.</p> <p>The interface guides you from high-level overviews to detailed implementation context. This consistent user-friendly structure streamlines the review process, reducing time from feedback to implementation.</p> <p></p>"},{"location":"qodo-merge-cli/usage/#navigation-instructions","title":"Navigation Instructions","text":"<p>Use <code>\u2191</code>/<code>\u2193</code> to navigate suggestions, <code>Enter</code> to implement, <code>Space</code> for multi-select, and <code>ESC</code> to exit.</p> <p>The table includes:</p> <ul> <li>Selection (<code>\u25cb</code>/<code>\u25c9</code>): Multi-selection mode</li> <li>Category: Security, Performance, General, etc.</li> <li>Impact: High, Medium, Low importance</li> <li>Suggestion: Brief description</li> <li>Status: <code>\u2713</code> implemented, <code>\u2717</code> declined, blank = pending</li> <li>Detail Panel (if wide enough): Full suggestion text, affected files, impact analysis</li> </ul>"},{"location":"qodo-merge-cli/usage/#flow","title":"Flow","text":""},{"location":"qodo-merge-cli/usage/#explore-the-suggestions","title":"Explore the suggestions","text":"<p>You can explore the suggestions in detail before implementing them. You can view the proposed code changes in a diff format, jump to the relevant code in your IDE, or chat about any suggestion for clarification.</p> <p>Exploring the suggestions</p> Diff View (<code>D/S</code>)Jump to Code (<code>O</code>)Chat (<code>C</code>) Unified Diff View (<code>D</code>)Side-by-Side View (<code>S</code>) <p></p> <ul> <li>Press <code>D</code> to view proposed code changes</li> <li>Standard unified diff format with line numbers</li> <li>Syntax highlighting for additions/removals</li> <li><code>\u2191</code>/<code>\u2193</code> to scroll through changes</li> </ul> <p></p> <ul> <li>Press <code>S</code> for side-by-side diff view</li> <li>Enhanced layout for complex changes</li> <li>Better context understanding</li> <li>Clear before/after comparison</li> </ul> <p>IDE Integration</p> <ul> <li>Press <code>O</code> to open the suggestion's source file in your IDE</li> <li>Supports all major IDEs when terminal is running inside them</li> <li>Direct navigation to relevant code location</li> <li>Seamless transition between CLI and editor</li> </ul> <p>Suggestion-Specific Discussion</p> <p></p> <ul> <li>Press <code>C</code> to discuss the current suggestion</li> <li>Context automatically included (files, lines, description)</li> <li>Ask questions, request modifications</li> <li><code>Ctrl+J</code> for new lines, <code>ESC</code> to return</li> </ul>"},{"location":"qodo-merge-cli/usage/#implement","title":"Implement","text":"<p>You can implement a single suggestion, multiple selected suggestions, or all suggestions at once. You can also chat about any suggestion before implementing it.</p> <p>Multiple implementation modes available</p> 1. Single Suggestion2. Multi-Select3. Address All4. Chat then Implement <p></p> <p>Direct individual implementation</p> <ol> <li>Navigate to any specific suggestion</li> <li>Press <code>Enter</code> to implement just that suggestion</li> </ol> <p></p> <p>Select multiple related suggestions</p> <ol> <li>Use <code>Space</code> to select specific suggestions (\u25c9)</li> <li>Navigate and select multiple related suggestions</li> <li>Press <code>Enter</code> on any selected suggestion to start implementation</li> <li>AI implements selected suggestions together</li> </ol> <p></p> <p>Reflect and address all suggestions (Always available as first row)</p> <ol> <li>Press <code>Enter</code> on the first row \"Reflect and address all suggestions\"</li> <li>AI implements all suggestions simultaneously and intelligently</li> <li>Handles conflicts and dependencies automatically</li> <li>Review the comprehensive summary</li> </ol> <p></p> <p>Discuss then implement</p> <ol> <li>Press <code>C</code> on any suggestion to start a chat</li> <li>Ask questions, request modifications, get clarifications</li> <li>Once satisfied, request implementation via chat</li> <li>AI implements based on your discussion</li> </ol>"},{"location":"qodo-merge-cli/usage/#implementation-summary","title":"Implementation Summary","text":"<p>After the AI completes the implementation, you receive a structured output showing detailed results for each suggestion:</p> <ul> <li>Status: <code>\u2713 IMPLEMENTED</code>, <code>SKIPPED</code>, or <code>\u2717 REJECTED</code></li> <li>Suggestion: Brief description of what was addressed</li> <li>Reasoning: Explanation of the implementation approach</li> <li>Changes: Summary of code modifications made</li> </ul> <p></p> <p>Each suggestion gets its own implementation summary, providing full transparency into what was done and why.</p>"},{"location":"qodo-merge-cli/usage/#finalize","title":"Finalize","text":"<p>After implementing the suggestions, you have several options to proceed:</p> <p>Post Implementation Actions</p> Return to Table (<code>ESC</code>)Continue Chatting (<code>C</code>)Commit Changes (<code>M</code>)Open Edited File (<code>O</code>) <p></p> <p>The first option returns you to the main table where you can see:</p> <ul> <li>Updated Status: Implemented suggestions now show <code>\u2713</code> green checkmark</li> <li>Real-time Updates: Status changes reflect immediately</li> <li>Continue Workflow: Handle remaining pending suggestions</li> </ul> <p></p> <p>Discuss the implementation details:</p> <ul> <li>Review changes made by the AI</li> <li>Request refinements or modifications</li> <li>Get explanations of implementation approach</li> <li>Continuous improvement cycle</li> </ul> <p></p> <p>Auto-generate commit messages:</p> <ul> <li>AI-generated commit messages based on changes</li> <li>Editable before committing</li> <li>Standard git conventions</li> <li>Seamless workflow integration</li> </ul> <p>Open the implemented code directly in your IDE:</p> <ul> <li>View the exact changes made</li> <li>See implementation in full context</li> <li>Continue development seamlessly</li> <li>Integrated with your existing workflow</li> </ul>"},{"location":"qodo-merge-cli/usage/#tips-for-success","title":"Tips for Success","text":"<ul> <li>Start with \"Fix All\" to let AI handle everything intelligently</li> <li>Use Chat liberally - ask questions about unclear suggestions</li> <li>Decline appropriately - press <code>X</code> and provide reasons for inappropriate suggestions</li> <li>Multi-select strategically - group related suggestions together</li> </ul>"},{"location":"recent_updates/","title":"Recent Updates","text":""},{"location":"recent_updates/#recent-updates-and-future-roadmap","title":"Recent Updates and Future Roadmap","text":"<p>This page summarizes recent enhancements to Qodo Merge.</p> <p>It also outlines our development roadmap for the upcoming three months. Please note that the roadmap is subject to change, and features may be adjusted, added, or reprioritized.</p> Recent UpdatesFuture Roadmap Date Feature Description 2025-09-17 Qodo Merge CLI A new command-line interface for Qodo Merge, enabling developers to implement code suggestions directly in your terminal. (Learn more) 2025-09-12 Repo Metadata You can now add metadata from files like <code>AGENTS.md</code>, which will be applied to all PRs in that repository. (Learn more) 2025-08-11 RAG support for GitLab All Qodo Merge RAG features are now available in GitLab. (Learn more) 2025-07-29 High-level Suggestions Qodo Merge now also provides high-level code suggestion for PRs. (Learn more) 2025-07-20 PR to Ticket Generate tickets in your tracking systems based on PR content. (Learn more) 2025-07-17 Compliance Comprehensive compliance checks for security, ticket requirements, and custom organizational rules. (Learn more) 2025-06-21 Mermaid Diagrams Qodo Merge now generates by default Mermaid diagrams for PRs, providing a visual representation of code changes. (Learn more) 2025-06-11 Best Practices Hierarchy Introducing support for structured best practices, such as for folders in monorepos or a unified best practice file for a group of repositories. (Learn more) 2025-06-01 CLI Endpoint A new Qodo Merge endpoint that accepts a lists of before/after code changes, executes Qodo Merge commands, and return the results. Currently available for enterprise customers. Contact Qodo for more information. <ul> <li><code>Compliance</code> tool to replace <code>review</code> as default: Planning to make the <code>compliance</code> tool the default automatic command instead of the current <code>review</code> tool.</li> <li>Smarter context retrieval: Leverage AST and LSP analysis to gather relevant context from across the entire repository.</li> <li>Enhanced portal experience: Improved user experience in the Qodo Merge portal with new options and capabilities.</li> </ul>"},{"location":"tools/","title":"Tools","text":""},{"location":"tools/#tools","title":"Tools","text":"<p>Here is a list of Qodo Merge tools, each with a dedicated page that explains how to use it:</p> Tool Description PR Description (<code>/describe</code>) Automatically generating PR description - title, type, summary, code walkthrough and labels PR Review (<code>/review</code>) Adjustable feedback about the PR, possible issues, security concerns, review effort and more Code Suggestions (<code>/improve</code>) Code suggestions for improving the PR Question Answering (<code>/ask ...</code>) Answering free-text questions about the PR, or on specific code lines Help (<code>/help</code>) Provides a list of all the available tools. Also enables to trigger them interactively (\ud83d\udc8e) Help Docs (<code>/help_docs</code>) Answer a free-text question based on a git documentation folder. Update Changelog (<code>/update_changelog</code>) Automatically updating the CHANGELOG.md file with the PR changes \ud83d\udc8e Add Documentation (<code>/add_docs</code>) Generates documentation to methods/functions/classes that changed in the PR \ud83d\udc8e Analyze (<code>/analyze</code>) Identify code components that changed in the PR, and enables to interactively generate tests, docs, and code suggestions for each component \ud83d\udc8e CI Feedback (<code>/checks ci_job</code>) Automatically generates feedback and analysis for a failed CI job \ud83d\udc8e Compliance (<code>/compliance</code>) Comprehensive compliance checks for security, ticket requirements, and custom organizational rules \ud83d\udc8e Custom Prompt (<code>/custom_prompt</code>) Automatically generates custom suggestions for improving the PR code, based on specific guidelines defined by the user \ud83d\udc8e Generate Custom Labels (<code>/generate_labels</code>) Generates custom labels for the PR, based on specific guidelines defined by the user \ud83d\udc8e Generate Tests (<code>/test</code>) Automatically generates unit tests for a selected component, based on the PR code changes \ud83d\udc8e Implement (<code>/implement</code>) Generates implementation code from review suggestions \ud83d\udc8e Improve Component (<code>/improve_component component_name</code>) Generates code suggestions for a specific code component that changed in the PR \ud83d\udc8e PR to Ticket (<code>/create_ticket</code>) Generates ticket in the ticket tracking systems (Jira, Linear, or Git provider issues) based on PR content \ud83d\udc8e Scan Repo Discussions (<code>/scan_repo_discussions</code>) Generates <code>best_practices.md</code> file based on previous discussions in the repository \ud83d\udc8e Similar Code (<code>/similar_code</code>) Retrieves the most similar code components from inside the organization's codebase, or from open-source code. <p>Note that the tools marked with \ud83d\udc8e are available only for Qodo Merge users.</p>"},{"location":"tools/analyze/","title":"\ud83d\udc8e Analyze","text":""},{"location":"tools/analyze/#overview","title":"Overview","text":"<p>The <code>analyze</code> tool combines advanced static code analysis with LLM capabilities to provide a comprehensive analysis of the PR code changes.</p> <p>The tool scans the PR code changes, finds the code components (methods, functions, classes) that changed, and enables to interactively generate tests, docs, code suggestions and similar code search for each component.</p> <p>It can be invoked manually by commenting on any PR:</p> <pre><code>/analyze\n</code></pre>"},{"location":"tools/analyze/#example-usage","title":"Example usage","text":"<p>An example result:</p> <p></p> <p>Language that are currently supported:</p> <p>Python, Java, C++, JavaScript, TypeScript, C#, Go, Ruby, PHP, Rust, Kotlin, Scala</p>"},{"location":"tools/ask/","title":"Ask","text":""},{"location":"tools/ask/#overview","title":"Overview","text":"<p>The <code>ask</code> tool answers questions about the PR, based on the PR code changes. Make sure to be specific and clear in your questions. It can be invoked manually by commenting on any PR:</p> <pre><code>/ask \"...\"\n</code></pre>"},{"location":"tools/ask/#example-usage","title":"Example usage","text":""},{"location":"tools/ask/#ask-lines","title":"Ask lines","text":"<p>You can run <code>/ask</code> on specific lines of code in the PR from the PR's diff view. The tool will answer questions based on the code changes in the selected lines.</p> <ul> <li>Click on the '+' sign next to the line number to select the line.</li> <li>To select multiple lines, click on the '+' sign of the first line and then hold and drag to select the rest of the lines.</li> <li>write <code>/ask \"...\"</code> in the comment box and press <code>Add single comment</code> button.</li> </ul> <p></p> <p>Note that the tool does not have \"memory\" of previous questions, and answers each question independently.</p>"},{"location":"tools/ask/#ask-on-images","title":"Ask on images","text":"<p>You can also ask questions about images that appear in the comment, where the entire PR code will be used as context.  The basic syntax is:</p> <pre><code>/ask \"...\"\n\n[Image](https://real_link_to_image)\n</code></pre> <p>where <code>https://real_link_to_image</code> is the direct link to the image.</p> <p>Note that GitHub has a built-in mechanism of pasting images in comments. However, pasted image does not provide a direct link. To get a direct link to an image, we recommend using the following scheme:</p> <p>1. First, post a comment that contains only the image:</p> <p></p> <p>2. Quote reply to that comment:</p> <p></p> <p>3. In the screen opened, type the question below the image:</p> <p> </p> <p>4. Post the comment, and receive the answer:</p> <p></p> <p>See a full video tutorial here</p>"},{"location":"tools/ci_feedback/","title":"\ud83d\udc8e CI Feedback","text":""},{"location":"tools/ci_feedback/#overview","title":"Overview","text":"<p>The CI feedback tool (<code>/checks)</code> automatically triggers when a PR has a failed check. The tool analyzes the failed checks and provides several feedbacks:</p> <ul> <li>Failed stage</li> <li>Failed test name</li> <li>Failure summary</li> <li>Relevant error logs</li> </ul>"},{"location":"tools/ci_feedback/#example-usage","title":"Example usage","text":"<p>\u2192 </p> <p>In addition to being automatically triggered, the tool can also be invoked manually by commenting on a PR:</p> <pre><code>/checks \"https://github.com/{repo_name}/actions/runs/{run_number}/job/{job_number}\"\n</code></pre> <p>where <code>{repo_name}</code> is the name of the repository, <code>{run_number}</code> is the run number of the failed check, and <code>{job_number}</code> is the job number of the failed check.</p>"},{"location":"tools/ci_feedback/#disabling-the-tool-from-running-automatically","title":"Disabling the tool from running automatically","text":"<p>If you wish to disable the tool from running automatically, you can do so by adding the following configuration to the configuration file:</p> <pre><code>[checks]\nenable_auto_checks_feedback = false\n</code></pre>"},{"location":"tools/ci_feedback/#configuration-options","title":"Configuration options","text":"<ul> <li><code>enable_auto_checks_feedback</code> - if set to true, the tool will automatically provide feedback when a check is failed. Default is true.</li> <li><code>excluded_checks_list</code> - a list of checks to exclude from the feedback, for example: [\"check1\", \"check2\"]. Default is an empty list.</li> <li><code>persistent_comment</code> - if set to true, the tool will overwrite a previous checks comment with the new feedback. Default is true.</li> <li><code>enable_help_text=true</code> - if set to true, the tool will provide a help message when a user comments \"/checks\" on a PR. Default is true.</li> <li><code>final_update_message</code> - if <code>persistent_comment</code> is true and updating a previous checks message, the tool will also create a new message: \"Persistent checks updated to latest commit\". Default is true.</li> </ul>"},{"location":"tools/compliance/","title":"\ud83d\udc8e Compliance","text":"<p><code>Platforms supported: GitHub, GitLab, Bitbucket</code></p>"},{"location":"tools/compliance/#overview","title":"Overview","text":"<p>The <code>compliance</code> tool performs comprehensive compliance checks on PR code changes, validating them against security standards, ticket requirements, and custom organizational compliance checklists, thereby helping teams, enterprises, and agents maintain consistent code quality and security practices while ensuring that development work aligns with business requirements.</p> Fully CompliantPartially Compliant <p></p> <p></p>"},{"location":"tools/compliance/#example-usage","title":"Example Usage","text":""},{"location":"tools/compliance/#manual-triggering","title":"Manual Triggering","text":"<p>Invoke the tool manually by commenting <code>/compliance</code> on any PR. The compliance results are presented in a comprehensive table:</p> <p>To edit configurations related to the <code>compliance</code> tool, use the following template:</p> <pre><code>/compliance --pr_compliance.some_config1=... --pr_compliance.some_config2=...\n</code></pre> <p>For example, you can enable ticket compliance labels by running:</p> <pre><code>/compliance --pr_compliance.enable_ticket_labels=true\n</code></pre>"},{"location":"tools/compliance/#automatic-triggering","title":"Automatic Triggering","text":"<p>The tool can be triggered automatically every time a new PR is opened, or in a push event to an existing PR.</p> <p>To run the <code>compliance</code> tool automatically when a PR is opened, define the following in the configuration file:</p> <pre><code>[github_app]  # for example\npr_commands = [\n    \"/compliance\",\n    ...\n]\n</code></pre>"},{"location":"tools/compliance/#compliance-categories","title":"Compliance Categories","text":"<p>The compliance tool evaluates three main categories:</p>"},{"location":"tools/compliance/#1-security-compliance","title":"1. Security Compliance","text":"<p>Scans for security vulnerabilities and potential exploits in the PR code changes:</p> <ul> <li>Verified Security Concerns \ud83d\udd34: Clear security vulnerabilities that require immediate attention</li> <li>Possible Security Risks \u26aa: Potential security issues that need human verification</li> <li>No Security Concerns \ud83d\udfe2: No security vulnerabilities detected</li> </ul> <p>Examples of security issues:</p> <ul> <li>Exposure of sensitive information (API keys, passwords, secrets)</li> <li>SQL injection vulnerabilities</li> <li>Cross-site scripting (XSS) risks</li> <li>Cross-site request forgery (CSRF) vulnerabilities</li> <li>Insecure data handling patterns</li> </ul>"},{"location":"tools/compliance/#2-ticket-compliance","title":"2. Ticket Compliance","text":"How to set up ticket compliance <p>Follow the guide on how to set up ticket compliance with Qodo Merge.</p> Auto-create ticket <p>Follow this guide to learn how to enable triggering <code>create tickets</code> based on PR content.</p> <p></p> <p>Validates that PR changes fulfill the requirements specified in linked tickets:</p> <ul> <li>Fully Compliant \ud83d\udfe2: All ticket requirements are satisfied</li> <li>Partially Compliant \ud83d\udfe1: Some requirements are met, others need attention</li> <li>Not Compliant \ud83d\udd34: Clear violations of ticket requirements</li> <li>Requires Verification \u26aa: Requirements that need human review</li> </ul>"},{"location":"tools/compliance/#3-rag-code-duplication-compliance","title":"3. RAG Code Duplication Compliance","text":"Learn more about RAG <p>For detailed information about RAG context enrichment, see the RAG Context Enrichment guide.</p> <p>Analyzes code changes using RAG endpoint to detect potential code duplication from the codebase:</p> <ul> <li>Fully Compliant \ud83d\udfe2: No code duplication found</li> <li>Not Compliant \ud83d\udd34: Full code duplication found</li> <li>Requires Verification \u26aa: Near code duplication </li> </ul>"},{"location":"tools/compliance/#4-custom-compliance","title":"4. Custom Compliance","text":"<p>Validates against an organization-specific compliance checklist:</p> <ul> <li>Fully Compliant \ud83d\udfe2: All custom compliance are satisfied</li> <li>Not Compliant \ud83d\udd34: Violations of custom compliance</li> <li>Requires Verification \u26aa: Compliance that need human assessment</li> </ul>"},{"location":"tools/compliance/#custom-compliance","title":"Custom Compliance","text":""},{"location":"tools/compliance/#setting-up-custom-compliance","title":"Setting Up Custom Compliance","text":"<p>Each compliance is defined in a YAML file as follows:</p> <ul> <li><code>title</code> (required): A clear, descriptive title that identifies what is being checked</li> <li><code>compliance_label</code> (required): Determines whether this compliance generates labels for non-compliance issues (set to <code>true</code> or <code>false</code>)</li> <li><code>objective</code> (required): A detailed description of the goal or purpose this compliance aims to achieve</li> <li><code>success_criteria</code> and <code>failure_criteria</code> (at least one required; both recommended): Define the conditions for compliance</li> </ul> Example of a compliance checklist <pre><code># pr_compliance_checklist.yaml\npr_compliances:\n  - title: \"Error Handling\"\n    compliance_label: true\n    objective: \"All external API calls must have proper error handling\"\n    success_criteria: \"Try-catch blocks around external calls with appropriate logging\"\n    failure_criteria: \"External API calls without error handling or logging\"\n\n...\n</code></pre> Writing effective compliance checklists <ul> <li>Avoid overly complex or subjective compliances that are hard to verify</li> <li>Keep compliances focused on security, business requirements, and critical standards</li> <li>Use clear, actionable language that developers can understand</li> <li>Focus on meaningful compliance requirements, not style preferences</li> </ul> Ready-to-use compliance templates <p>For production-ready compliance checklist templates organized by programming languages and technology stacks, check out the PR Compliance Templates repository.</p>"},{"location":"tools/compliance/#local-compliance-checklists","title":"Local Compliance Checklists","text":"<p>For basic usage, create a <code>pr_compliance_checklist.yaml</code> file in your repository's root directory containing the compliance requirements specific to your repository.</p> <p>The AI model will use this <code>pr_compliance_checklist.yaml</code> file as a reference, and if the PR code violates any of the compliance requirements, it will be shown in the compliance tool's comment.</p>"},{"location":"tools/compliance/#global-hierarchical-compliance","title":"Global Hierarchical Compliance","text":"<p>Qodo Merge supports hierarchical compliance checklists using a dedicated global configuration repository.</p>"},{"location":"tools/compliance/#setting-up-global-hierarchical-compliance","title":"Setting up global hierarchical compliance","text":"<p>1. Create a new repository named <code>pr-agent-settings</code> in your organization or workspace.</p> <p>2. Build the folder hierarchy in your <code>pr-agent-settings</code> repository:</p> <pre><code>pr-agent-settings/\n\u251c\u2500\u2500 metadata.yaml                              # Maps repos/folders to compliance paths\n\u2514\u2500\u2500 codebase_standards/                        # Root for all compliance definitions\n    \u251c\u2500\u2500 global/                                # Global compliance, inherited widely\n    \u2502   \u2514\u2500\u2500 pr_compliance_checklist.yaml\n    \u251c\u2500\u2500 groups/                                # For groups of repositories\n    \u2502   \u251c\u2500\u2500 frontend_repos/\n    \u2502   \u2502   \u2514\u2500\u2500 pr_compliance_checklist.yaml\n    \u2502   \u251c\u2500\u2500 backend_repos/\n    \u2502   \u2502   \u2514\u2500\u2500 pr_compliance_checklist.yaml\n    \u2502   \u251c\u2500\u2500 python_repos/\n    \u2502   \u2502   \u2514\u2500\u2500 pr_compliance_checklist.yaml\n    \u2502   \u251c\u2500\u2500 cpp_repos/\n    \u2502   \u2502   \u2514\u2500\u2500 pr_compliance_checklist.yaml\n    \u2502   \u2514\u2500\u2500 ...\n    \u251c\u2500\u2500 repo_a/                                # For standalone repositories\n    \u2502   \u2514\u2500\u2500 pr_compliance_checklist.yaml\n    \u251c\u2500\u2500 monorepo-name/                         # For monorepo-specific compliance\n    \u2502   \u251c\u2500\u2500 pr_compliance_checklist.yaml       # Root-level monorepo compliance\n    \u2502   \u251c\u2500\u2500 service-a/                         # Subproject compliance\n    \u2502   \u2502   \u2514\u2500\u2500 pr_compliance_checklist.yaml\n    \u2502   \u2514\u2500\u2500 service-b/                         # Another subproject\n    \u2502       \u2514\u2500\u2500 pr_compliance_checklist.yaml\n    \u2514\u2500\u2500 ...                                    # More repositories\n</code></pre> <p>Note: In this structure, <code>pr-agent-settings</code>, <code>codebase_standards</code>, <code>global</code>, <code>groups</code>, <code>metadata.yaml</code>, and <code>pr_compliance_checklist.yaml</code> are hardcoded names that must be used exactly as shown. All other names (such as <code>frontend_repos</code>, <code>backend_repos</code>, <code>repo_a</code>, <code>monorepo-name</code>, <code>service-a</code>, etc.) are examples and should be replaced with your actual repository and service names.</p> Grouping and categorizing compliance checklists <ul> <li>Each folder (including the global folder) can contain a single <code>pr_compliance_checklist.yaml</code> file</li> <li>Organize repository compliance checklists by creating subfolders within the <code>groups</code> folder. Group them by purpose, programming languages, or other categories</li> </ul> <p>3. Define the metadata file <code>metadata.yaml</code> in the root of <code>pr-agent-settings</code>:</p> <pre><code># Standalone repos\nrepo_a:\n  pr_compliance_checklist_paths:\n    - \"repo_a\"\n\n# Group-associated repos\nrepo_b:\n  pr_compliance_checklist_paths:\n    - \"groups/backend_repos\"\n\n# Multi-group repos\nrepo_c:\n  pr_compliance_checklist_paths:\n    - \"groups/frontend_repos\"\n    - \"groups/backend_repos\"\n\n# Monorepo with subprojects\nmonorepo-name:\n  pr_compliance_checklist_paths:\n    - \"monorepo-name\"\n  monorepo_subprojects:\n    service-a:\n      pr_compliance_checklist_paths:\n        - \"monorepo-name/service-a\"\n    service-b:\n      pr_compliance_checklist_paths:\n        - \"monorepo-name/service-b\"\n</code></pre> <p>4. Set the following configuration:</p> <pre><code>[pr_compliance]\nenable_global_pr_compliance = true\n</code></pre> Compliance checklist loading strategy <ol> <li> <p>Global Checklists: Hierarchical compliance from <code>pr-agent-settings</code> repository</p> <p>1.1 If the repository is mapped in <code>metadata.yaml</code>, it uses the specified paths and the global compliance checklist</p> <p>1.2 For monorepos, it automatically collects compliance checklists matching PR file paths</p> <p>1.3 If the repository is not mapped in <code>metadata.yaml</code>, global checklists are not loaded</p> </li> <li> <p>Local Repository Checklist: <code>pr_compliance_checklist.yaml</code> file in the repository</p> <p>2.1 Loaded if present in the repository</p> <p>2.2 Content is merged with global checklists (if loaded) to create the final compliance checklist</p> </li> </ol>"},{"location":"tools/compliance/#configuration-options","title":"Configuration Options","text":"General options <p> extra_instructions Optional extra instructions for the tool. For example: \"Ensure that all error-handling paths in the code contain appropriate logging statements\". Default is empty string. persistent_comment If set to true, the compliance comment will be persistent, meaning that every new compliance request will edit the previous one. Default is true. enable_user_defined_compliance_labels If set to true, the tool will add the label <code>Failed compliance check</code> for custom compliance violations. Default is true. enable_estimate_effort_to_review If set to true, the tool will estimate the effort required to review the PR (1-5 scale) as a label. Default is true. enable_todo_scan If set to true, the tool will scan for TODO comments in the PR code. Default is false. enable_update_pr_compliance_checkbox If set to true, the tool will add an update checkbox to refresh compliance status following push events. Default is true. enable_help_text If set to true, the tool will display help text in the comment. Default is false. </p> Section visibility options <p> enable_security_section If set to true, the security compliance section will be displayed in the output. When false, the entire security section is hidden. Default is true. enable_ticket_section If set to true, the ticket compliance section will be displayed in the output. When false, the entire ticket section is hidden. Default is true. enable_codebase_duplication_section If set to true, the codebase duplication compliance section will be displayed in the output. When false, the entire codebase duplication section is hidden. Default is true. enable_custom_compliance_section If set to true, the custom compliance section will be displayed in the output. When false, the entire custom section is hidden. Default is true. </p> Security compliance options <p> enable_security_compliance If set to true, the tool will check for security vulnerabilities. Default is true. enable_compliance_labels_security If set to true, the tool will add a <code>Possible security concern</code> label to the PR when security-related concerns are detected. Default is true. </p> Ticket compliance options <p> enable_ticket_labels If set to true, the tool will add ticket compliance labels to the PR. Default is false. enable_no_ticket_labels If set to true, the tool will add a label when no ticket is found. Default is false. check_pr_additional_content If set to true, the tool will check if the PR contains content not related to the ticket. Default is false. </p> Generic custom compliance checklist options <p> enable_generic_custom_compliance_checklist If set to true, the tool will apply generic custom compliance checklist rules. Default is true. persist_generic_custom_compliance_checklist If set to false, generic compliance checklist will not be kept with custom compliance. Default is false. </p>"},{"location":"tools/compliance/#usage-tips","title":"Usage Tips","text":""},{"location":"tools/compliance/#blocking-prs-based-on-compliance","title":"Blocking PRs Based on Compliance","text":"<p>You can configure CI/CD Actions to prevent merging PRs with specific compliance labels:</p> <ul> <li><code>Possible security concern</code> - Block PRs with potential security issues</li> <li><code>Failed compliance check</code> - Block PRs that violate custom compliance checklists</li> </ul> <p>Implement a dedicated GitHub Action to enforce these checklists.</p>"},{"location":"tools/custom_labels/","title":"\ud83d\udc8e Generate Labels","text":"<p><code>Platforms supported: GitHub, GitLab</code></p>"},{"location":"tools/custom_labels/#overview","title":"Overview","text":"<p>The <code>generate_labels</code> tool scans the PR code changes, and given a list of labels and their descriptions, it automatically suggests labels that match the PR code changes.</p> <p>It can be invoked manually by commenting on any PR:</p> <pre><code>/generate_labels\n</code></pre>"},{"location":"tools/custom_labels/#example-usage","title":"Example usage","text":"<p>If we wish to add detect changes to SQL queries in a given PR, we can add the following custom label along with its description:</p> <p></p> <p>When running the <code>generate_labels</code> tool on a PR that includes changes in SQL queries, it will automatically suggest the custom label:</p> <p></p> <p>Note that in addition to the dedicated tool <code>generate_labels</code>, the custom labels will also be used by the <code>describe</code> tool.</p>"},{"location":"tools/custom_labels/#how-to-enable-custom-labels","title":"How to enable custom labels","text":"<p>There are 3 ways to enable custom labels:</p>"},{"location":"tools/custom_labels/#1-cli-local-configuration-file","title":"1. CLI (local configuration file)","text":"<p>When working from CLI, you need to apply the configuration changes to the custom_labels file:</p>"},{"location":"tools/custom_labels/#2-repo-configuration-file","title":"2. Repo configuration file","text":"<p>To enable custom labels, you need to apply the configuration changes to the local <code>.pr_agent.toml</code> file in your repository.</p>"},{"location":"tools/custom_labels/#3-handle-custom-labels-from-the-repos-labels-page","title":"3. Handle custom labels from the Repo's labels page \ud83d\udc8e","text":"<p>This feature is available only in Qodo Merge</p> <ul> <li>GitHub : <code>https://github.com/{owner}/{repo}/labels</code>, or click on the \"Labels\" tab in the issues or PRs page.</li> <li>GitLab : <code>https://gitlab.com/{owner}/{repo}/-/labels</code>, or click on \"Manage\" -&gt; \"Labels\" on the left menu.</li> </ul> <p>b. Add/edit the custom labels. It should be formatted as follows:</p> <ul> <li>Label name: The name of the custom label.</li> <li>Description: Start the description of with prefix <code>pr_agent:</code>, for example: <code>pr_agent: Description of when AI should suggest this label</code>. The description should be comprehensive and detailed, indicating when to add the desired label.</li> </ul> <p></p> <p>c. Now the custom labels will be included in the <code>generate_labels</code> tool.</p> <p>This feature is supported in GitHub and GitLab.</p>"},{"location":"tools/custom_labels/#configuration-options","title":"Configuration options","text":"<ul> <li>Change <code>enable_custom_labels</code> to True: This will turn off the default labels and enable the custom labels provided in the custom_labels.toml file.</li> <li>Add the custom labels. It should be formatted as follows:</li> </ul> <pre><code>[config]\nenable_custom_labels=true\n\n[custom_labels.\"Custom Label Name\"]\ndescription = \"Description of when AI should suggest this label\"\n\n[custom_labels.\"Custom Label 2\"]\ndescription = \"Description of when AI should suggest this label 2\"\n</code></pre> Auto-remove custom label when no longer relevant <p>If the custom label is no longer relevant, it will be automatically removed from the PR by running the <code>generate_labels</code> tool or the <code>describe</code> tool.</p>"},{"location":"tools/custom_prompt/","title":"\ud83d\udc8e Custom Prompt","text":""},{"location":"tools/custom_prompt/#overview","title":"Overview","text":"<p>The <code>custom_prompt</code> tool scans the PR code changes, and automatically generates suggestions for improving the PR code. It shares similarities with the <code>improve</code> tool, but with one main difference: the <code>custom_prompt</code> tool will only propose suggestions that follow specific guidelines defined by the prompt in: <code>pr_custom_prompt.prompt</code> configuration.</p> <p>The tool can be triggered automatically every time a new PR is opened, or can be invoked manually by commenting on a PR.</p> <p>When commenting, use the following template:</p> <pre><code>/custom_prompt --pr_custom_prompt.prompt=\"\nThe code suggestions should focus only on the following:\n- ...\n- ...\n\n\"\n</code></pre> <p>With a configuration file, use the following template:</p> <pre><code>[pr_custom_prompt]\nprompt=\"\"\"\\\nThe suggestions should focus only on the following:\n-...\n-...\n\n\"\"\"\n</code></pre> <p>Remember - with this tool, you are the prompter. Be specific, clear, and concise in the instructions. Specify relevant aspects that you want the model to focus on. \\ You might benefit from several trial-and-error iterations, until you get the correct prompt for your use case.</p>"},{"location":"tools/custom_prompt/#example-usage","title":"Example usage","text":"<p>Here is an example of a possible prompt, defined in the configuration file:</p> <pre><code>[pr_custom_prompt]\nprompt=\"\"\"\\\nThe code suggestions should focus only on the following:\n- look for edge cases when implementing a new function\n- make sure every variable has a meaningful name\n- make sure the code is efficient\n\"\"\"\n</code></pre> <p>(The instructions above are just an example. We want to emphasize that the prompt should be specific and clear, and be tailored to the needs of your project)</p> <p>Results obtained with the prompt above:</p> <p></p>"},{"location":"tools/custom_prompt/#configuration-options","title":"Configuration options","text":"<ul> <li> <p><code>prompt</code>: the prompt for the tool. It should be a multi-line string.</p> </li> <li> <p><code>num_code_suggestions_per_chunk</code>: number of code suggestions provided by the 'custom_prompt' tool, per chunk. Default is 3.</p> </li> <li> <p><code>enable_help_text</code>: if set to true, the tool will display a help text in the comment. Default is true.</p> </li> </ul>"},{"location":"tools/describe/","title":"Describe","text":""},{"location":"tools/describe/#overview","title":"Overview","text":"<p>The <code>describe</code> tool scans the PR code changes, and generates a description for the PR - title, type, summary, walkthrough and labels.</p> <p>The tool can be triggered automatically every time a new PR is opened, or it can be invoked manually by commenting on any PR:</p> <pre><code>/describe\n</code></pre>"},{"location":"tools/describe/#example-usage","title":"Example usage","text":""},{"location":"tools/describe/#manual-triggering","title":"Manual triggering","text":"<p>Invoke the tool manually by commenting <code>/describe</code> on any PR:</p> <p></p> <p>After ~30 seconds, the tool will generate a description for the PR:</p> <p></p> <p>If you want to edit configurations, add the relevant ones to the command:</p> <pre><code>/describe --pr_description.some_config1=... --pr_description.some_config2=...\n</code></pre>"},{"location":"tools/describe/#automatic-triggering","title":"Automatic triggering","text":"<p>To run the <code>describe</code> automatically when a PR is opened, define in a configuration file:</p> <pre><code>[github_app]\npr_commands = [\n    \"/describe\",\n    ...\n]\n\n[pr_description]\npublish_labels = true\n...\n</code></pre> <ul> <li>The <code>pr_commands</code> lists commands that will be executed automatically when a PR is opened.</li> <li>The <code>[pr_description]</code> section contains the configurations for the <code>describe</code> tool you want to edit (if any).</li> </ul>"},{"location":"tools/describe/#preserving-the-original-user-description","title":"Preserving the original user description","text":"<p>By default, Qodo Merge tries to preserve your original PR description by placing it above the generated content. This requires including your description during the initial PR creation.</p> <p>\"Qodo removed the original description from the PR. Why\"?</p> <p>From our experience, there are two possible reasons:</p> <ul> <li> <p>If you edit the description while the automated tool is running, a race condition may occur, potentially causing your original description to be lost. Hence, create a description before launching the PR.</p> </li> <li> <p>When updating PR descriptions, the <code>/describe</code> tool considers everything above the \"PR Type\" field as user content and will preserve it. Everything below this marker is treated as previously auto-generated content and will be replaced.</p> </li> </ul> <p></p>"},{"location":"tools/describe/#sequence-diagram-support","title":"Sequence Diagram Support","text":"<p>The <code>/describe</code> tool includes a Mermaid sequence diagram showing component/function interactions. </p> <p>This option is enabled by default via the <code>pr_description.enable_pr_diagram</code> param.</p>"},{"location":"tools/describe/#configuration-options","title":"Configuration options","text":"Possible configurations <p> publish_labels If set to true, the tool will publish labels to the PR. Default is false. publish_description_as_comment If set to true, the tool will publish the description as a comment to the PR. If false, it will overwrite the original description. Default is false. publish_description_as_comment_persistent If set to true and <code>publish_description_as_comment</code> is true, the tool will publish the description as a persistent comment to the PR. Default is true. add_original_user_description If set to true, the tool will add the original user description to the generated description. Default is true. generate_ai_title If set to true, the tool will also generate an AI title for the PR. Default is false. extra_instructions Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\" enable_pr_type If set to false, it will not show the <code>PR type</code> as a text value in the description content. Default is true. final_update_message If set to true, it will add a comment message <code>PR Description updated to latest commit...</code> after finishing calling <code>/describe</code>. Default is true. enable_semantic_files_types If set to true, \"Changes walkthrough\" section will be generated. Default is true. file_table_collapsible_open_by_default If set to true, the file list in the \"Changes walkthrough\" section will be open by default. If set to false, it will be closed by default. Default is false. collapsible_file_list If set to true, the file list in the \"Changes walkthrough\" section will be collapsible. If set to \"adaptive\", the file list will be collapsible only if there are more than 8 files. Default is \"adaptive\". enable_large_pr_handling \ud83d\udc8e If set to true, in case of a large PR the tool will make several calls to the AI and combine them to be able to cover more files. Default is true. enable_help_text If set to true, the tool will display a help text in the comment. Default is false. enable_pr_diagram If set to true, the tool will generate a horizontal Mermaid flowchart summarizing the main pull request changes. This field remains empty if not applicable. Default is true. auto_create_ticket If set to true, this will automatically create a ticket in the ticketing system when a PR is opened. Default is false. </p>"},{"location":"tools/describe/#inline-file-summary","title":"Inline file summary \ud83d\udc8e","text":"<p>This feature enables you to copy the <code>changes walkthrough</code> table to the \"Files changed\" tab, so you can quickly understand the changes in each file while reviewing the code changes (diff view).</p> <p>To copy the <code>changes walkthrough</code> table to the \"Files changed\" tab, you can click on the checkbox that appears PR Description status message below the main PR Description:</p> <p></p> <p>If you prefer to have the file summaries appear in the \"Files changed\" tab on every PR, change the <code>pr_description.inline_file_summary</code> parameter in the configuration file, possible values are:</p> <ul> <li><code>'table'</code>: File changes walkthrough table will be displayed on the top of the \"Files changed\" tab, in addition to the \"Conversation\" tab.</li> </ul> <p></p> <ul> <li><code>true</code>: A collapsible file comment with changes title and a changes summary for each file in the PR.</li> </ul> <p></p> <ul> <li><code>false</code> (<code>default</code>): File changes walkthrough will be added only to the \"Conversation\" tab.</li> </ul> <p>Note: that this feature is currently available only for GitHub.</p>"},{"location":"tools/describe/#markers-template","title":"Markers template","text":"<p>To enable markers, set <code>pr_description.use_description_markers=true</code>. Markers enable to easily integrate user's content and auto-generated content, with a template-like mechanism.</p> <p>For example, if the PR original description was:</p> <pre><code>User content...\n\n## PR Type:\npr_agent:type\n\n## PR Description:\npr_agent:summary\n\n## PR Walkthrough:\npr_agent:walkthrough\n\n## PR Diagram:\npr_agent:diagram\n</code></pre> <p>The marker <code>pr_agent:type</code> will be replaced with the PR type, <code>pr_agent:summary</code> will be replaced with the PR summary, <code>pr_agent:walkthrough</code> will be replaced with the PR walkthrough, and <code>pr_agent:diagram</code> will be replaced with the sequence diagram (if enabled).</p> <p></p> <p>becomes</p> <p></p> <p>Configuration params:</p> <ul> <li><code>use_description_markers</code>: if set to true, the tool will use markers template. It replaces every marker of the form <code>pr_agent:marker_name</code> with the relevant content. Default is false.</li> <li><code>include_generated_by_header</code>: if set to true, the tool will add a dedicated header: 'Generated by PR Agent at ...' to any automatic content. Default is true.</li> <li><code>diagram</code>: if present as a marker, will be replaced by the PR sequence diagram (if enabled).</li> </ul>"},{"location":"tools/describe/#custom-labels","title":"Custom labels","text":"<p>The default labels of the describe tool are quite generic, since they are meant to be used in any repo: [<code>Bug fix</code>, <code>Tests</code>, <code>Enhancement</code>, <code>Documentation</code>, <code>Other</code>].</p> <p>You can define custom labels that are relevant for your repo and use cases. Custom labels can be defined in a configuration file, or directly in the repo's labels page.</p> <p>Make sure to provide proper title, and a detailed and well-phrased description for each label, so the tool will know when to suggest it. Each label description should be a conditional statement, that indicates if to add the label to the PR or not, according to the PR content.</p> Auto-remove custom label when no longer relevant <p>If the custom label is no longer relevant, it will be automatically removed from the PR by running the <code>generate_labels</code> tool or the <code>describe</code> tool.</p>"},{"location":"tools/describe/#handle-custom-labels-from-a-configuration-file","title":"Handle custom labels from a configuration file","text":"<p>Example for a custom labels configuration setup in a configuration file:</p> <pre><code>[config]\nenable_custom_labels=true\n\n\n[custom_labels.\"sql_changes\"]\ndescription = \"Use when a PR contains changes to SQL queries\"\n\n[custom_labels.\"test\"]\ndescription = \"use when a PR primarily contains new tests\"\n\n...\n</code></pre>"},{"location":"tools/describe/#handle-custom-labels-from-the-repos-labels-page","title":"Handle custom labels from the Repo's labels page \ud83d\udc8e","text":"<p>You can also control the custom labels that will be suggested by the <code>describe</code> tool from the repo's labels page:</p> <ul> <li>GitHub : go to <code>https://github.com/{owner}/{repo}/labels</code> (or click on the \"Labels\" tab in the issues or PRs page)</li> <li>GitLab : go to <code>https://gitlab.com/{owner}/{repo}/-/labels</code> (or click on \"Manage\" -&gt; \"Labels\" on the left menu)</li> </ul> <p>Now add/edit the custom labels. they should be formatted as follows:</p> <ul> <li>Label name: The name of the custom label.</li> <li>Description: Start the description of with prefix <code>pr_agent:</code>, for example: <code>pr_agent: Description of when AI should suggest this label</code>.</li> </ul> <p>Examples for custom labels:</p> <ul> <li><code>Main topic:performance</code> -  pr_agent:The main topic of this PR is performance</li> <li><code>New endpoint</code> -  pr_agent:A new endpoint was added in this PR</li> <li><code>SQL query</code> -  pr_agent:A new SQL query was added in this PR</li> <li><code>Dockerfile changes</code> - pr_agent:The PR contains changes in the Dockerfile</li> <li>...</li> </ul> <p>The description should be comprehensive and detailed, indicating when to add the desired label. For example: </p>"},{"location":"tools/describe/#usage-tips","title":"Usage Tips","text":"<p>Automation</p> <ul> <li>When you first install Qodo Merge app, the default mode for the describe tool is: <pre><code>pr_commands = [\"/describe\", ...]\n</code></pre> meaning the <code>describe</code> tool will run automatically on every PR, with the default configurations.</li> </ul> <ul> <li>Markers are an alternative way to control the generated description, to give maximal control to the user. If you set:</li> </ul> <pre><code>pr_commands = [\"/describe --pr_description.use_description_markers=true\", ...]\n</code></pre> <p>the tool will replace every marker of the form <code>pr_agent:marker_name</code> in the PR description with the relevant content, where <code>marker_name</code> is one of the following:          *<code>type</code>: the PR type.          * <code>summary</code>: the PR summary.          * <code>walkthrough</code>: the PR walkthrough.</p> <ul> <li>Note that when markers are enabled, if the original PR description does not contain any markers, the tool will not alter the description at all.</li> </ul>"},{"location":"tools/documentation/","title":"\ud83d\udc8e Add Documentation","text":""},{"location":"tools/documentation/#overview","title":"Overview","text":"<p>The <code>add_docs</code> tool scans the PR code changes, and automatically suggests documentation for any code components that changed in the PR (functions, classes, etc.).</p> <p>It can be invoked manually by commenting on any PR:</p> <pre><code>/add_docs\n</code></pre>"},{"location":"tools/documentation/#example-usage","title":"Example usage","text":"<p>Invoke the tool manually by commenting <code>/add_docs</code> on any PR:</p> <p></p> <p>The tool will generate documentation for all the components that changed in the PR:</p> <p></p> <p></p> <p>You can state a name of a specific component in the PR to get documentation only for that component:</p> <pre><code>/add_docs component_name\n</code></pre>"},{"location":"tools/documentation/#manual-triggering","title":"Manual triggering","text":"<p>Comment <code>/add_docs</code> on a PR to invoke it manually.</p>"},{"location":"tools/documentation/#automatic-triggering","title":"Automatic triggering","text":"<p>To automatically run the <code>add_docs</code> tool when a pull request is opened, define in a configuration file:</p> <pre><code>[github_app]\npr_commands = [\n    \"/add_docs\",\n    ...\n]\n</code></pre> <p>The <code>pr_commands</code> list defines commands that run automatically when a PR is opened. Since this is under the [github_app] section, it only applies when using the Qodo Merge GitHub App in GitHub environments.</p>"},{"location":"tools/documentation/#configuration-options","title":"Configuration options","text":"<ul> <li><code>docs_style</code>: The exact style of the documentation (for python docstring). you can choose between: <code>google</code>, <code>numpy</code>, <code>sphinx</code>, <code>restructuredtext</code>, <code>plain</code>. Default is <code>sphinx</code>.</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\".</li> </ul> <p>Notes</p> <ul> <li>The following languages are currently supported: <code>Python, Java, C++, JavaScript, TypeScript, C#, Go, Ruby, PHP, Rust, Kotlin, Scala</code></li> <li>This tool can also be triggered interactively by using the <code>analyze</code> tool.</li> </ul>"},{"location":"tools/help/","title":"Help","text":""},{"location":"tools/help/#overview","title":"Overview","text":"<p>The <code>help</code> tool provides a list of all the available tools and their descriptions. For Qodo Merge users, it also enables to trigger each tool by checking the relevant box.</p> <p>It can be invoked manually by commenting on any PR:</p> <pre><code>/help\n</code></pre>"},{"location":"tools/help/#example-usage","title":"Example usage","text":"<p>Invoke the <code>help</code> tool by commenting on a PR with:</p> <p></p> <p>Response will include a list of available tools:</p> <p></p>"},{"location":"tools/help_docs/","title":"Help Docs","text":""},{"location":"tools/help_docs/#overview","title":"Overview","text":"<p>The <code>help_docs</code> tool can answer a free-text question based on a git documentation folder.</p> <p>It can be invoked manually by commenting on any PR or Issue:</p> <pre><code>/help_docs \"...\"\n</code></pre> <p>Or configured to be triggered automatically when a new issue is opened.</p> <p>The tool assumes by default that the documentation is located in the root of the repository, at <code>/docs</code> folder. However, this can be customized by setting the <code>docs_path</code> configuration option:</p> <pre><code>[pr_help_docs]\nrepo_url = \"\"                 # The repository to use as context\ndocs_path = \"docs\"            # The documentation folder\nrepo_default_branch = \"main\"  # The branch to use in case repo_url overwritten\n</code></pre> <p>See more configuration options in the Configuration options section.</p>"},{"location":"tools/help_docs/#example-usage","title":"Example usage","text":"<p>Asking a question about another repository</p> <p></p> <p>Response:</p> <p></p>"},{"location":"tools/help_docs/#run-automatically-when-a-new-issue-is-opened","title":"Run automatically when a new issue is opened","text":"<p>You can configure PR-Agent to run <code>help_docs</code> automatically on any newly created issue. This can be useful, for example, for providing immediate feedback to users who open issues with questions on open-source projects with extensive documentation.</p> <p>Here's how:</p> <p>1) Follow the steps depicted under Run as a Github Action to create a new workflow, such as:<code>.github/workflows/help_docs.yml</code>:</p> <p>2) Edit your yaml file to the following:</p> <pre><code>name: Run pr agent on every opened issue, respond to user comments on an issue\n\n#When the action is triggered\non:\n  issues:\n    types: [opened] #New issue\n\n# Read env. variables\nenv:\n  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n  GITHUB_API_URL: ${{ github.api_url }}\n  GIT_REPO_URL: ${{ github.event.repository.clone_url }}\n  ISSUE_URL: ${{ github.event.issue.html_url || github.event.comment.html_url }}\n  ISSUE_BODY: ${{ github.event.issue.body || github.event.comment.body }}\n  OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n\n# The actual set of actions\njobs:\n  issue_agent:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.sender.type != 'Bot' }} #Do not respond to bots\n\n    # Set required permissions\n    permissions:\n      contents: read    # For reading repository contents\n      issues: write     # For commenting on issues\n\n    steps:\n      - name: Run PR Agent on Issues\n        if: ${{ env.ISSUE_URL != '' }}\n        uses: docker://codiumai/pr-agent:latest\n        with:\n          entrypoint: /bin/bash #Replace invoking cli.py directly with a shell\n          args: |\n            -c \"cd /app &amp;&amp; \\\n            echo 'Running Issue Agent action step on ISSUE_URL=$ISSUE_URL' &amp;&amp; \\\n            export config__git_provider='github' &amp;&amp; \\\n                        export github__user_token=$GITHUB_TOKEN &amp;&amp; \\\n            export github__base_url=$GITHUB_API_URL &amp;&amp; \\\n            export openai__key=$OPENAI_KEY &amp;&amp; \\\n            python -m pr_agent.cli --issue_url=$ISSUE_URL --pr_help_docs.repo_url=\"...\" --pr_help_docs.docs_path=\"...\" --pr_help_docs.openai_key=$OPENAI_KEY &amp;&amp; \\\n            help_docs \"$ISSUE_BODY\"\n</code></pre> <p>3) Following completion of the remaining steps (such as adding secrets and relevant configurations, such as <code>repo_url</code> and <code>docs_path</code>) merge this change to your main branch. When a new issue is opened, you should see a comment from <code>github-actions</code> bot with an auto response, assuming the question is related to the documentation of the repository.</p>"},{"location":"tools/help_docs/#configuration-options","title":"Configuration options","text":"<p>Under the section <code>pr_help_docs</code>, the configuration file contains options to customize the 'help docs' tool:</p> <ul> <li><code>repo_url</code>: If not overwritten, will use the repo from where the context came from (issue or PR), otherwise - use the given repo as context.</li> <li><code>repo_default_branch</code>: The branch to use in case repo_url overwritten, otherwise - has no effect.</li> <li><code>docs_path</code>: Relative path from root of repository (either the one this PR has been issued for, or above repo url).</li> <li><code>exclude_root_readme</code>:  Whether or not to exclude the root README file for querying the model.</li> <li><code>supported_doc_exts</code> : Which file extensions should be included for the purpose of querying the model.</li> </ul>"},{"location":"tools/implement/","title":"\ud83d\udc8e Implement","text":"<p><code>Platforms supported: GitHub, GitLab, Bitbucket</code></p>"},{"location":"tools/implement/#overview","title":"Overview","text":"<p>The <code>implement</code> tool converts human code review discussions and feedback into ready-to-commit code changes. It leverages LLM technology to transform PR comments and review suggestions into concrete implementation code, helping developers quickly turn feedback into working solutions.</p>"},{"location":"tools/implement/#usage-scenarios","title":"Usage Scenarios","text":"For ReviewersFor PR AuthorsFor Referencing Comments <p>Reviewers can request code changes by:</p> <ol> <li>Selecting the code block to be modified.</li> <li>Adding a comment with the syntax:</li> </ol> <pre><code>/implement &lt;code-change-description&gt;\n</code></pre> <p></p> <p>PR authors can implement suggested changes by replying to a review comment using either:</p> <ol> <li>Add specific implementation details as described above</li> </ol> <pre><code>/implement &lt;code-change-description&gt;\n</code></pre> <ol> <li>Use the original review comment as instructions</li> </ol> <pre><code>/implement\n</code></pre> <p></p> <p>You can reference and implement changes from any comment by:</p> <pre><code>/implement &lt;link-to-an-inline-comment&gt;\n</code></pre> <p></p> <p>Note that the implementation will occur within the review discussion thread.</p>"},{"location":"tools/implement/#configuration-options","title":"Configuration options","text":"<ul> <li>Use <code>/implement</code> to implement code change within and based on the review discussion.</li> <li>Use <code>/implement &lt;code-change-description&gt;</code> inside a review discussion to implement specific instructions.</li> <li>Use <code>/implement &lt;link-to-an-inline-comment&gt;</code> to respond to an inline comment by triggering the tool from anywhere in the thread.</li> </ul>"},{"location":"tools/improve/","title":"Improve","text":""},{"location":"tools/improve/#overview","title":"Overview","text":"<p>The <code>improve</code> tool scans the PR code changes, and automatically generates meaningful suggestions for improving the PR code. The tool can be triggered automatically every time a new PR is opened, or it can be invoked manually by commenting on any PR:</p> <pre><code>/improve\n</code></pre>"},{"location":"tools/improve/#how-it-looks","title":"How it looks","text":"Suggestions OverviewSelecting a specific suggestion <p>The following features are available only for Qodo Merge \ud83d\udc8e users:</p> <ul> <li>The <code>Apply / Chat</code> checkbox, which interactively converts a suggestion into a committable code comment</li> <li>The <code>More</code> checkbox to generate additional suggestions</li> <li>On Bitbucket (Cloud &amp; Data Center) and GitLab Server (v16 and earlier), you can invoke More Suggestions manually</li> </ul>"},{"location":"tools/improve/#example-usage","title":"Example usage","text":""},{"location":"tools/improve/#manual-triggering","title":"Manual triggering","text":"<p>Invoke the tool manually by commenting <code>/improve</code> on any PR. The code suggestions by default are presented as a single comment:</p> <p>To edit configurations related to the <code>improve</code> tool, use the following template:</p> <pre><code>/improve --pr_code_suggestions.some_config1=... --pr_code_suggestions.some_config2=...\n</code></pre> <p>For example, you can choose to present all the suggestions as committable code comments, by running the following command:</p> <pre><code>/improve --pr_code_suggestions.commitable_code_suggestions=true\n</code></pre> <p></p>"},{"location":"tools/improve/#manual-more-suggestions","title":"Manual more suggestions","text":"<p>To generate more suggestions (distinct from the ones already generated), for git-providers that don't support interactive checkbox option, you can manually run:</p> <pre><code>/improve --more_suggestions=true\n</code></pre>"},{"location":"tools/improve/#automatic-triggering","title":"Automatic triggering","text":"<p>To run the <code>improve</code> automatically when a PR is opened, define in a configuration file:</p> <pre><code>[github_app]\npr_commands = [\n    \"/improve\",\n    ...\n]\n\n[pr_code_suggestions]\nnum_code_suggestions_per_chunk = ...\n...\n</code></pre> <ul> <li>The <code>pr_commands</code> lists commands that will be executed automatically when a PR is opened.</li> <li>The <code>[pr_code_suggestions]</code> section contains the configurations for the <code>improve</code> tool you want to edit (if any)</li> </ul>"},{"location":"tools/improve/#table-vs-committable-code-comments","title":"Table vs Committable code comments","text":"<p>Qodo Merge supports two modes for presenting code suggestions: </p> <p>1) Table mode </p> <p>2) Inline Committable code comments mode.</p> <p>The table format offers several key advantages:</p> <ul> <li>Reduced noise: Creates a cleaner PR experience with less clutter</li> <li>Quick overview and prioritization: Enables quick review of one-liner summaries, impact levels, and easy prioritization</li> <li>High-level suggestions: High-level suggestions that aren't tied to specific code chunks are presented only in the table mode</li> <li>Interactive features: Provides 'more' and 'update' functionality via clickable buttons</li> <li>Centralized tracking: Shows suggestion implementation status in one place</li> <li>IDE integration: Allows applying suggestions directly in your IDE via Qodo Command</li> </ul> <p>Table mode is the default of Qodo Merge, and is recommended approach for most users due to these benefits. </p> <p></p> <p>Teams with specific preferences can enable committable code comments mode in their local configuration, or use dual publishing mode.</p> <p><code>Note - due to platform limitations, Bitbucket cloud and server supports only committable code comments mode.</code></p>"},{"location":"tools/improve/#assessing-impact","title":"Assessing Impact","text":"<p><code>\ud83d\udc8e feature</code></p> <p>Qodo Merge tracks two types of implementations for tracking implemented suggestions:</p> <ul> <li>Direct implementation - when the user directly applies the suggestion by clicking the <code>Apply</code> checkbox.</li> <li>Indirect implementation - when the user implements the suggestion in their IDE environment. In this case, Qodo Merge will utilize, after each commit, a dedicated logic to identify if a suggestion was implemented, and will mark it as implemented.</li> </ul> <p></p> <p>In post-process, Qodo Merge counts the number of suggestions that were implemented, and provides general statistics and insights about the suggestions' impact on the PR process.</p> <p></p> <p></p>"},{"location":"tools/improve/#suggestion-tracking","title":"Suggestion tracking","text":"<p><code>\ud83d\udc8e feature. Platforms supported: GitHub, GitLab</code></p> <p>Qodo Merge employs a novel detection system to automatically identify AI code suggestions that PR authors have accepted and implemented.</p> <p>Accepted suggestions are also automatically documented in a dedicated wiki page called <code>.pr_agent_accepted_suggestions</code>, allowing users to track historical changes, assess the tool's effectiveness, and learn from previously implemented recommendations in the repository. An example result:</p> <p></p> <p>This dedicated wiki page will also serve as a foundation for future AI model improvements, allowing it to learn from historically implemented suggestions and generate more targeted, contextually relevant recommendations.</p> <p>This feature is controlled by a boolean configuration parameter: <code>pr_code_suggestions.wiki_page_accepted_suggestions</code> (default is true).</p> <p>Wiki must be enabled</p> <p>While the aggregation process is automatic, GitHub repositories require a one-time manual wiki setup.</p> <p>To initialize the wiki: navigate to <code>Wiki</code>, select <code>Create the first page</code>, then click <code>Save page</code>.</p> <p></p> <p>Once a wiki repo is created, the tool will automatically use this wiki for tracking suggestions.</p> <p>Why a wiki page?</p> <p>Your code belongs to you, and we respect your privacy. Hence, we won't store any code suggestions in an external database.</p> <p>Instead, we leverage a dedicated private page, within your repository wiki, to track suggestions. This approach offers convenient secure suggestion tracking while avoiding pull requests or any noise to the main repository.</p>"},{"location":"tools/improve/#extra-instructions-and-best-practices","title":"<code>Extra instructions</code> and <code>best practices</code>","text":"<p>The <code>improve</code> tool can be further customized by providing additional instructions and best practices to the AI model.</p>"},{"location":"tools/improve/#extra-instructions","title":"Extra instructions","text":"<p>You can use the <code>extra_instructions</code> configuration option to give the AI model additional instructions for the <code>improve</code> tool. Be specific, clear, and concise in the instructions. With extra instructions, you are the prompter.</p> <p>Examples for possible instructions:</p> <pre><code>[pr_code_suggestions]\nextra_instructions=\"\"\"\\\n(1) Answer in Japanese\n(2) Don't suggest to add try-except block\n(3) Ignore changes in toml files\n...\n\"\"\"\n</code></pre> <p>Use triple quotes to write multi-line instructions. Use bullet points or numbers to make the instructions more readable.</p>"},{"location":"tools/improve/#best-practices","title":"Best practices","text":"<p><code>\ud83d\udc8e feature. Platforms supported: GitHub, GitLab, Bitbucket</code></p> <p>Qodo Merge supports both simple and hierarchical best practices configurations to provide guidance to the AI model for generating relevant code suggestions.</p> Writing effective best practices files <p>The following guidelines apply to all best practices files:</p> <ul> <li>Write clearly and concisely</li> <li>Include brief code examples when helpful with before/after patterns</li> <li>Focus on project-specific guidelines that will result in relevant suggestions you actually want to get</li> <li>Keep each file relatively short, under 800 lines, since:<ul> <li>AI models may not process effectively very long documents</li> <li>Long files tend to contain generic guidelines already known to AI</li> <li>Maximum multiple file accumulated content is limited to 2000 lines.</li> </ul> </li> <li>Use pattern-based structure rather than simple bullet points for better clarity</li> </ul> Example of a best practices file <p>Pattern 1: Add proper error handling with try-except blocks around external function calls.</p> <p>Example code before:</p> <pre><code># Some code that might raise an exception\nreturn process_pr_data(data)\n</code></pre> <p>Example code after:</p> <pre><code>try:\n    # Some code that might raise an exception\n    return process_pr_data(data)\nexcept Exception as e:\n    logger.exception(\"Failed to process request\", extra={\"error\": e})\n</code></pre> <p>Pattern 2: Add defensive null/empty checks before accessing object properties or performing operations on potentially null variables to prevent runtime errors.</p> <p>Example code before:</p> <pre><code>def get_pr_code(pr_data):\n    if \"changed_code\" in pr_data:\n        return pr_data.get(\"changed_code\", \"\")\n    return \"\"\n</code></pre> <p>Example code after:</p> <pre><code>def get_pr_code(pr_data):\n    if pr_data is None:\n        return \"\"\n    if \"changed_code\" in pr_data:\n        return pr_data.get(\"changed_code\", \"\")\n    return \"\"\n</code></pre>"},{"location":"tools/improve/#local-best-practices","title":"Local best practices","text":"<p>For basic usage, create a <code>best_practices.md</code> file in your repository's root directory containing a list of best practices, coding standards, and guidelines specific to your repository.</p> <p>The AI model will use this <code>best_practices.md</code> file as a reference, and in case the PR code violates any of the guidelines, it will create additional suggestions, with a dedicated label: <code>Organization best practice</code>.</p>"},{"location":"tools/improve/#global-hierarchical-best-practices","title":"Global hierarchical best practices","text":"<p>For organizations managing multiple repositories with different requirements, Qodo Merge supports a hierarchical best practices system using a dedicated global configuration repository.</p> <p>Supported scenarios:</p> <ol> <li>Standalone repositories: Individual repositories can have their own specific best practices tailored to their unique requirements</li> <li>Groups of repositories: Repositories can be mapped to shared group-level best practices for consistent standards across similar projects</li> <li>Monorepos with subprojects: Large monorepos can have both repository-level and subproject-level best practices, with automatic path-based matching</li> </ol>"},{"location":"tools/improve/#setting-up-global-hierarchical-best-practices","title":"Setting up global hierarchical best practices","text":"<p>1. Create a new repository named <code>pr-agent-settings</code> in your organization/workspace.</p> <p>2. Build the folder hierarchy in your <code>pr-agent-settings</code> repository, for example:</p> <pre><code>pr-agent-settings/\n\u251c\u2500\u2500 metadata.yaml                    # Maps repos/folders to best practice paths\n\u2514\u2500\u2500 codebase_standards/              # Root for all best practice definitions\n    \u251c\u2500\u2500 global/                      # Global rules, inherited widely\n    \u2502   \u2514\u2500\u2500 best_practices.md\n    \u251c\u2500\u2500 groups/                      # For groups of repositories\n    \u2502   \u251c\u2500\u2500 frontend_repos/\n    \u2502   \u2502   \u2514\u2500\u2500 best_practices.md\n    \u2502   \u251c\u2500\u2500 backend_repos/\n    \u2502   \u2502   \u2514\u2500\u2500 best_practices.md\n    \u2502   \u251c\u2500\u2500 python_repos/\n    \u2502   \u2502   \u2514\u2500\u2500 best_practices.md\n    \u2502   \u251c\u2500\u2500 cpp_repos/\n    \u2502   \u2502   \u2514\u2500\u2500 best_practices.md\n    \u2502   \u2514\u2500\u2500 ...\n    \u251c\u2500\u2500 repo_a/                      # For standalone repositories\n    \u2502   \u2514\u2500\u2500 best_practices.md\n    \u251c\u2500\u2500 monorepo-name/               # For monorepo-specific rules \n    \u2502   \u251c\u2500\u2500 best_practices.md        # Root level monorepo rules\n    \u2502   \u251c\u2500\u2500 service-a/               # Subproject best practices\n    \u2502   \u2502   \u2514\u2500\u2500 best_practices.md\n    \u2502   \u2514\u2500\u2500 service-b/               # Another subproject\n    \u2502       \u2514\u2500\u2500 best_practices.md\n    \u2514\u2500\u2500 ...                          # More repositories\n</code></pre> <p>Note: In this structure, <code>pr-agent-settings</code>, <code>codebase_standards</code>, <code>global</code>, <code>groups</code>, <code>metadata.yaml</code>, and <code>best_practices.md</code> are hardcoded names that must be used exactly as shown. All other names (such as <code>frontend_repos</code>, <code>backend_repos</code>, <code>repo_a</code>, <code>monorepo-name</code>, <code>service-a</code>, etc.) are examples and should be replaced with your actual repository and service names.</p> Grouping and categorizing best practices <ul> <li>Each folder (including the global folder) can contain a single <code>best_practices.md</code> file</li> <li>Organize repository best practices by creating subfolders within the <code>groups</code> folder. Group them by purpose, programming languages, or other categories</li> </ul> <p>3. Define the metadata file <code>metadata.yaml</code> that maps your repositories to their relevant best practices paths, for example:</p> <pre><code># Standalone repos\nrepo_a:\n  best_practices_paths:\n    - \"repo_a\"\n\n# Group-associated repos\nrepo_b:\n  best_practices_paths:\n    - \"groups/backend_repos\"\n\n# Multi-group repos\nrepo_c:\n  best_practices_paths:\n    - \"groups/frontend_repos\"\n    - \"groups/backend_repos\"\n\n# Monorepo with subprojects\nmonorepo-name:\n  best_practices_paths:\n    - \"monorepo-name\"\n  monorepo_subprojects:\n    service-a:\n      best_practices_paths:\n        - \"monorepo-name/service-a\"\n    service-b:\n      best_practices_paths:\n        - \"monorepo-name/service-b\"\n</code></pre> <p>4. Set the following configuration in your global configuration file:</p> <pre><code>[best_practices]\nenable_global_best_practices = true\n</code></pre> Best practices priority and fallback behavior <p>When global best practices are enabled, Qodo Merge follows this priority order:</p> <p>1. Primary: Global hierarchical best practices from <code>pr-agent-settings</code> repository:</p> <pre><code>1.1 If the repository is mapped in `metadata.yaml`, it uses the specified paths\n\n1.2 For monorepos, it automatically collects best practices matching PR file paths\n\n1.3 If no mapping exists, it falls back to the global best practices\n</code></pre> <p>2. Fallback: Local repository <code>best_practices.md</code> file:</p> <pre><code>2.1 Used when global best practices are not found or configured\n\n2.2 Acts as a safety net for repositories not yet configured in the global system\n\n2.3 Local best practices are completely ignored when global best practices are successfully loaded\n</code></pre> Edge cases and behavior <ul> <li>Missing paths: If specified paths in <code>metadata.yaml</code> don't exist in the file system, those paths are skipped</li> <li>Monorepo subproject matching: For monorepos, Qodo Merge automatically matches PR file paths against subproject paths to apply relevant best practices</li> <li>Multiple group inheritance: Repositories can inherit from multiple groups, and all applicable best practices are combined</li> </ul> Dedicated label for best practices suggestions <p>Best practice suggestions are labeled as <code>Organization best practice</code> by default. To customize this label, modify it in your configuration file:</p> <pre><code>[best_practices]\norganization_name = \"...\"\n</code></pre> <p>And the label will be: <code>{organization_name} best practice</code>.</p>"},{"location":"tools/improve/#example-results","title":"Example results","text":""},{"location":"tools/improve/#auto-best-practices","title":"Auto best practices","text":"<p><code>\ud83d\udc8e feature. Platforms supported: GitHub.</code></p> <p><code>Auto best practices</code> is a novel Qodo Merge capability that:</p> <ol> <li>Identifies recurring patterns from accepted suggestions</li> <li>Automatically generates best practices page based on what your team consistently values</li> <li>Applies these learned patterns to future code reviews</li> </ol> <p>This creates an automatic feedback loop where the system continuously learns from your team's choices to provide increasingly relevant suggestions. The system maintains two analysis phases:</p> <ul> <li>Open exploration for new issues</li> <li>Targeted checking against established best practices</li> </ul> <p>Note that when a custom best practices exist, Qodo Merge will still generate an 'auto best practices' wiki file, though it won't use it in the <code>improve</code> tool. Learn more about utilizing 'auto best practices' in our detailed guide.</p>"},{"location":"tools/improve/#relevant-configurations","title":"Relevant configurations","text":"<pre><code>[auto_best_practices]\n# Disable all auto best practices usage or generation\nenable_auto_best_practices = true  \n\n# Disable usage of auto best practices file in the 'improve' tool\nutilize_auto_best_practices = true \n\n# Extra instructions to the auto best practices generation prompt\nextra_instructions = \"\"            \n\n# Max number of patterns to be detected\nmax_patterns = 5                   \n</code></pre>"},{"location":"tools/improve/#multiple-best-practices-sources","title":"Multiple best practices sources","text":"<p>The <code>improve</code> tool will combine best practices from all available sources - global configuration, local configuration, and auto-generated files - to provide you with comprehensive recommendations.</p>"},{"location":"tools/improve/#combining-extra-instructions-and-best-practices","title":"Combining 'extra instructions' and 'best practices'","text":"<p><code>\ud83d\udc8e feature</code></p> <p>The <code>extra instructions</code> configuration is more related to the <code>improve</code> tool prompt. It can be used, for example, to avoid specific suggestions (\"Don't suggest to add try-except block\", \"Ignore changes in toml files\", ...) or to emphasize specific aspects or formats (\"Answer in Japanese\", \"Give only short suggestions\", ...)</p> <p>In contrast, the <code>best_practices.md</code> file is a general guideline for the way code should be written in the repo.</p> <p>Using a combination of both can help the AI model to provide relevant and tailored suggestions.</p>"},{"location":"tools/improve/#usage-tips","title":"Usage Tips","text":""},{"location":"tools/improve/#implementing-the-proposed-code-suggestions","title":"Implementing the proposed code suggestions","text":"<p>Each generated suggestion consists of three key elements:</p> <ol> <li>A single-line summary of the proposed change</li> <li>An expandable section containing a comprehensive description of the suggestion</li> <li>A diff snippet showing the recommended code modification (before and after)</li> </ol> <p>We advise users to apply critical analysis and judgment when implementing the proposed suggestions. In addition to mistakes (which may happen, but are rare), sometimes the presented code modification may serve more as an illustrative example than a directly applicable solution. In such cases, we recommend prioritizing the suggestion's detailed description, using the diff snippet primarily as a supporting reference.</p>"},{"location":"tools/improve/#dual-publishing-mode","title":"Dual publishing mode","text":"<p>Our recommended approach for presenting code suggestions is through a table (<code>--pr_code_suggestions.commitable_code_suggestions=false</code>). This method significantly reduces the PR footprint and allows for quick and easy digestion of multiple suggestions.</p> <p>We also offer a complementary dual publishing mode. When enabled, suggestions exceeding a certain score threshold are not only displayed in the table, but also presented as committable PR comments. This mode helps highlight suggestions deemed more critical.</p> <p>To activate dual publishing mode, use the following setting:</p> <pre><code>[pr_code_suggestions]\ndual_publishing_score_threshold = x\n</code></pre> <p>Where x represents the minimum score threshold (&gt;=) for suggestions to be presented as committable PR comments in addition to the table. Default is -1 (disabled).</p>"},{"location":"tools/improve/#controlling-suggestions-depth","title":"Controlling suggestions depth","text":"<p><code>\ud83d\udc8e feature</code></p> <p>You can control the depth and comprehensiveness of the code suggestions by using the <code>pr_code_suggestions.suggestions_depth</code> parameter.</p> <p>Available options:</p> <ul> <li><code>selective</code> - Shows only suggestions above a score threshold of 6</li> <li><code>regular</code> - Default mode with balanced suggestion coverage  </li> <li><code>exhaustive</code> - Provides maximum suggestion comprehensiveness</li> </ul> <p>(Alternatively, use numeric values: 1, 2, or 3 respectively)</p> <p>We recommend starting with <code>regular</code> mode, then exploring <code>exhaustive</code> mode, which can provide more comprehensive suggestions and enhanced bug detection.</p>"},{"location":"tools/improve/#self-review","title":"Self-review","text":"<p><code>\ud83d\udc8e feature. Platforms supported: GitHub, GitLab</code></p> <p>If you set in a configuration file:</p> <pre><code>[pr_code_suggestions]\ndemand_code_suggestions_self_review = true\n</code></pre> <p>The <code>improve</code> tool will add a checkbox below the suggestions, prompting user to acknowledge that they have reviewed the suggestions. You can set the content of the checkbox text via:</p> <pre><code>[pr_code_suggestions]\ncode_suggestions_self_review_text = \"... (your text here) ...\"\n</code></pre> <p></p> <p>Tip - Reducing visual footprint after self-review \ud83d\udc8e</p> <p>The configuration parameter <code>pr_code_suggestions.fold_suggestions_on_self_review</code> (default is True) can be used to automatically fold the suggestions after the user clicks the self-review checkbox.</p> <p>This reduces the visual footprint of the suggestions, and also indicates to the PR reviewer that the suggestions have been reviewed by the PR author, and don't require further attention.</p> <p>Tip - Demanding self-review from the PR author \ud83d\udc8e</p> <p>By setting: </p><pre><code>[pr_code_suggestions]\napprove_pr_on_self_review = true\n</code></pre> the tool can automatically add an approval when the PR author clicks the self-review checkbox.<p></p> <ul> <li>If you set the number of required reviewers for a PR to 2, this effectively means that the PR author must click the self-review checkbox before the PR can be merged (in addition to a human reviewer).</li> </ul> <p></p> <ul> <li> <p>If you keep the number of required reviewers for a PR to 1 and enable this configuration, this effectively means that the PR author can approve the PR by actively clicking the self-review checkbox.</p> <p>To prevent unauthorized approvals, this configuration defaults to false, and cannot be altered through online comments; enabling requires a direct update to the configuration file and a commit to the repository. This ensures that utilizing the feature demands a deliberate documented decision by the repository owner.</p> </li> </ul>"},{"location":"tools/improve/#how-many-code-suggestions-are-generated","title":"How many code suggestions are generated?","text":"<p>Qodo Merge uses a dynamic strategy to generate code suggestions based on the size of the pull request (PR). Here's how it works:</p>"},{"location":"tools/improve/#1-chunking-large-prs","title":"1. Chunking large PRs","text":"<ul> <li>Qodo Merge divides large PRs into 'chunks'.</li> <li>Each chunk contains up to <code>config.max_model_tokens</code> tokens (default: 32,000).</li> </ul>"},{"location":"tools/improve/#2-generating-suggestions","title":"2. Generating suggestions","text":"<ul> <li>For each chunk, Qodo Merge generates up to <code>pr_code_suggestions.num_code_suggestions_per_chunk</code> suggestions (default: 3).</li> </ul> <p>This approach has two main benefits:</p> <ul> <li>Scalability: The number of suggestions scales with the PR size, rather than being fixed.</li> <li>Quality: By processing smaller chunks, the AI can maintain higher quality suggestions, as larger contexts tend to decrease AI performance.</li> </ul> <p>Note: Chunking is primarily relevant for large PRs. For most PRs (up to 600 lines of code), Qodo Merge will be able to process the entire code in a single call.</p>"},{"location":"tools/improve/#maximum-coverage-configuration","title":"Maximum coverage configuration","text":"<p><code>\ud83d\udc8e feature</code></p> <p>For critical code reviews requiring maximum coverage, you can combine several settings to achieve a \"super exhaustive\" analysis. This is not a built-in mode, but a configuration recipe for advanced use cases.</p> <pre><code># Recipe for maximum suggestion comprehensiveness\n[pr_code_suggestions]\nsuggestions_depth = \"exhaustive\"\nenable_suggestion_type_reuse = true\nnum_code_suggestions_per_chunk = 100\nnum_best_practice_suggestions = 100\n</code></pre> <p>This configuration is recommended for:</p> <ul> <li>Critical code reviews requiring maximum coverage</li> <li>Final reviews before major releases</li> <li>Code quality audits</li> </ul> Performance considerations <p>This configuration will significantly increase:</p> <ul> <li>Analysis time and API costs</li> <li>Number of suggestions generated (potentially overwhelming)</li> <li>Comment volume in your PR</li> </ul> <p>Use this configuration judiciously and consider your team's review capacity.</p>"},{"location":"tools/improve/#configuration-options","title":"Configuration options","text":"General options <p> extra_instructions Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\". commitable_code_suggestions If set to true, the tool will display the suggestions as committable code comments. Default is false. enable_chat_in_code_suggestions If set to true, QM bot will interact with comments made on code changes it has proposed. Default is true. suggestions_depth \ud83d\udc8e  Controls the depth of the suggestions. Can be set to 'selective', 'regular', or 'exhaustive'. Default is 'regular'. dual_publishing_score_threshold Minimum score threshold for suggestions to be presented as committable PR comments in addition to the table. Default is -1 (disabled). focus_only_on_problems If set to true, suggestions will focus primarily on identifying and fixing code problems, and less on style considerations like best practices, maintainability, or readability. Default is true. persistent_comment If set to true, the improve comment will be persistent, meaning that every new improve request will edit the previous one. Default is true. suggestions_score_threshold  Any suggestion with importance score less than this threshold will be removed. Default is 0. Highly recommend not to set this value above 7-8, since above it may clip relevant suggestions that can be useful.  apply_suggestions_checkbox  Enable the checkbox to create a committable suggestion. Default is true. enable_more_suggestions_checkbox  Enable the checkbox to generate more suggestions. Default is true. enable_help_text If set to true, the tool will display a help text in the comment. Default is false. enable_chat_text If set to true, the tool will display a reference to the PR chat in the comment. Default is false. publish_output_no_suggestions If set to true, the tool will publish a comment even if no suggestions were found. Default is true. wiki_page_accepted_suggestions If set to true, the tool will automatically track accepted suggestions in a dedicated wiki page called <code>.pr_agent_accepted_suggestions</code>. Default is true. allow_thumbs_up_down If set to true, all code suggestions will have thumbs up and thumbs down buttons, to encourage users to provide feedback on the suggestions. Default is false. Note that this feature is for statistics tracking. It will not affect future feedback from the AI model. </p> Params for number of suggestions and AI calls <p> auto_extended_mode Enable chunking the PR code and running the tool on each chunk. Default is true. num_code_suggestions_per_chunk Number of code suggestions provided by the 'improve' tool, per chunk. Default is 3. num_best_practice_suggestions \ud83d\udc8e Number of code suggestions provided by the 'improve' tool for best practices. Default is 1. max_number_of_calls Maximum number of chunks. Default is 3. </p>"},{"location":"tools/improve/#understanding-ai-code-suggestions","title":"Understanding AI Code Suggestions","text":"<ul> <li>AI Limitations: AI models for code are getting better and better, but they are not flawless. Not all the suggestions will be perfect, and a user should not accept all of them automatically. Critical reading and judgment are required. Mistakes of the AI are rare but can happen, and it is usually quite easy for a human to spot them.</li> <li>Purpose of Suggestions:<ul> <li>Self-reflection: The suggestions aim to enable developers to self-reflect and improve their pull requests. This process can help to identify blind spots, uncover missed edge cases, and enhance code readability and coherency. Even when a specific code suggestion isn't suitable, the underlying issue it highlights often reveals something important that might deserve attention.</li> <li>Bug detection: The suggestions also alert on any critical bugs that may have been identified during the analysis. This provides an additional safety net to catch potential issues before they make it into production. It's perfectly acceptable to implement only the suggestions you find valuable for your specific context.</li> </ul> </li> <li>Hierarchy: Presenting the suggestions in a structured hierarchical table enables the user to quickly understand them, and to decide which ones are relevant and which are not.</li> <li>Customization: To guide the model to suggestions that are more relevant to the specific needs of your project, we recommend using the <code>extra_instructions</code> and <code>best practices</code> fields.</li> <li>Model Selection: SaaS users can also choose between different models. For specific programming languages or use cases, some models may perform better than others.</li> <li>Interactive usage: The interactive PR chat also provides an easy way to get more tailored suggestions and feedback from the AI model.</li> </ul>"},{"location":"tools/improve_component/","title":"\ud83d\udc8e Improve Components","text":""},{"location":"tools/improve_component/#overview","title":"Overview","text":"<p>The <code>improve_component</code> tool generates code suggestions for a specific code component that has changed in the PR. it can be invoked manually by commenting on any PR:</p> <pre><code>/improve_component component_name\n</code></pre> <p>To get a list of the components that changed in the PR and choose the relevant component interactively, use the <code>analyze</code> tool.</p>"},{"location":"tools/improve_component/#example-usage","title":"Example usage","text":"<p>Invoke the tool manually by commenting <code>/improve_component</code> on any PR:</p> <p></p> <p>The tool will generate code suggestions for the selected component (if no component is stated, it will generate code suggestions for the largest component):</p> <p></p> <p>Notes</p> <ul> <li>Language that are currently supported by the tool: <code>Python, Java, C++, JavaScript, TypeScript, C#, Go, Ruby, PHP, Rust, Kotlin, Scala</code></li> <li>This tool can also be triggered interactively by using the <code>analyze</code> tool.</li> </ul>"},{"location":"tools/improve_component/#configuration-options","title":"Configuration options","text":"<ul> <li><code>num_code_suggestions</code>: number of code suggestions to provide. Default is 4</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"focus on ...\".</li> <li><code>file</code>: in case there are several components with the same name, you can specify the relevant file.</li> <li><code>class_name</code>: in case there are several methods with the same name in the same file, you can specify the relevant class name.</li> </ul>"},{"location":"tools/pr_to_ticket/","title":"\ud83d\udc8e PR to Ticket","text":"<p><code>Platforms supported: GitHub, GitLab, Bitbucket</code></p> <p><code>Supported Ticket providers: Jira, Linear, GitHub Issues, Gitlab Issues</code></p>"},{"location":"tools/pr_to_ticket/#overview","title":"Overview","text":"<p>The <code>create_ticket</code> tool automatically generates tickets in ticket tracking systems (<code>Jira</code>, <code>Linear</code>, or <code>GitHub Issues</code> and <code>Gitlab issues</code>) based on PR content.</p> <p>It analyzes the PR's data (code changes, commit messages, and description) to create well-structured tickets that capture the essence of the development work, helping teams maintain traceability between code changes and project management systems.</p> <p>When a ticket is created, it appears in the PR description under an <code>Auto-created Ticket</code> section, complete with a link to the generated ticket.</p> <p></p> <p>Pre-requisites</p> <ul> <li>To use this tool you need to integrate your ticketing system with Qodo-merge, follow the Ticket Compliance Documentation.</li> <li>For Jira Cloud users, please re-integrate your connection through the qodo merge integration page to enable the <code>update</code> permission required for ticket creation</li> <li>You need to configure the project key in ticket corresponding to the repository where the PR is created. This is done by adding the <code>default_project_key</code>.</li> </ul> <pre><code>[pr_to_ticket]\ndefault_project_key = \"PROJECT_KEY\" # e.g., \"SCRUM\"\n</code></pre>"},{"location":"tools/pr_to_ticket/#usage","title":"Usage","text":"<p>there are 3 ways to use the <code>create_ticket</code> tool:</p> <ol> <li>Automatic Ticket Creation</li> <li>Interactive Triggering via Compliance Tool</li> <li>Manual Ticket Creation</li> </ol>"},{"location":"tools/pr_to_ticket/#automatic-ticket-creation","title":"Automatic Ticket Creation","text":"<p>The tool can be configured to automatically create tickets when a PR is opened or updated and the PR does not already have a ticket associated with it.  This ensures that every code change is documented in the ticketing system without manual intervention.</p> <p>To configure automatic ticket creation, add the following to <code>.pr_agent.toml</code>:</p> <pre><code>[pr_description]\nauto_create_ticket = true\n</code></pre>"},{"location":"tools/pr_to_ticket/#interactive-triggering-via-compliance-tool","title":"Interactive Triggering via Compliance Tool","text":"<p><code>Supported only in Github and Gitlab</code></p> <p>The tool can be triggered interactively through a checkbox in the compliance tool. This allows users to create tickets as part of their PR Compliance Review workflow.</p> <p></p> <ul> <li>After clicking the checkbox, the tool will create a ticket and will add/update the <code>PR Description</code> with a section called <code>Auto-created Ticket</code> with the link to the created ticket.</li> <li>Then you can click <code>update</code> in the <code>Ticket compliance</code> section in the <code>Compliance</code> tool </li> </ul> <p></p>"},{"location":"tools/pr_to_ticket/#manual-ticket-creation","title":"Manual Ticket Creation","text":"<p>Users can manually trigger the ticket creation process from the PR interface.</p> <p>To trigger ticket creation manually, the user can call this tool from the PR comment:</p> <pre><code>/create_ticket\n</code></pre> <p>After triggering, the tool will create a ticket and will add/update the <code>PR Description</code> with a section called <code>Auto-created Ticket</code> with the link to the created ticket.</p>"},{"location":"tools/pr_to_ticket/#configuration","title":"Configuration","text":""},{"location":"tools/pr_to_ticket/#configuration-options","title":"Configuration Options","text":"Configuration <p> default_project_key The default project key for your ticketing system (e.g., <code>SCRUM</code>). This is required unless <code>fallback_to_git_provider_issues</code> is set to <code>true</code>. default_base_url If your organization have integrated to multiple ticketing systems, you can set the default base URL for the ticketing system. This will be used to create tickets in the default system. Example: <code>https://YOUR-ORG.atlassian.net</code>. fallback_to_git_provider_issues If set to <code>true</code>, the tool will create issues in the Git provider's issue tracker (GitHub, Gitlab) if the <code>default_project_key</code> is not configured in the repository configuration. Default is <code>false</code>. </p>"},{"location":"tools/pr_to_ticket/#helping-your-organization-meet-soc-2-requirements","title":"Helping Your Organization Meet SOC-2 Requirements","text":"<p>The <code>create_ticket</code> tool helps your organization satisfy SOC-2 compliance. By automatically creating tickets from PRs and establishing bidirectional links between them, it ensures every code change is traceable to its corresponding business requirement or task.</p>"},{"location":"tools/review/","title":"Review","text":""},{"location":"tools/review/#overview","title":"Overview","text":"<p>The <code>review</code> tool scans the PR code changes, and generates feedback about the PR, aiming to aid the reviewing process.  The tool can be triggered automatically every time a new PR is opened, or can be invoked manually by commenting on any PR:</p> <pre><code>/review\n</code></pre> <p>Note that the main purpose of the <code>review</code> tool is to provide the PR reviewer with useful feedback and insights. The PR author, in contrast, may prefer to save time and focus on the output of the improve tool, which provides actionable code suggestions.</p> <p>(Read more about the different personas in the PR process and how Qodo Merge aims to assist them in our blog)</p>"},{"location":"tools/review/#example-usage","title":"Example usage","text":""},{"location":"tools/review/#manual-triggering","title":"Manual triggering","text":"<p>Invoke the tool manually by commenting <code>/review</code> on any PR:</p> <p></p> <p>After ~30 seconds, the tool will generate a review for the PR:</p> <p></p> <p>If you want to edit configurations, add the relevant ones to the command:</p> <pre><code>/review --pr_reviewer.some_config1=... --pr_reviewer.some_config2=...\n</code></pre>"},{"location":"tools/review/#automatic-triggering","title":"Automatic triggering","text":"<p>To run the <code>review</code> automatically when a PR is opened, define in a configuration file:</p> <pre><code>[github_app]\npr_commands = [\n    \"/review\",\n    ...\n]\n\n[pr_reviewer]\nextra_instructions = \"...\"\n...\n</code></pre> <ul> <li>The <code>pr_commands</code> lists commands that will be executed automatically when a PR is opened.</li> <li>The <code>[pr_reviewer]</code> section contains the configurations for the <code>review</code> tool you want to edit (if any).</li> </ul>"},{"location":"tools/review/#configuration-options","title":"Configuration options","text":"General options <p> persistent_comment If set to true, the review comment will be persistent, meaning that every new review request will edit the previous one. Default is true. final_update_message When set to true, updating a persistent review comment during online commenting will automatically add a short comment with a link to the updated review in the pull request .Default is true. extra_instructions Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\". enable_help_text If set to true, the tool will display a help text in the comment. Default is false. num_max_findings Number of maximum returned findings. Default is 3. </p> Enable\\disable specific sub-sections <p> require_score_review If set to true, the tool will add a section that scores the PR. Default is false. require_tests_review If set to true, the tool will add a section that checks if the PR contains tests. Default is true. require_estimate_effort_to_review If set to true, the tool will add a section that estimates the effort needed to review the PR. Default is true. require_estimate_contribution_time_cost If set to true, the tool will add a section that estimates the time required for a senior developer to create and submit such changes. Default is false. require_can_be_split_review If set to true, the tool will add a section that checks if the PR contains several themes, and can be split into smaller PRs. Default is false. require_security_review If set to true, the tool will add a section that checks if the PR contains a possible security or vulnerability issue. Default is true. require_todo_scan If set to true, the tool will add a section that lists TODO comments found in the PR code changes. Default is false.      require_ticket_analysis_review If set to true, and the PR contains a GitHub or Jira ticket link, the tool will add a section that checks if the PR in fact fulfilled the ticket requirements. Default is true. </p> Adding PR labels <p>You can enable\\disable the <code>review</code> tool to add specific labels to the PR:</p> <p> enable_review_labels_security If set to true, the tool will publish a 'possible security issue' label if it detects a security issue. Default is true. enable_review_labels_effort If set to true, the tool will publish a 'Review effort x/5' label (1\u20135 scale). Default is true. </p>"},{"location":"tools/review/#usage-tips","title":"Usage Tips","text":""},{"location":"tools/review/#general-guidelines","title":"General guidelines","text":"<p>The <code>review</code> tool provides a collection of configurable feedbacks about a PR. It is recommended to review the Configuration options section, and choose the relevant options for your use case.</p> <p>Some of the features that are disabled by default are quite useful, and should be considered for enabling. For example: <code>require_score_review</code>, and more.</p> <p>On the other hand, if you find one of the enabled features to be irrelevant for your use case, disable it. No default configuration can fit all use cases.</p>"},{"location":"tools/review/#automation","title":"Automation","text":"<p>When you first install Qodo Merge app, the default mode for the <code>review</code> tool is: </p><pre><code>pr_commands = [\"/review\", ...]\n</code></pre> Meaning the <code>review</code> tool will run automatically on every PR, without any additional configurations. Edit this field to enable/disable the tool, or to change the configurations used.<p></p>"},{"location":"tools/review/#auto-generated-pr-labels-by-the-review-tool","title":"Auto-generated PR labels by the Review Tool","text":"<p>The <code>review</code> can tool automatically add labels to your Pull Requests:</p> <ul> <li><code>possible security issue</code>: This label is applied if the tool detects a potential security vulnerability in the PR's code. This feedback is controlled by the 'enable_review_labels_security' flag (default is true).</li> <li><code>review effort [x/5]</code>: This label estimates the effort required to review the PR on a relative scale of 1 to 5, where 'x' represents the assessed effort. This feedback is controlled by the 'enable_review_labels_effort' flag (default is true).</li> <li><code>ticket compliance</code>: Adds a label indicating code compliance level (\"Fully compliant\" | \"PR Code Verified\" | \"Partially compliant\" | \"Not compliant\") to any GitHub/Jira/Linea ticket linked in the PR. Controlled by the 'require_ticket_labels' flag (default: false). If 'require_no_ticket_labels' is also enabled, PRs without ticket links will receive a \"No ticket found\" label.</li> </ul>"},{"location":"tools/review/#auto-blocking-prs-from-being-merged-based-on-the-generated-labels","title":"Auto-blocking PRs from being merged based on the generated labels","text":"<p>You can configure a CI/CD Action to prevent merging PRs with specific labels. For example, implement a dedicated GitHub Action.</p> <p>This approach helps ensure PRs with potential security issues or ticket compliance problems will not be merged without further review.</p> <p>Since AI may make mistakes or lack complete context, use this feature judiciously. For flexibility, users with appropriate permissions can remove generated labels when necessary. When a label is removed, this action will be automatically documented in the PR discussion, clearly indicating it was a deliberate override by an authorized user to allow the merge.</p>"},{"location":"tools/review/#extra-instructions","title":"Extra instructions","text":"<p>Extra instructions are important. The <code>review</code> tool can be configured with extra instructions, which can be used to guide the model to a feedback tailored to the needs of your project.</p> <p>Be specific, clear, and concise in the instructions. With extra instructions, you are the prompter. Specify the relevant sub-tool, and the relevant aspects of the PR that you want to emphasize.</p> <p>Examples of extra instructions: </p><pre><code>[pr_reviewer]\nextra_instructions=\"\"\"\\\nIn the code feedback section, emphasize the following:\n- Does the code logic cover relevant edge cases?\n- Is the code logic clear and easy to understand?\n- Is the code logic efficient?\n...\n\"\"\"\n</code></pre> Use triple quotes to write multi-line instructions. Use bullet points to make the instructions more readable.<p></p>"},{"location":"tools/scan_repo_discussions/","title":"\ud83d\udc8e Scan Repo Discussions","text":"<p><code>Platforms supported: GitHub</code></p>"},{"location":"tools/scan_repo_discussions/#overview","title":"Overview","text":"<p>The <code>scan_repo_discussions</code> tool analyzes code discussions (meaning review comments over code lines) from merged pull requests over the past 12 months. It processes these discussions alongside other PR metadata to identify recurring patterns related to best practices in team feedback and code reviews, generating a comprehensive <code>best_practices.md</code> document that distills key insights and recommendations.</p> <p>This file captures repository-specific patterns derived from your team's actual workflow and discussions, rather than more generic best practices. It will be utilized by Qodo Merge to provide tailored suggestions for improving code quality in future pull requests.</p> <p>Active repositories are needed</p> <p>The tool is designed to work with real-life repositories, as it relies on actual discussions to generate meaningful insights. At least 50 merged PRs are required to generate the <code>best_practices.md</code> file.</p> <p>Additional customization</p> <p>Teams are encouraged to further customize and refine these insights to better align with their specific development priorities and contexts. This can be done by editing the <code>best_practices.md</code> file directly when the PR is created, or iteratively over time to enhance the 'best practices' suggestions provided by Qodo Merge.</p> <p>The tool can be invoked manually by commenting on any PR:</p> <pre><code>/scan_repo_discussions\n</code></pre> <p>As a response, the bot will create a new PR that contains an auto-generated <code>best_practices.md</code> file. Note that the scan can take several minutes to complete, since up to 250 PRs are scanned.</p>"},{"location":"tools/scan_repo_discussions/#example-usage","title":"Example usage","text":"<p>The PR created by the bot:</p> <p></p> <p>The <code>best_practices.md</code> file in the PR:</p> <p></p>"},{"location":"tools/scan_repo_discussions/#configuration-options","title":"Configuration options","text":"<ul> <li>Use <code>/scan_repo_discussions --scan_repo_discussions.force_scan=true</code> to force generating a PR with a new <code>best_practices.md</code> file, even if it already exists (by default, the bot will not generate a new file if it already exists).</li> <li>Use <code>/scan_repo_discussions --scan_repo_discussions.days_back=X</code> to specify the number of days back to scan for discussions. The default is 365 days.</li> <li>Use <code>/scan_repo_discussions --scan_repo_discussions.minimal_number_of_prs=X</code> to specify the minimum number of merged PRs needed to generate the <code>best_practices.md</code> file. The default is 50 PRs.</li> </ul>"},{"location":"tools/similar_code/","title":"\ud83d\udc8e Similar Code","text":"<p><code>Platforms supported: GitHub</code></p>"},{"location":"tools/similar_code/#overview","title":"Overview","text":"<p>The similar code tool retrieves the most similar code components from inside the organization's codebase, or from open-source code.</p> <p>For example:</p> <p>A <code>Global Search</code> for a method called <code>chat_completion</code>:</p> <p></p> <p>Qodo Merge will examine the code component and will extract the most relevant keywords to search for similar code:</p> <ul> <li><code>extracted keywords</code>: the keywords that were extracted from the code by Qodo Merge. the link will open a search page with the extracted keywords, to allow the user to modify the search if needed.</li> <li><code>search context</code>: the context in which the search will be performed, organization's codebase or open-source code (Global).</li> <li><code>similar code</code>: the most similar code components found. the link will open the code component in the relevant file.</li> <li><code>relevant repositories</code>: the open-source repositories in which that are relevant to the searched code component and it's keywords.</li> </ul> <p>Search result link example:</p> <p></p> <p>An <code>Organization Search</code>:</p> <p></p>"},{"location":"tools/similar_code/#how-to-use","title":"How to use","text":""},{"location":"tools/similar_code/#manually","title":"Manually","text":"<p>To invoke the <code>similar code</code> tool manually, comment on the PR:</p> <pre><code>/find_similar_component COMPONENT_NAME\n</code></pre> <p>Where <code>COMPONENT_NAME</code> should be the name of a code component in the PR (class, method, function).</p> <p>If there is a name ambiguity, there are two configurations that will help the tool to find the correct component:</p> <ul> <li><code>--pr_find_similar_component.file</code>: in case there are several components with the same name, you can specify the relevant file.</li> <li><code>--pr_find_similar_component.class_name</code>: in case there are several methods with the same name in the same file, you can specify the relevant class name.</li> </ul> <p>example:</p> <pre><code>/find_similar_component COMPONENT_NAME --pr_find_similar_component.file=FILE_NAME\n</code></pre>"},{"location":"tools/similar_code/#automatically-via-analyze-table","title":"Automatically (via Analyze table)","text":"<p>It can be invoked automatically from the analyze table, can be accessed by:</p> <pre><code>/analyze\n</code></pre> <p>Choose the components you want to find similar code for, and click on the <code>similar</code> checkbox.</p> <p></p> <p>You can search for similar code either within the organization's codebase or globally, which includes open-source repositories. Each result will include the relevant code components along with their associated license details.</p> <p></p>"},{"location":"tools/similar_code/#configuration-options","title":"Configuration options","text":"<ul> <li><code>search_from_org</code>: if set to true, the tool will search for similar code in the organization's codebase. Default is false.</li> <li><code>number_of_keywords</code>: number of keywords to use for the search. Default is 5.</li> <li><code>number_of_results</code>: the maximum number of results to present. Default is 5.</li> </ul>"},{"location":"tools/similar_issues/","title":"Similar issues","text":""},{"location":"tools/similar_issues/#overview","title":"Overview","text":"<p>The similar issue tool retrieves the most similar issues to the current issue. It can be invoked manually by commenting on any PR:</p> <pre><code>/similar_issue\n</code></pre>"},{"location":"tools/similar_issues/#example-usage","title":"Example usage","text":"<p>Note that to perform retrieval, the <code>similar_issue</code> tool indexes all the repo previous issues (once).</p>"},{"location":"tools/similar_issues/#selecting-a-vector-database","title":"Selecting a Vector Database","text":"<p>Configure your preferred database by changing the <code>pr_similar_issue</code> parameter in <code>configuration.toml</code> file.</p>"},{"location":"tools/similar_issues/#available-options","title":"Available Options","text":"<p>Choose from the following Vector Databases:</p> <ol> <li>LanceDB</li> <li>Pinecone</li> <li>Qdrant</li> </ol>"},{"location":"tools/similar_issues/#pinecone-configuration","title":"Pinecone Configuration","text":"<p>To use Pinecone with the <code>similar issue</code> tool, add these credentials to <code>.secrets.toml</code> (or set as environment variables):</p> <pre><code>[pinecone]\napi_key = \"...\"\nenvironment = \"...\"\n</code></pre> <p>These parameters can be obtained by registering to Pinecone.</p>"},{"location":"tools/similar_issues/#qdrant-configuration","title":"Qdrant Configuration","text":"<p>To use Qdrant with the <code>similar issue</code> tool, add these credentials to <code>.secrets.toml</code> (or set as environment variables):</p> <pre><code>[qdrant]\nurl = \"https://YOUR-QDRANT-URL\" # e.g., https://xxxxxxxx-xxxxxxxx.eu-central-1-0.aws.cloud.qdrant.io\napi_key = \"...\"\n</code></pre> <p>Then select Qdrant in <code>configuration.toml</code>:</p> <pre><code>[pr_similar_issue]\nvectordb = \"qdrant\"\n</code></pre> <p>You can get a free managed Qdrant instance from Qdrant Cloud.</p>"},{"location":"tools/similar_issues/#how-to-use","title":"How to use","text":"<ul> <li> <p>To invoke the 'similar issue' tool from CLI, run: <code>python3 cli.py --issue_url=... similar_issue</code></p> </li> <li> <p>To invoke the 'similar' issue tool via online usage, comment on a PR: <code>/similar_issue</code></p> </li> <li> <p>You can also enable the 'similar issue' tool to run automatically when a new issue is opened, by adding it to the pr_commands list in the github_app section</p> </li> </ul>"},{"location":"tools/test/","title":"\ud83d\udc8e Generate Tests","text":""},{"location":"tools/test/#overview","title":"Overview","text":"<p>By combining LLM abilities with static code analysis, the <code>test</code> tool generates tests for a selected component, based on the PR code changes. It can be invoked manually by commenting on any PR:</p> <pre><code>/test component_name\n</code></pre> <p>where 'component_name' is the name of a specific component in the PR. To get a list of the components that changed in the PR and choose the relevant component interactively, use the <code>analyze</code> tool.</p>"},{"location":"tools/test/#example-usage","title":"Example usage","text":"<p>Invoke the tool manually by commenting <code>/test</code> on any PR: The tool will generate tests for the selected component (if no component is stated, it will generate tests for largest component):</p> <p></p> <p>(Example taken from here):</p> <p>Notes</p> <ul> <li>The following languages are currently supported: <code>Python, Java, C++, JavaScript, TypeScript, C#, Go, Ruby, PHP, Rust, Kotlin, Scala</code></li> <li>This tool can also be triggered interactively by using the <code>analyze</code> tool.</li> </ul>"},{"location":"tools/test/#configuration-options","title":"Configuration options","text":"<ul> <li><code>num_tests</code>: number of tests to generate. Default is 3.</li> <li><code>testing_framework</code>: the testing framework to use. If not set, for Python it will use <code>pytest</code>, for Java it will use <code>JUnit</code>, for C++ it will use <code>Catch2</code>, and for JavaScript and TypeScript it will use <code>jest</code>.</li> <li><code>avoid_mocks</code>: if set to true, the tool will try to avoid using mocks in the generated tests. Note that even if this option is set to true, the tool might still use mocks if it cannot generate a test without them. Default is true.</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"use the following mock injection scheme: ...\".</li> <li><code>file</code>: in case there are several components with the same name, you can specify the relevant file.</li> <li><code>class_name</code>: in case there are several methods with the same name in the same file, you can specify the relevant class name.</li> <li><code>enable_help_text</code>: if set to true, the tool will add a help text to the PR comment. Default is true.</li> </ul>"},{"location":"tools/update_changelog/","title":"Update Changelog","text":""},{"location":"tools/update_changelog/#overview","title":"Overview","text":"<p>The <code>update_changelog</code> tool automatically updates the CHANGELOG.md file with the PR changes. It can be invoked manually by commenting on any PR:</p> <pre><code>/update_changelog\n</code></pre>"},{"location":"tools/update_changelog/#example-usage","title":"Example usage","text":""},{"location":"tools/update_changelog/#configuration-options","title":"Configuration options","text":"<p>Under the section <code>pr_update_changelog</code>, the configuration file contains options to customize the 'update changelog' tool:</p> <ul> <li><code>push_changelog_changes</code>: whether to push the changes to CHANGELOG.md, or just publish them as a comment. Default is false (publish as comment).</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"Use the following structure: ...\"</li> <li><code>add_pr_link</code>: whether the model should try to add a link to the PR in the changelog. Default is true.</li> <li><code>skip_ci_on_push</code>: whether the commit message (when <code>push_changelog_changes</code> is true) will include the term \"[skip ci]\", preventing CI tests to be triggered on the changelog commit. Default is true.</li> </ul>"},{"location":"usage-guide/","title":"Usage guide","text":""},{"location":"usage-guide/#usage-guide","title":"Usage guide","text":"<p>This section provides a detailed guide on how to use Qodo Merge. It includes information on how to adjust Qodo Merge configurations, define which tools will run automatically, and other advanced configurations.</p> <ul> <li>Introduction</li> <li>Enabling a Wiki</li> <li>Configuration File</li> <li>Usage and Automation<ul> <li>Local Repo (CLI)</li> <li>Online Usage</li> <li>GitHub App</li> <li>GitHub Action</li> <li>GitLab Webhook</li> <li>Gitea Webhook</li> <li>BitBucket App</li> <li>Azure DevOps Provider</li> </ul> </li> <li>Managing Mail Notifications</li> <li>Changing a Model</li> <li>Additional Configurations<ul> <li>Ignoring files from analysis</li> <li>Extra instructions</li> <li>Working with large PRs</li> <li>Changing a model</li> </ul> </li> <li>FAQ</li> <li>Qodo Merge Models</li> </ul>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/","title":"EXAMPLE BEST PRACTICE","text":""},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#recommend-python-best-practices","title":"Recommend Python Best Practices","text":"<p>This document outlines a series of recommended best practices for Python development. These guidelines aim to improve code quality, maintainability, and readability.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#imports","title":"Imports","text":"<p>Use  <code>import</code>  statements for packages and modules only, not for individual types, classes, or functions.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#definition","title":"Definition","text":"<p>Reusability mechanism for sharing code from one module to another.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision","title":"Decision","text":"<ul> <li>Use  <code>import x</code>  for importing packages and modules.</li> <li>Use  <code>from x import y</code>  where  <code>x</code>  is the package prefix and  <code>y</code>  is the module name with no prefix.</li> <li>Use  <code>from x import y as z</code>  in any of the following circumstances:</li> <li>Two modules named  <code>y</code>  are to be imported.</li> <li><code>y</code>  conflicts with a top-level name defined in the current module.</li> <li><code>y</code>  conflicts with a common parameter name that is part of the public API (e.g.,  <code>features</code>).</li> <li><code>y</code>  is an inconveniently long name, or too generic in the context of your code</li> <li>Use  <code>import y as z</code>  only when  <code>z</code>  is a standard abbreviation (e.g.,  <code>import numpy as np</code>).</li> </ul> <p>For example the module  <code>sound.effects.echo</code>  may be imported as follows:</p> <pre><code>from sound.effects import echo\n...\necho.EchoFilter(input, output, delay=0.7, atten=4)\n</code></pre> <p>Do not use relative names in imports. Even if the module is in the same package, use the full package name. This helps prevent unintentionally importing a package twice.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#exemptions","title":"Exemptions","text":"<p>Exemptions from this rule:</p> <ul> <li>Symbols from the following modules are used to support static analysis and type checking:</li> <li><code>typing</code>  module</li> <li><code>collections.abc</code>  module</li> <li><code>typing_extensions</code>  module</li> <li>Redirects from the  six.moves module.</li> </ul>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#packages","title":"Packages","text":"<p>Import each module using the full pathname location of the module.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_1","title":"Decision","text":"<p>All new code should import each module by its full package name.</p> <p>Imports should be as follows:</p> <pre><code>Yes:\n  # Reference absl.flags in code with the complete name (verbose).\n  import absl.flags\n  from doctor.who import jodie\n\n  _FOO = absl.flags.DEFINE_string(...)\n</code></pre> <pre><code>Yes:\n  # Reference flags in code with just the module name (common).\n  from absl import flags\n  from doctor.who import jodie\n\n  _FOO = flags.DEFINE_string(...)\n</code></pre> <p>(assume this file lives in  <code>doctor/who/</code>  where  <code>jodie.py</code>  also exists)</p> <pre><code>No:\n  # Unclear what module the author wanted and what will be imported.  The actual\n  # import behavior depends on external factors controlling sys.path.\n  # Which possible jodie module did the author intend to import?\n  import jodie\n</code></pre> <p>The directory the main binary is located in should not be assumed to be in  <code>sys.path</code>  despite that happening in some environments. This being the case, code should assume that  <code>import jodie</code>  refers to a third-party or top-level package named  <code>jodie</code>, not a local  <code>jodie.py</code>.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#default-iterators-and-operators","title":"Default Iterators and Operators","text":"<p>Use default iterators and operators for types that support them, like lists, dictionaries, and files.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#definition_1","title":"Definition","text":"<p>Container types, like dictionaries and lists, define default iterators and membership test operators (\u201cin\u201d and \u201cnot in\u201d).</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_2","title":"Decision","text":"<p>Use default iterators and operators for types that support them, like lists, dictionaries, and files. The built-in types define iterator methods, too. Prefer these methods to methods that return lists, except that you should not mutate a container while iterating over it.</p> <pre><code>Yes:  for key in adict: ...\n      if obj in alist: ...\n      for line in afile: ...\n      for k, v in adict.items(): ...\n</code></pre> <pre><code>No:   for key in adict.keys(): ...\n      for line in afile.readlines(): ...\n</code></pre>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#lambda-functions","title":"Lambda Functions","text":"<p>Okay for one-liners. Prefer generator expressions over  <code>map()</code>  or  <code>filter()</code>  with a  <code>lambda</code>.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_3","title":"Decision","text":"<p>Lambdas are allowed. If the code inside the lambda function spans multiple lines or is longer than 60-80 chars, it might be better to define it as a regular  nested function.</p> <p>For common operations like multiplication, use the functions from the  <code>operator</code>  module instead of lambda functions. For example, prefer  <code>operator.mul</code>  to  <code>lambda x, y: x * y</code>.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#default-argument-values","title":"Default Argument Values","text":"<p>Okay in most cases.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#definition_2","title":"Definition","text":"<p>You can specify values for variables at the end of a function\u2019s parameter list, e.g.,  <code>def foo(a, b=0):</code>. If  <code>foo</code>  is called with only one argument,  <code>b</code>  is set to 0. If it is called with two arguments,  <code>b</code>  has the value of the second argument.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_4","title":"Decision","text":"<p>Okay to use with the following caveat:</p> <p>Do not use mutable objects as default values in the function or method definition.</p> <pre><code>Yes: def foo(a, b=None):\n         if b is None:\n             b = []\nYes: def foo(a, b: Sequence | None = None):\n         if b is None:\n             b = []\nYes: def foo(a, b: Sequence = ()):  # Empty tuple OK since tuples are immutable.\n         ...\n</code></pre> <pre><code>from absl import flags\n_FOO = flags.DEFINE_string(...)\n\nNo:  def foo(a, b=[]):\n         ...\nNo:  def foo(a, b=time.time()):  # Is `b` supposed to represent when this module was loaded?\n         ...\nNo:  def foo(a, b=_FOO.value):  # sys.argv has not yet been parsed...\n         ...\nNo:  def foo(a, b: Mapping = {}):  # Could still get passed to unchecked code.\n         ...\n</code></pre>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#truefalse-evaluations","title":"True/False Evaluations","text":"<p>Use the \u201cimplicit\u201d false if possible, e.g.,  <code>if foo:</code>  rather than  <code>if foo != []:</code></p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#lexical-scoping","title":"Lexical Scoping","text":"<p>Okay to use.</p> <p>An example of the use of this feature is:</p> <pre><code>def get_adder(summand1: float) -&gt; Callable[[float], float]:\n    \"\"\"Returns a function that adds numbers to a given number.\"\"\"\n    def adder(summand2: float) -&gt; float:\n        return summand1 + summand2\n\n    return adder\n</code></pre>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_5","title":"Decision","text":"<p>Okay to use.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#threading","title":"Threading","text":"<p>Do not rely on the atomicity of built-in types.</p> <p>While Python\u2019s built-in data types such as dictionaries appear to have atomic operations, there are corner cases where they aren\u2019t atomic (e.g. if  <code>__hash__</code>  or  <code>__eq__</code>  are implemented as Python methods) and their atomicity should not be relied upon. Neither should you rely on atomic variable assignment (since this in turn depends on dictionaries).</p> <p>Use the  <code>queue</code>  module\u2019s  <code>Queue</code>  data type as the preferred way to communicate data between threads. Otherwise, use the  <code>threading</code>  module and its locking primitives. Prefer condition variables and  <code>threading.Condition</code>  instead of using lower-level locks.</p>"},{"location":"usage-guide/additional_configurations/","title":"Additional Configurations","text":""},{"location":"usage-guide/additional_configurations/#show-possible-configurations","title":"Show possible configurations","text":"<p>The possible configurations of Qodo Merge are stored in here. In the tools page you can find explanations on how to use these configurations for each tool.</p> <p>To print all the available configurations as a comment on your PR, you can use the following command:</p> <pre><code>/config\n</code></pre> <p></p> <p>To view the actual configurations used for a specific tool, after all the user settings are applied, you can add for each tool a <code>--config.output_relevant_configurations=true</code> suffix. For example:</p> <pre><code>/improve --config.output_relevant_configurations=true\n</code></pre> <p>Will output an additional field showing the actual configurations used for the <code>improve</code> tool.</p> <p></p>"},{"location":"usage-guide/additional_configurations/#ignoring-files-from-analysis","title":"Ignoring files from analysis","text":"<p>In some cases, you may want to exclude specific files or directories from the analysis performed by Qodo Merge. This can be useful, for example, when you have files that are generated automatically or files that shouldn't be reviewed, like vendor code.</p> <p>You can ignore files or folders using the following methods:</p> <ul> <li><code>IGNORE.GLOB</code></li> <li><code>IGNORE.REGEX</code></li> </ul> <p>which you can edit to ignore files or folders based on glob or regex patterns.</p>"},{"location":"usage-guide/additional_configurations/#example-usage","title":"Example usage","text":"<p>Let's look at an example where we want to ignore all files with <code>.py</code> extension from the analysis.</p> <p>To ignore Python files in a PR with online usage, comment on a PR: <code>/review --ignore.glob=\"['*.py']\"</code></p> <p>To ignore Python files in all PRs using <code>glob</code> pattern, set in a configuration file:</p> <pre><code>[ignore]\nglob = ['*.py']\n</code></pre> <p>And to ignore Python files in all PRs using <code>regex</code> pattern, set in a configuration file:</p> <pre><code>[ignore]\nregex = ['.*\\.py$']\n</code></pre>"},{"location":"usage-guide/additional_configurations/#extra-instructions","title":"Extra instructions","text":"<p>All Qodo Merge tools have a parameter called <code>extra_instructions</code>, that enables to add free-text extra instructions. Example usage:</p> <pre><code>/update_changelog --pr_update_changelog.extra_instructions=\"Make sure to update also the version ...\"\n</code></pre>"},{"location":"usage-guide/additional_configurations/#language-settings","title":"Language Settings","text":"<p>The default response language for Qodo Merge is U.S. English. However, some development teams may prefer to display information in a different language. For example, your team's workflow might improve if PR descriptions and code suggestions are set to your country's native language.</p> <p>To configure this, set the <code>response_language</code> parameter in the configuration file. This will prompt the model to respond in the specified language. Use a standard locale code based on ISO 3166 (country codes) and ISO 639 (language codes) to define a language-country pair. See this comprehensive list of locale codes.</p> <p>Example:</p> <pre><code>[config]\nresponse_language = \"it-IT\"\n</code></pre> <p>This will set the response language globally for all the commands to Italian.</p> <p>Important: Note that only dynamic text generated by the AI model is translated to the configured language. Static text such as labels and table headers that are not part of the AI models response will remain in US English. In addition, the model you are using must have good support for the specified language.</p>"},{"location":"usage-guide/additional_configurations/#expand-gitlab-submodule-diffs","title":"Expand GitLab submodule diffs","text":"<p>By default, GitLab merge requests show submodule updates as <code>Subproject commit</code> lines. To include the actual file-level changes from those submodules in Qodo Merge analysis, enable:</p> <pre><code>[gitlab]\nexpand_submodule_diffs = true\n</code></pre> <p>When enabled, Qodo Merge will fetch and attach diffs from the submodule repositories. The default is <code>false</code> to avoid extra GitLab API calls.</p>"},{"location":"usage-guide/additional_configurations/#log-level","title":"Log Level","text":"<p>Qodo Merge allows you to control the verbosity of logging by using the <code>log_level</code> configuration parameter. This is particularly useful for troubleshooting and debugging issues with your PR workflows.</p> <pre><code>[config]\nlog_level = \"DEBUG\"  # Options: \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"\n</code></pre> <p>The default log level is \"DEBUG\", which provides detailed output of all operations. If you prefer less verbose logs, you can set higher log levels like \"INFO\" or \"WARNING\".</p>"},{"location":"usage-guide/additional_configurations/#integrating-with-logging-observability-platforms","title":"Integrating with Logging Observability Platforms","text":"<p>Various logging observability tools can be used out-of-the box when using the default LiteLLM AI Handler. Simply configure the LiteLLM callback settings in <code>configuration.toml</code> and set environment variables according to the LiteLLM documentation.</p> <p>For example, to use LangSmith you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[litellm]\nenable_callbacks = true\nsuccess_callback = [\"langsmith\"]\nfailure_callback = [\"langsmith\"]\nservice_callback = []\n</code></pre> <p>Then set the following environment variables:</p> <pre><code>LANGSMITH_API_KEY=&lt;api_key&gt;\nLANGSMITH_PROJECT=&lt;project&gt;\nLANGSMITH_BASE_URL=&lt;url&gt;\n</code></pre>"},{"location":"usage-guide/additional_configurations/#bringing-additional-repository-metadata-to-qodo-merge","title":"Bringing additional repository metadata to Qodo Merge \ud83d\udc8e","text":"<p>To provide Qodo Merge tools with additional context about your project, you can enable automatic repository metadata detection. </p> <p>If you set:</p> <pre><code>[config]\nadd_repo_metadata = true\n</code></pre> <p>Qodo Merge automatically searches for repository metadata files in your PR's head branch root directory. By default, it looks for: AGENTS.MD, QODO.MD, CLAUDE.MD.</p> <p>You can also specify custom filenames to search for:</p> <pre><code>[config]\nadd_repo_metadata_file_list= [\"file1.md\", \"file2.md\", ...]\n</code></pre>"},{"location":"usage-guide/additional_configurations/#ignoring-automatic-commands-in-prs","title":"Ignoring automatic commands in PRs","text":"<p>Qodo Merge allows you to automatically ignore certain PRs based on various criteria:</p> <ul> <li>PRs with specific titles (using regex matching)</li> <li>PRs between specific branches (using regex matching)</li> <li>PRs from specific repositories (using regex matching)</li> <li>PRs not from specific folders</li> <li>PRs containing specific labels</li> <li>PRs opened by specific users</li> </ul>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-with-specific-titles","title":"Ignoring PRs with specific titles","text":"<p>To ignore PRs with a specific title such as \"[Bump]: ...\", you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_pr_title = [\"\\\\[Bump\\\\]\"]\n</code></pre> <p>Where the <code>ignore_pr_title</code> is a list of regex patterns to match the PR title you want to ignore. Default is <code>ignore_pr_title = [\"^\\\\[Auto\\\\]\", \"^Auto\"]</code>.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-between-specific-branches","title":"Ignoring PRs between specific branches","text":"<p>To ignore PRs from specific source or target branches, you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_pr_source_branches = ['develop', 'main', 'master', 'stage']\nignore_pr_target_branches = [\"qa\"]\n</code></pre> <p>Where the <code>ignore_pr_source_branches</code> and <code>ignore_pr_target_branches</code> are lists of regex patterns to match the source and target branches you want to ignore. They are not mutually exclusive, you can use them together or separately.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-from-specific-repositories","title":"Ignoring PRs from specific repositories","text":"<p>To ignore PRs from specific repositories, you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_repositories = [\"my-org/my-repo1\", \"my-org/my-repo2\"]\n</code></pre> <p>Where the <code>ignore_repositories</code> is a list of regex patterns to match the repositories you want to ignore. This is useful when you have multiple repositories and want to exclude certain ones from analysis.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-not-from-specific-folders","title":"Ignoring PRs not from specific folders","text":"<p>To allow only specific folders (often needed in large monorepos), set:</p> <pre><code>[config]\nallow_only_specific_folders=['folder1','folder2']\n</code></pre> <p>For the configuration above, automatic feedback will only be triggered when the PR changes include files where 'folder1' or 'folder2' is in the file path</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-containing-specific-labels","title":"Ignoring PRs containing specific labels","text":"<p>To ignore PRs containing specific labels, you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_pr_labels = [\"do-not-merge\"]\n</code></pre> <p>Where the <code>ignore_pr_labels</code> is a list of labels that when present in the PR, the PR will be ignored.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-prs-from-specific-users","title":"Ignoring PRs from specific users","text":"<p>Qodo Merge tries to automatically identify and ignore pull requests created by bots using:</p> <ul> <li>GitHub's native bot detection system</li> <li>Name-based pattern matching</li> </ul> <p>While this detection is robust, it may not catch all cases, particularly when:</p> <ul> <li>Bots are registered as regular user accounts</li> <li>Bot names don't match common patterns</li> </ul> <p>To supplement the automatic bot detection, you can manually specify users to ignore. Add the following to your <code>configuration.toml</code> file to ignore PRs from specific users:</p> <pre><code>[config]\nignore_pr_authors = [\"my-special-bot-user\", ...]\n</code></pre> <p>Where the <code>ignore_pr_authors</code> is a regex list of usernames that you want to ignore.</p> <p>Note</p> <p>There is one specific case where bots will receive an automatic response - when they generated a PR with a failed test. In that case, the <code>ci_feedback</code> tool will be invoked.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-generated-files-by-languageframework","title":"Ignoring Generated Files by Language/Framework","text":"<p>To automatically exclude files generated by specific languages or frameworks, you can add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_language_framework = ['protobuf', ...]\n</code></pre> <p>You can view the list of auto-generated file patterns in <code>generated_code_ignore.toml</code>. Files matching these glob patterns will be automatically excluded from PR Agent analysis.</p>"},{"location":"usage-guide/additional_configurations/#ignoring-tickets-with-specific-labels","title":"Ignoring Tickets with Specific Labels","text":"<p>When Qodo Merge analyzes tickets (JIRA, GitHub Issues, GitLab Issues, etc.) referenced in your PR, you may want to exclude tickets that have certain labels from the analysis. This is useful for filtering out tickets marked as \"ignore-compliance\", \"skip-review\", or other labels that indicate the ticket should not be considered during PR review.</p> <p>To ignore tickets with specific labels, add the following to your <code>configuration.toml</code> file:</p> <pre><code>[config]\nignore_ticket_labels = [\"ignore-compliance\", \"skip-review\", \"wont-fix\"]\n</code></pre> <p>Where <code>ignore_ticket_labels</code> is a list of label names that should be ignored during ticket analysis.</p>"},{"location":"usage-guide/automations_and_usage/","title":"Usage and Automation","text":""},{"location":"usage-guide/automations_and_usage/#local-repo-cli","title":"Local repo (CLI)","text":"<p>When running from your locally cloned Qodo Merge repo (CLI), your local configuration file will be used. Examples of invoking the different tools via the CLI:</p> <ul> <li>Review:       <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  review</code></li> <li>Describe:     <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  describe</code></li> <li>Improve:      <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  improve</code></li> <li>Ask:          <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  ask \"Write me a poem about this PR\"</code></li> <li>Update Changelog:      <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  update_changelog</code></li> </ul> <p><code>&lt;pr_url&gt;</code> is the url of the relevant PR (for example: #50).</p> <p>Notes:</p> <ol> <li>in addition to editing your local configuration file, you can also change any configuration value by adding it to the command line:</li> </ol> <pre><code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  /review --pr_reviewer.extra_instructions=\"focus on the file: ...\"\n</code></pre> <ol> <li>You can print results locally, without publishing them, by setting in <code>configuration.toml</code>:</li> </ol> <pre><code>[config]\npublish_output=false\nverbosity_level=2\n</code></pre> <p>This is useful for debugging or experimenting with different tools.</p> <ol> <li>git provider: The git_provider field in a configuration file determines the GIT provider that will be used by Qodo Merge. Currently, the following providers are supported: <code>github</code> (default), <code>gitlab</code>, <code>bitbucket</code>, <code>azure</code>, <code>codecommit</code>, <code>local</code>, and <code>gitea</code>.</li> </ol>"},{"location":"usage-guide/automations_and_usage/#cli-health-check","title":"CLI Health Check","text":"<p>To verify that Qodo Merge has been configured correctly, you can run this health check command from the repository root:</p> <pre><code>python -m tests.health_test.main\n</code></pre> <p>If the health check passes, you will see the following output:</p> <pre><code>========\nHealth test passed successfully\n========\n</code></pre> <p>At the end of the run.</p> <p>Before running the health check, ensure you have:</p> <ul> <li>Configured your LLM provider</li> <li>Added a valid GitHub token to your configuration file</li> </ul>"},{"location":"usage-guide/automations_and_usage/#online-usage","title":"Online usage","text":"<p>Online usage means invoking Qodo Merge tools by comments on a PR. Commands for invoking the different tools via comments:</p> <ul> <li>Review:       <code>/review</code></li> <li>Describe:     <code>/describe</code></li> <li>Improve:      <code>/improve</code>  (or <code>/improve_code</code> for bitbucket, since <code>/improve</code> is sometimes reserved)</li> <li>Ask:          <code>/ask \"...\"</code></li> <li>Update Changelog:      <code>/update_changelog</code></li> </ul> <p>To edit a specific configuration value, just add <code>--config_path=&lt;value&gt;</code> to any command. For example, if you want to edit the <code>review</code> tool configurations, you can run:</p> <pre><code>/review --pr_reviewer.extra_instructions=\"...\" --pr_reviewer.require_score_review=false\n</code></pre> <p>Any configuration value in configuration file file can be similarly edited. Comment <code>/config</code> to see the list of available configurations.</p>"},{"location":"usage-guide/automations_and_usage/#qodo-merge-automatic-feedback","title":"Qodo Merge Automatic Feedback","text":""},{"location":"usage-guide/automations_and_usage/#disabling-all-automatic-feedback","title":"Disabling all automatic feedback","text":"<p>To easily disable all automatic feedback from Qodo Merge (GitHub App, GitLab Webhook, BitBucket App, Azure DevOps Webhook), set in a configuration file:</p> <pre><code>[config]\ndisable_auto_feedback = true\n</code></pre> <p>When this parameter is set to <code>true</code>, Qodo Merge will not run any automatic tools (like <code>describe</code>, <code>review</code>, <code>improve</code>) when a new PR is opened, or when new code is pushed to an open PR.</p>"},{"location":"usage-guide/automations_and_usage/#github-app","title":"GitHub App","text":"<p>Configurations for Qodo Merge</p> <p>Qodo Merge for GitHub is an App, hosted by Qodo. So all the instructions below are relevant also for Qodo Merge users. Same goes for GitLab webhook and BitBucket App sections.</p>"},{"location":"usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened","title":"GitHub app automatic tools when a new PR is opened","text":"<p>The github_app section defines GitHub app specific configurations.</p> <p>The configuration parameter <code>pr_commands</code> defines the list of tools that will be run automatically when a new PR is opened:</p> <pre><code>[github_app]\npr_commands = [\n    \"/describe\",\n    \"/review\",\n    \"/improve\",\n]\n</code></pre> <p>This means that when a new PR is opened/reopened or marked as ready for review, Qodo Merge will run the <code>describe</code>, <code>review</code> and <code>improve</code> tools.  </p> <p>Draft PRs: </p> <p>By default, draft PRs are not considered for automatic tools, but you can change this by setting the <code>feedback_on_draft_pr</code> parameter to <code>true</code> in the configuration file.</p> <pre><code>[github_app]\nfeedback_on_draft_pr = true\n</code></pre> <p>Changing default tool parameters:</p> <p>You can override the default tool parameters by using one the three options for a configuration file: wiki, local, or global. For example, if your configuration file contains:</p> <pre><code>[pr_description]\ngenerate_ai_title = true\n</code></pre> <p>Every time you run the <code>describe</code> tool (including automatic runs) the PR title will be generated by the AI.</p> <p>Parameters for automated runs:</p> <p>You can customize configurations specifically for automated runs by using the <code>--config_path=&lt;value&gt;</code> parameter. For instance, to modify the <code>review</code> tool settings only for newly opened PRs, use:</p> <pre><code>[github_app]\npr_commands = [\n    \"/describe\",\n    \"/review --pr_reviewer.extra_instructions='focus on the file: ...'\",\n    \"/improve\",\n]\n</code></pre>"},{"location":"usage-guide/automations_and_usage/#github-app-automatic-tools-for-push-actions-commits-to-an-open-pr","title":"GitHub app automatic tools for push actions (commits to an open PR)","text":"<p>In addition to running automatic tools when a PR is opened, the GitHub app can also respond to new code that is pushed to an open PR.</p> <p>The configuration toggle <code>handle_push_trigger</code> can be used to enable this feature. The configuration parameter <code>push_commands</code> defines the list of tools that will be run automatically when new code is pushed to the PR.</p> <pre><code>[github_app]\nhandle_push_trigger = true\npush_commands = [\n    \"/describe\",\n    \"/review\",\n]\n</code></pre> <p>This means that when new code is pushed to the PR, the Qodo Merge will run the <code>describe</code> and <code>review</code> tools, with the specified parameters.</p>"},{"location":"usage-guide/automations_and_usage/#github-action","title":"GitHub Action","text":"<p><code>GitHub Action</code> is a different way to trigger Qodo Merge tools, and uses a different configuration mechanism than <code>GitHub App</code>. You can configure settings for <code>GitHub Action</code> by adding environment variables under the env section in <code>.github/workflows/pr_agent.yml</code> file. Specifically, start by setting the following environment variables:</p> <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }} # Make sure to add your OpenAI key to your repo secrets\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Make sure to add your GitHub token to your repo secrets\n        github_action_config.auto_review: \"true\" # enable\\disable auto review\n        github_action_config.auto_describe: \"true\" # enable\\disable auto describe\n        github_action_config.auto_improve: \"true\" # enable\\disable auto improve\n        github_action_config.pr_actions: '[\"opened\", \"reopened\", \"ready_for_review\", \"review_requested\"]'\n</code></pre> <p><code>github_action_config.auto_review</code>, <code>github_action_config.auto_describe</code> and <code>github_action_config.auto_improve</code> are used to enable/disable automatic tools that run when a new PR is opened. If not set, the default configuration is for all three tools to run automatically when a new PR is opened.</p> <p><code>github_action_config.pr_actions</code> is used to configure which <code>pull_requests</code> events will trigger the enabled auto flags If not set, the default configuration is <code>[\"opened\", \"reopened\", \"ready_for_review\", \"review_requested\"]</code></p> <p><code>github_action_config.enable_output</code> are used to enable/disable github actions output parameter (default is <code>true</code>). Review result is output as JSON to <code>steps.{step-id}.outputs.review</code> property. The JSON structure is equivalent to the yaml data structure defined in pr_reviewer_prompts.toml.</p> <p>Note that you can give additional config parameters by adding environment variables to <code>.github/workflows/pr_agent.yml</code>, or by using a <code>.pr_agent.toml</code> configuration file in the root of your repo</p> <p>For example, you can set an environment variable: <code>pr_description.publish_labels=false</code>, or add a <code>.pr_agent.toml</code> file with the following content:</p> <pre><code>[pr_description]\npublish_labels = false\n</code></pre> <p>to prevent Qodo Merge from publishing labels when running the <code>describe</code> tool.</p>"},{"location":"usage-guide/automations_and_usage/#enable-using-commands-in-pr","title":"Enable using commands in PR","text":"<p>You can configure your GitHub Actions workflow to trigger on <code>issue_comment</code> events (<code>created</code> and <code>edited</code>).</p> <p>Example GitHub Actions workflow configuration:</p> <pre><code>on:\n  issue_comment:\n    types: [created, edited]\n</code></pre> <p>When this is configured, Qodo merge can be invoked by commenting on the PR.</p>"},{"location":"usage-guide/automations_and_usage/#quick-reference-model-configuration-in-github-actions","title":"Quick Reference: Model Configuration in GitHub Actions","text":"<p>For detailed step-by-step examples of configuring different models (Gemini, Claude, Azure OpenAI, etc.) in GitHub Actions, see the Configuration Examples section in the installation guide.</p> <p>Common Model Configuration Patterns:</p> <ul> <li>OpenAI: Set <code>config.model: \"gpt-4o\"</code> and <code>OPENAI_KEY</code></li> <li>Gemini: Set <code>config.model: \"gemini/gemini-1.5-flash\"</code> and <code>GOOGLE_AI_STUDIO.GEMINI_API_KEY</code> (no <code>OPENAI_KEY</code> needed)</li> <li>Claude: Set <code>config.model: \"anthropic/claude-3-opus-20240229\"</code> and <code>ANTHROPIC.KEY</code> (no <code>OPENAI_KEY</code> needed)</li> <li>Azure OpenAI: Set <code>OPENAI.API_TYPE: \"azure\"</code>, <code>OPENAI.API_BASE</code>, and <code>OPENAI.DEPLOYMENT_ID</code></li> <li>Local Models: Set <code>config.model: \"ollama/model-name\"</code> and <code>OLLAMA.API_BASE</code></li> </ul> <p>Environment Variable Format: - Use dots (<code>.</code>) to separate sections and keys: <code>config.model</code>, <code>pr_reviewer.extra_instructions</code> - Boolean values as strings: <code>\"true\"</code> or <code>\"false\"</code> - Arrays as JSON strings: <code>'[\"item1\", \"item2\"]'</code></p> <p>For complete model configuration details, see Changing a model in PR-Agent.</p>"},{"location":"usage-guide/automations_and_usage/#gitlab-webhook","title":"GitLab Webhook","text":"<p>After setting up a GitLab webhook, to control which commands will run automatically when a new MR is opened, you can set the <code>pr_commands</code> parameter in the configuration file, similar to the GitHub App:</p> <pre><code>[gitlab]\npr_commands = [\n    \"/describe\",\n    \"/review\",\n    \"/improve\",\n]\n</code></pre> <p>the GitLab webhook can also respond to new code that is pushed to an open MR. The configuration toggle <code>handle_push_trigger</code> can be used to enable this feature. The configuration parameter <code>push_commands</code> defines the list of tools that will be run automatically when new code is pushed to the MR.</p> <pre><code>[gitlab]\nhandle_push_trigger = true\npush_commands = [\n    \"/describe\",\n    \"/review\",\n]\n</code></pre> <p>Note that to use the 'handle_push_trigger' feature, you need to give the gitlab webhook also the \"Push events\" scope.</p>"},{"location":"usage-guide/automations_and_usage/#bitbucket-app","title":"BitBucket App","text":"<p>Similar to GitHub app, when running Qodo Merge from BitBucket App, the default configuration file will be initially loaded.</p> <p>By uploading a local <code>.pr_agent.toml</code> file to the root of the repo's default branch, you can edit and customize any configuration parameter. Note that you need to upload <code>.pr_agent.toml</code> prior to creating a PR, in order for the configuration to take effect.</p> <p>For example, if your local <code>.pr_agent.toml</code> file contains:</p> <pre><code>[pr_reviewer]\nextra_instructions = \"Answer in japanese\"\n</code></pre> <p>Each time you invoke a <code>/review</code> tool, it will use the extra instructions you set in the local configuration file.</p> <p>Note that among other limitations, BitBucket provides relatively low rate-limits for applications (up to 1000 requests per hour), and does not provide an API to track the actual rate-limit usage. If you experience a lack of responses from Qodo Merge, you might want to set: <code>bitbucket_app.avoid_full_files=true</code> in your configuration file. This will prevent Qodo Merge from acquiring the full file content, and will only use the diff content. This will reduce the number of requests made to BitBucket, at the cost of small decrease in accuracy, as dynamic context will not be applicable.</p>"},{"location":"usage-guide/automations_and_usage/#bitbucket-self-hosted-app-automatic-tools","title":"BitBucket Self-Hosted App automatic tools","text":"<p>To control which commands will run automatically when a new PR is opened, you can set the <code>pr_commands</code> parameter in the configuration file: Specifically, set the following values:</p> <pre><code>[bitbucket_app]\npr_commands = [\n    \"/review\",\n    \"/improve --pr_code_suggestions.commitable_code_suggestions=true --pr_code_suggestions.suggestions_score_threshold=7\",\n]\n</code></pre> <p>Note that we set specifically for bitbucket, we recommend using: <code>--pr_code_suggestions.suggestions_score_threshold=7</code> and that is the default value we set for bitbucket. Since this platform only supports inline code suggestions, we want to limit the number of suggestions, and only present a limited number.</p> <p>To enable BitBucket app to respond to each push to the PR, set (for example):</p> <pre><code>[bitbucket_app]\nhandle_push_trigger = true\npush_commands = [\n    \"/describe\",\n    \"/review\",\n]\n</code></pre>"},{"location":"usage-guide/automations_and_usage/#azure-devops-provider","title":"Azure DevOps provider","text":"<p>To use Azure DevOps provider use the following settings in configuration.toml:</p> <pre><code>[config]\ngit_provider=\"azure\"\n</code></pre> <p>Azure DevOps provider supports PAT token or DefaultAzureCredential authentication. PAT is faster to create, but has build in expiration date, and will use the user identity for API calls. Using DefaultAzureCredential you can use managed identity or Service principle, which are more secure and will create separate ADO user identity (via AAD) to the agent.</p> <p>If PAT was chosen, you can assign the value in .secrets.toml. If DefaultAzureCredential was chosen, you can assigned the additional env vars like AZURE_CLIENT_SECRET directly, or use managed identity/az cli (for local development) without any additional configuration. in any case, 'org' value must be assigned in .secrets.toml:</p> <pre><code>[azure_devops]\norg = \"https://dev.azure.com/YOUR_ORGANIZATION/\"\n# pat = \"YOUR_PAT_TOKEN\" needed only if using PAT for authentication\n</code></pre>"},{"location":"usage-guide/automations_and_usage/#azure-devops-webhook","title":"Azure DevOps Webhook","text":"<p>To control which commands will run automatically when a new PR is opened, you can set the <code>pr_commands</code> parameter in the configuration file, similar to the GitHub App:</p> <pre><code>[azure_devops_server]\npr_commands = [\n    \"/describe\",\n    \"/review\",\n    \"/improve\",\n]\n</code></pre>"},{"location":"usage-guide/automations_and_usage/#gitea-webhook","title":"Gitea Webhook","text":"<p>After setting up a Gitea webhook, to control which commands will run automatically when a new MR is opened, you can set the <code>pr_commands</code> parameter in the configuration file, similar to the GitHub App:</p> <pre><code>[gitea]\npr_commands = [\n    \"/describe\",\n    \"/review\",\n    \"/improve\",\n]\n</code></pre>"},{"location":"usage-guide/changing_a_model/","title":"Changing a Model","text":""},{"location":"usage-guide/changing_a_model/#changing-a-model-in-pr-agent","title":"Changing a model in PR-Agent","text":"<p>See here for a list of supported models in PR-Agent. The default model of PR-Agent is <code>GPT-5</code> from OpenAI. To use a different model than the default, you need to edit in the configuration file the fields:</p> <pre><code>[config]\nmodel = \"...\"\nfallback_models = [\"...\"]\n</code></pre> <p>For models and environments not from OpenAI, you might need to provide additional keys and other parameters. You can give parameters via a configuration file, or from environment variables.</p> <p>Model-specific environment variables</p> <p>See litellm documentation for the environment variables needed per model, as they may vary and change over time. Our documentation per-model may not always be up-to-date with the latest changes. Failing to set the needed keys of a specific model will usually result in litellm not identifying the model type, and failing to utilize it.</p>"},{"location":"usage-guide/changing_a_model/#openai-like-api","title":"OpenAI like API","text":"<p>To use an OpenAI like API, set the following in your <code>.secrets.toml</code> file:</p> <pre><code>[openai]\napi_base = \"https://api.openai.com/v1\"\napi_key = \"sk-...\"\n</code></pre> <p>or use the environment variables (make sure to use double underscores <code>__</code>):</p> <pre><code>OPENAI__API_BASE=https://api.openai.com/v1\nOPENAI__KEY=sk-...\n</code></pre>"},{"location":"usage-guide/changing_a_model/#openai-flex-processing","title":"OpenAI Flex Processing","text":"<p>To reduce costs for non-urgent/background tasks, enable Flex Processing:</p> <pre><code>[litellm]\nextra_body='{\"processing_mode\": \"flex\"}'\n</code></pre> <p>See OpenAI Flex Processing docs for details.</p>"},{"location":"usage-guide/changing_a_model/#azure","title":"Azure","text":"<p>To use Azure, set in your <code>.secrets.toml</code> (working from CLI), or in the GitHub <code>Settings &gt; Secrets and variables</code> (working from GitHub App or GitHub Action):</p> <pre><code>[openai]\nkey = \"\" # your azure api key\napi_type = \"azure\"\napi_version = '2023-05-15'  # Check Azure documentation for the current API version\napi_base = \"\"  # The base URL for your Azure OpenAI resource. e.g. \"https://&lt;your resource name&gt;.openai.azure.com\"\ndeployment_id = \"\"  # The deployment name you chose when you deployed the engine\n</code></pre> <p>and set in your configuration file:</p> <pre><code>[config]\nmodel=\"\" # the OpenAI model you've deployed on Azure (e.g. gpt-4o)\nfallback_models=[\"...\"]\n</code></pre> <p>To use Azure AD (Entra id) based authentication set in your <code>.secrets.toml</code> (working from CLI), or in the GitHub <code>Settings &gt; Secrets and variables</code> (working from GitHub App or GitHub Action):</p> <pre><code>[azure_ad]\nclient_id = \"\"  # Your Azure AD application client ID\nclient_secret = \"\"  # Your Azure AD application client secret\ntenant_id = \"\"  # Your Azure AD tenant ID\napi_base = \"\"  # Your Azure OpenAI service base URL (e.g., https://openai.xyz.com/)\n</code></pre> <p>Passing custom headers to the underlying LLM Model API can be done by setting extra_headers parameter to litellm.</p> <pre><code>[litellm]\nextra_headers='{\"projectId\": \"&lt;authorized projectId &gt;\", ...}') #The value of this setting should be a JSON string representing the desired headers, a ValueError is thrown otherwise.\n</code></pre> <p>This enables users to pass authorization tokens or API keys, when routing requests through an API management gateway.</p>"},{"location":"usage-guide/changing_a_model/#ollama","title":"Ollama","text":"<p>You can run models locally through either VLLM or Ollama</p> <p>E.g. to use a new model locally via Ollama, set in <code>.secrets.toml</code> or in a configuration file:</p> <pre><code>[config]\nmodel = \"ollama/qwen2.5-coder:32b\"\nfallback_models=[\"ollama/qwen2.5-coder:32b\"]\ncustom_model_max_tokens=128000 # set the maximal input tokens for the model\nduplicate_examples=true # will duplicate the examples in the prompt, to help the model to generate structured output\n\n[ollama]\napi_base = \"http://localhost:11434\" # or whatever port you're running Ollama on\n</code></pre> <p>By default, Ollama uses a context window size of 2048 tokens. In most cases this is not enough to cover pr-agent prompt and pull-request diff. Context window size can be overridden with the <code>OLLAMA_CONTEXT_LENGTH</code> environment variable. For example, to set the default context length to 8K, use: <code>OLLAMA_CONTEXT_LENGTH=8192 ollama serve</code>. More information you can find on the official ollama faq.</p> <p>Please note that the <code>custom_model_max_tokens</code> setting should be configured in accordance with the <code>OLLAMA_CONTEXT_LENGTH</code>. Failure to do so may result in unexpected model output.</p> <p>Local models vs commercial models</p> <p>Qodo Merge is compatible with almost any AI model, but analyzing complex code repositories and pull requests requires a model specifically optimized for code analysis.</p> <p>Commercial models such as GPT-5, Claude Sonnet, and Gemini have demonstrated robust capabilities in generating structured output for code analysis tasks with large input. In contrast, most open-source models currently available (as of January 2025) face challenges with these complex tasks.</p> <p>Based on our testing, local open-source models are suitable for experimentation and learning purposes (mainly for the <code>ask</code> command), but they are not suitable for production-level code analysis tasks.</p> <p>Hence, for production workflows and real-world usage, we recommend using commercial models.</p>"},{"location":"usage-guide/changing_a_model/#hugging-face","title":"Hugging Face","text":"<p>To use a new model with Hugging Face Inference Endpoints, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"huggingface/meta-llama/Llama-2-7b-chat-hf\"\nfallback_models=[\"huggingface/meta-llama/Llama-2-7b-chat-hf\"]\ncustom_model_max_tokens=... # set the maximal input tokens for the model\n\n[huggingface] # in .secrets.toml\nkey = ... # your Hugging Face api key\napi_base = ... # the base url for your Hugging Face inference endpoint\n</code></pre> <p>(you can obtain a Llama2 key from here)</p>"},{"location":"usage-guide/changing_a_model/#replicate","title":"Replicate","text":"<p>To use Llama2 model with Replicate, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"replicate/llama-2-70b-chat:2c1608e18606fad2812020dc541930f2d0495ce32eee50074220b87300bc16e1\"\nfallback_models=[\"replicate/llama-2-70b-chat:2c1608e18606fad2812020dc541930f2d0495ce32eee50074220b87300bc16e1\"]\n[replicate] # in .secrets.toml\nkey = ...\n</code></pre> <p>(you can obtain a Llama2 key from here)</p> <p>Also, review the AiHandler file for instructions on how to set keys for other models.</p>"},{"location":"usage-guide/changing_a_model/#groq","title":"Groq","text":"<p>To use Llama3 model with Groq, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"llama3-70b-8192\"\nfallback_models = [\"groq/llama3-70b-8192\"]\n[groq] # in .secrets.toml\nkey = ... # your Groq api key\n</code></pre> <p>(you can obtain a Groq key from here)</p>"},{"location":"usage-guide/changing_a_model/#xai","title":"xAI","text":"<p>To use xAI's models with PR-Agent, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"xai/grok-2-latest\"\nfallback_models = [\"xai/grok-2-latest\"] # or any other model as fallback\n\n[xai] # in .secrets.toml\nkey = \"...\" # your xAI API key\n</code></pre> <p>You can obtain an xAI API key from xAI's console by creating an account and navigating to the developer settings page.</p>"},{"location":"usage-guide/changing_a_model/#vertex-ai","title":"Vertex AI","text":"<p>To use Google's Vertex AI platform and its associated models (chat-bison/codechat-bison) set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"vertex_ai/codechat-bison\"\nfallback_models=\"vertex_ai/codechat-bison\"\n\n[vertexai] # in .secrets.toml\nvertex_project = \"my-google-cloud-project\"\nvertex_location = \"\"\n</code></pre> <p>Your application default credentials will be used for authentication so there is no need to set explicit credentials in most environments.</p> <p>If you do want to set explicit credentials, then you can use the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable set to a path to a json credentials file.</p>"},{"location":"usage-guide/changing_a_model/#google-ai-studio","title":"Google AI Studio","text":"<p>To use Google AI Studio models, set the relevant models in the configuration section of the configuration file:</p> <pre><code>[config] # in configuration.toml\nmodel=\"gemini/gemini-1.5-flash\"\nfallback_models=[\"gemini/gemini-1.5-flash\"]\n\n[google_ai_studio] # in .secrets.toml\ngemini_api_key = \"...\"\n</code></pre> <p>If you don't want to set the API key in the .secrets.toml file, you can set the <code>GOOGLE_AI_STUDIO.GEMINI_API_KEY</code> environment variable.</p>"},{"location":"usage-guide/changing_a_model/#anthropic","title":"Anthropic","text":"<p>To use Anthropic models, set the relevant models in the configuration section of the configuration file:</p> <pre><code>[config]\nmodel=\"anthropic/claude-3-opus-20240229\"\nfallback_models=[\"anthropic/claude-3-opus-20240229\"]\n</code></pre> <p>And also set the api key in the .secrets.toml file:</p> <pre><code>[anthropic]\nKEY = \"...\"\n</code></pre> <p>See litellm documentation for more information about the environment variables required for Anthropic.</p>"},{"location":"usage-guide/changing_a_model/#amazon-bedrock","title":"Amazon Bedrock","text":"<p>To use Amazon Bedrock and its foundational models, add the below configuration:</p> <pre><code>[config] # in configuration.toml\nmodel=\"bedrock/anthropic.claude-3-5-sonnet-20240620-v1:0\"\nfallback_models=[\"bedrock/anthropic.claude-3-5-sonnet-20240620-v1:0\"]\n\n[aws]\nAWS_ACCESS_KEY_ID=\"...\"\nAWS_SECRET_ACCESS_KEY=\"...\"\nAWS_REGION_NAME=\"...\"\n</code></pre> <p>You can also use the new Meta Llama 4 models available on Amazon Bedrock:</p> <pre><code>[config] # in configuration.toml\nmodel=\"bedrock/us.meta.llama4-scout-17b-instruct-v1:0\"\nfallback_models=[\"bedrock/us.meta.llama4-maverick-17b-instruct-v1:0\"]\n</code></pre>"},{"location":"usage-guide/changing_a_model/#custom-inference-profiles","title":"Custom Inference Profiles","text":"<p>To use a custom inference profile with Amazon Bedrock (for cost allocation tags and other configuration settings), add the <code>model_id</code> parameter to your configuration:</p> <pre><code>[config] # in configuration.toml\nmodel=\"bedrock/anthropic.claude-3-5-sonnet-20240620-v1:0\"\nfallback_models=[\"bedrock/anthropic.claude-3-5-sonnet-20240620-v1:0\"]\n\n[aws]\nAWS_ACCESS_KEY_ID=\"...\"\nAWS_SECRET_ACCESS_KEY=\"...\"\nAWS_REGION_NAME=\"...\"\n\n[litellm]\nmodel_id = \"your-custom-inference-profile-id\"\n</code></pre> <p>The <code>model_id</code> parameter will be passed to all Bedrock completion calls, allowing you to use custom inference profiles for better cost allocation and reporting.</p> <p>See litellm documentation for more information about the environment variables required for Amazon Bedrock.</p>"},{"location":"usage-guide/changing_a_model/#deepseek","title":"DeepSeek","text":"<p>To use deepseek-chat model with DeepSeek, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"deepseek/deepseek-chat\"\nfallback_models=[\"deepseek/deepseek-chat\"]\n</code></pre> <p>and fill up your key</p> <pre><code>[deepseek] # in .secrets.toml\nkey = ...\n</code></pre> <p>(you can obtain a deepseek-chat key from here)</p>"},{"location":"usage-guide/changing_a_model/#deepinfra","title":"DeepInfra","text":"<p>To use DeepSeek model with DeepInfra, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"deepinfra/deepseek-ai/DeepSeek-R1-Distill-Llama-70B\"\nfallback_models = [\"deepinfra/deepseek-ai/DeepSeek-R1-Distill-Qwen-32B\"]\n[deepinfra] # in .secrets.toml\nkey = ... # your DeepInfra api key\n</code></pre> <p>(you can obtain a DeepInfra key from here)</p>"},{"location":"usage-guide/changing_a_model/#mistral","title":"Mistral","text":"<p>To use models like Mistral or Codestral with Mistral, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"mistral/mistral-small-latest\"\nfallback_models = [\"mistral/mistral-medium-latest\"]\n[mistral] # in .secrets.toml\nkey = \"...\" # your Mistral api key\n</code></pre> <p>(you can obtain a Mistral key from here)</p>"},{"location":"usage-guide/changing_a_model/#codestral","title":"Codestral","text":"<p>To use Codestral model with Codestral, for example, set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"codestral/codestral-latest\"\nfallback_models = [\"codestral/codestral-2405\"]\n[codestral] # in .secrets.toml\nkey = \"...\" # your Codestral api key\n</code></pre> <p>(you can obtain a Codestral key from here)</p>"},{"location":"usage-guide/changing_a_model/#openrouter","title":"Openrouter","text":"<p>To use model from Openrouter, for example, set:</p> <pre><code>[config] # in configuration.toml \nmodel=\"openrouter/anthropic/claude-3.7-sonnet\"\nfallback_models=[\"openrouter/deepseek/deepseek-chat\"]\ncustom_model_max_tokens=20000\n\n[openrouter]  # in .secrets.toml or passed an environment variable openrouter__key\nkey = \"...\" # your openrouter api key\n</code></pre> <p>(you can obtain an Openrouter API key from here)</p>"},{"location":"usage-guide/changing_a_model/#custom-models","title":"Custom models","text":"<p>If the relevant model doesn't appear here, you can still use it as a custom model:</p> <ol> <li>Set the model name in the configuration file:</li> </ol> <pre><code>[config]\nmodel=\"custom_model_name\"\nfallback_models=[\"custom_model_name\"]\n</code></pre> <ol> <li>Set the maximal tokens for the model:</li> </ol> <pre><code>[config]\ncustom_model_max_tokens= ...\n</code></pre> <ol> <li> <p>Go to litellm documentation, find the model you want to use, and set the relevant environment variables.</p> </li> <li> <p>Most reasoning models do not support chat-style inputs (<code>system</code> and <code>user</code> messages) or temperature settings. To bypass chat templates and temperature controls, set <code>config.custom_reasoning_model = true</code> in your configuration file.</p> </li> </ol>"},{"location":"usage-guide/changing_a_model/#dedicated-parameters","title":"Dedicated parameters","text":""},{"location":"usage-guide/changing_a_model/#openai-models","title":"OpenAI models","text":"<pre><code>[config]\nreasoning_effort = \"medium\" # \"low\", \"medium\", \"high\"\n</code></pre> <p>With the OpenAI models that support reasoning effort (eg: o4-mini), you can specify its reasoning effort via <code>config</code> section. The default value is <code>medium</code>. You can change it to <code>high</code> or <code>low</code> based on your usage.</p>"},{"location":"usage-guide/changing_a_model/#anthropic-models","title":"Anthropic models","text":"<pre><code>[config]\nenable_claude_extended_thinking = false # Set to true to enable extended thinking feature\nextended_thinking_budget_tokens = 2048\nextended_thinking_max_output_tokens = 4096\n</code></pre>"},{"location":"usage-guide/configuration_options/","title":"Configuration File","text":"<p>The different tools and sub-tools used by Qodo Merge are adjustable via a Git configuration file. There are three main ways to set persistent configurations:</p> <ol> <li>Wiki configuration page \ud83d\udc8e</li> <li>Local configuration file</li> <li>Global configuration file \ud83d\udc8e</li> </ol> <p>In terms of precedence, wiki configurations will override local configurations, and local configurations will override global configurations.</p> <p>For a list of all possible configurations, see the configuration options page. In addition to general configuration options, each tool has its own configurations. For example, the <code>review</code> tool will use parameters from the pr_reviewer section in the configuration file.</p> <p>Tip1: Edit only what you need</p> <p>Your configuration file should be minimal, and edit only the relevant values. Don't copy the entire configuration options, since it can lead to legacy problems when something changes.</p> <p>Tip2: Show relevant configurations</p> <p>If you set <code>config.output_relevant_configurations</code> to True, each tool will also output in a collapsible section its relevant configurations. This can be useful for debugging, or getting to know the configurations better.</p>"},{"location":"usage-guide/configuration_options/#wiki-configuration-file","title":"Wiki configuration file \ud83d\udc8e","text":"<p><code>Platforms supported: GitHub, GitLab, Bitbucket</code></p> <p>With Qodo Merge, you can set configurations by creating a page called <code>.pr_agent.toml</code> in the wiki of the repo. The advantage of this method is that it allows to set configurations without needing to commit new content to the repo - just edit the wiki page and save.</p> <p></p> <p>Click here to see a short instructional video. We recommend surrounding the configuration content with triple-quotes (or ```toml), to allow better presentation when displayed in the wiki as markdown. An example content:</p> <pre><code>[pr_description]\ngenerate_ai_title=true\n</code></pre> <p>Qodo Merge will know to remove the surrounding quotes when reading the configuration content.</p>"},{"location":"usage-guide/configuration_options/#local-configuration-file","title":"Local configuration file","text":"<p><code>Platforms supported: GitHub, GitLab, Bitbucket, Azure DevOps</code></p> <p>By uploading a local <code>.pr_agent.toml</code> file to the root of the repo's default branch, you can edit and customize any configuration parameter. Note that you need to upload or update <code>.pr_agent.toml</code> before using the PR Agent tools (either at PR creation or via manual trigger) for the configuration to take effect.</p> <p>For example, if you set in <code>.pr_agent.toml</code>:</p> <pre><code>[pr_reviewer]\nextra_instructions=\"\"\"\\\n- instruction a\n- instruction b\n...\n\"\"\"\n</code></pre> <p>Then you can give a list of extra instructions to the <code>review</code> tool.</p>"},{"location":"usage-guide/configuration_options/#global-configuration-file","title":"Global configuration file \ud83d\udc8e","text":"<p><code>Platforms supported: GitHub, GitLab, Bitbucket</code></p> <p>If you create a repo called <code>pr-agent-settings</code> in your organization, its configuration file <code>.pr_agent.toml</code> will be used as a global configuration file for any other repo that belongs to the same organization. Parameters from a local <code>.pr_agent.toml</code> file, in a specific repo, will override the global configuration parameters.</p> <p>For example, in the GitHub organization <code>Codium-ai</code>:</p> <ul> <li> <p>The file <code>https://github.com/Codium-ai/pr-agent-settings/.pr_agent.toml</code>  serves as a global configuration file for all the repos in the GitHub organization <code>Codium-ai</code>.</p> </li> <li> <p>The repo <code>https://github.com/Codium-ai/pr-agent</code> inherits the global configuration file from <code>pr-agent-settings</code>.</p> </li> </ul>"},{"location":"usage-guide/configuration_options/#bitbucket-organization-level-configuration-file","title":"Bitbucket Organization level configuration file \ud83d\udc8e","text":"<p><code>Relevant platforms: Bitbucket Data Center</code></p> <p>In Bitbucket Data Center, there are two levels where you can define a global configuration file:</p> <ul> <li>Project-level global configuration:</li> </ul> <p>Create a repository named <code>pr-agent-settings</code> within a specific project. The configuration file in this repository will apply to all repositories under the same project.</p> <ul> <li>Organization-level global configuration:</li> </ul> <p>Create a dedicated project to hold a global configuration file that affects all repositories across all projects in your organization.</p> <p>Setting up organization-level global configuration:</p> <ol> <li>Create a new project with both the name and key: PR_AGENT_SETTINGS.</li> <li>Inside the PR_AGENT_SETTINGS project, create a repository named pr-agent-settings.</li> <li>In this repository, add a <code>.pr_agent.toml</code> configuration file\u2014structured similarly to the global configuration file described above.</li> <li>Optionally, you can add organizational-level global best practices.</li> </ol> <p>Repositories across your entire Bitbucket organization will inherit the configuration from this file.</p> <p>Note</p> <p>If both organization-level and project-level global settings are defined, the project-level settings will take precedence over the organization-level configuration. Additionally, parameters from a repository\u2019s local .pr_agent.toml file will always override both global settings.</p>"},{"location":"usage-guide/enabling_a_wiki/","title":"Enabling a Wiki","text":"<p><code>Supported Git Platforms: GitHub, GitLab, Bitbucket</code></p> <p>For optimal functionality of Qodo Merge, we recommend enabling a wiki for each repository where Qodo Merge is installed. The wiki serves several important purposes:</p> <p>Key Wiki Features: \ud83d\udc8e</p> <ul> <li>Storing a configuration file</li> <li>Track accepted suggestions</li> <li>Facilitates learning over time by creating an auto_best_practices.md file</li> </ul> <p>Setup Instructions (GitHub):</p> <p>To enable a wiki for your repository:</p> <ol> <li>Navigate to your repository's main page on GitHub</li> <li>Select \"Settings\" from the top navigation bar</li> <li>Locate the \"Features\" section</li> <li>Enable the \"Wikis\" option by checking the corresponding box</li> <li>Return to your repository's main page</li> <li>Look for the newly added \"Wiki\" tab in the top navigation</li> <li>Initialize your wiki by clicking \"Create the first page\" and saving (this step is important - without creating an initial page, the wiki will not be fully functional)</li> </ol>"},{"location":"usage-guide/enabling_a_wiki/#why-wiki","title":"Why Wiki?","text":"<ul> <li>Your code (and its derivatives, including accepted code suggestions) is yours. Qodo Merge will never store it on external servers.</li> <li>Repository changes typically require pull requests, which create overhead and are time-consuming. This process is too cumbersome for auto data aggregation, and is not very convenient even for managing frequently updated content like configuration files.</li> <li>A repository wiki page provides an ideal balance:</li> <li>It lives within your repository, making it suitable for code-related documentation</li> <li>It enables quick updates without the overhead of pull requests</li> <li>It maintains full Git version control, allowing you to track changes over time.</li> </ul>"},{"location":"usage-guide/introduction/","title":"Introduction","text":"<p>After installation, there are three basic ways to invoke Qodo Merge:</p> <ol> <li>Locally running a CLI command</li> <li>Online usage - by commenting on a PR</li> <li>Enabling Qodo Merge tools to run automatically when a new PR is opened</li> </ol> <p>Specifically, CLI commands can be issued by invoking a pre-built docker image, or by invoking a locally cloned repo.</p> <p>For online usage, you will need to setup either a GitHub App or a GitHub Action (GitHub), a GitLab webhook (GitLab), or a BitBucket App (BitBucket). These platforms also enable to run Qodo Merge specific tools automatically when a new PR is opened, or on each push to a branch.</p>"},{"location":"usage-guide/mail_notifications/","title":"Managing Mail Notifications","text":"<p>Unfortunately, it is not possible in GitHub to disable mail notifications from a specific user. If you are subscribed to notifications for a repo with Qodo Merge, we recommend turning off notifications for PR comments, to avoid lengthy emails:</p> <p></p> <p>As an alternative, you can filter in your mail provider the notifications specifically from the Qodo Merge bot, see how.</p> <p></p> <p>Another option to reduce the mail overload, yet still receive notifications on Qodo Merge tools, is to disable the help collapsible section in Qodo Merge bot comments. This can done by setting <code>enable_help_text=false</code> for the relevant tool in the configuration file. For example, to disable the help text for the <code>pr_reviewer</code> tool, set:</p> <pre><code>[pr_reviewer]\nenable_help_text = false\n</code></pre>"},{"location":"usage-guide/qodo_merge_models/","title":"Qodo Merge Models","text":"<p>The default models used by Qodo Merge \ud83d\udc8e (October 2025) are a combination of GPT-5, Haiku-4.5, and Gemini 2.5 Pro.</p>"},{"location":"usage-guide/qodo_merge_models/#selecting-a-specific-model","title":"Selecting a Specific Model","text":"<p>Users can configure Qodo Merge to use only a specific model by editing the configuration file. The models supported by Qodo Merge are:</p> <ul> <li><code>gpt-5</code></li> <li><code>claude-haiku-4.5</code></li> <li><code>gemini-2.5-pro</code></li> <li><code>o4-mini</code></li> <li><code>deepseek/r1</code></li> </ul> <p>To restrict Qodo Merge to using only <code>o4-mini</code>, add this setting:</p> <pre><code>[config]\nmodel=\"o4-mini\"\n</code></pre> <p>To restrict Qodo Merge to using only <code>GPT-5</code>, add this setting:</p> <pre><code>[config]\nmodel=\"gpt-5\"\n</code></pre> <p>To restrict Qodo Merge to using only <code>gemini-2.5-pro</code>, add this setting:</p> <pre><code>[config]\nmodel=\"gemini-2.5-pro\"\n</code></pre> <p>To restrict Qodo Merge to using only <code>claude-4-sonnet</code>, add this setting:</p> <pre><code>[config]\nmodel=\"claude-4-sonnet\"\n</code></pre>"}]}